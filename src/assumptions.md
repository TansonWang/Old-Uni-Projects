# **Assumptions**
* ## **Data Types**
	* *email*
		* less than 120 char in length (name_first and name_last <= 100 char)
		* must contain an '@' symbol
		* there must be a string before and after the '@' 
	* *password*
		* less than 50 char in length
		* strong strength: chars > 10, contains atleast one symbol, one uppercase, one lowercase, and one number
		* moderate strength: chars > 8, contains atleast one number
		* weak strength: everything else
	* *new_password*
		* cannot be the same as the current password
	* *token*
		* randomly generated using a hash 
		* length of 8
		* unique and reused when user logs out
	* *name_first*
		* length < 50 char
		* doesn't contain symbols or numbers
	* *name_last*
		* length < 50 char
		* doesn't contain symbols or numbers
	* *reset_code*
		* randomly generated
		* length of 4
	* *u_id*
		* randomly generated once when a user registers
		* unique
	* *token*
		* unique while in use
		* reusable
	
	* *channel_id*
		* in a logical, linear order
		* easy to find
	* *time_finish*
		* generated by adding 15 mins to current time
	* *message*
		* length < 1000 char
		* image does not add to length
		* image can be sent with message

* ## **Authentication**
	* **auth_login**(*email, password*)
		* user cannot attempt to login when already logged in
	* **auth_logout**(*token*)
		* user cannot attempt to logout when already logged out
	* **auth_register**(*email, password, name_first, name_last*)
		* email user enters exists
		* name_first and name_last does not contain  symbols or numbers
		* password must be atleast moderate strength
		* Assuming the first person to be registered is given owner permissions, and
		  all subsaquent registrations are given member permissions.
	* **auth_passwordreset_request**(*email*)
		* if the email is invalid, gives them the option to register
		* the reset_code is auto-generated
	* **auth_passwordreset_reset**(*reset_code, new_password*)
		* new_password cannot be the same as the current password

* ## **Message**
	* **message_send**(*token, channel_id, message*)
		* that you can only send in a valid channel as it was layed out in the requirement for message_sendlater
		* that the character you are sending is supported (e.g. Unicode vs ASCII)
		* Assuming an empty message cannot be sent
		* Assuming attempting to message a channel that you're not invited to is the same as trying to message 
		  a channel that you've been revemoed from
		* Assuming Slackr owner and channel owner have the same permissions in a channel 
	* **message_sentlater**(*token, channel_id, message, time_sent*)
		* assuming the assumptions for message_send
		* limitation on how far in the future you can send a message to
		* that you can set a message to send later when you are offline
	* **message_remove**(*token, message_id*)
		* the message can be removed by the person who wrote the message, the channel owner, or server admin
		* the u_id in a message dictionary list is referring to the person who wrote the message 
		* can’t remove a message until the message is sent
		* the react and the pinning would be archived when a message is removed
		* Assuming editing a message to nothing is the same as removing that message 
		* Assuming once a message is removed it is cleared from the message history
	* **message_edit**(*token, message_id, message*)
		* can’t edit a message until the message is sent
		* the new message can’t be 1000 words long
	* **message_react**(*token, message_id, react_id*)
		* can’t give a react once the message has been removed 
	* **message_unreact**(*token, message_id, react_id*)
		* can’t unreact to a message that has already been unreacted
	* **message_pin**(*token, message_id*)
		* assume that the message dict list also contains the boolean status of whether a message is pinned 
	* **message_unpin**(*token, message_id*)
		* can’t unpin a message that has already been unpinned


* ## **Channel**
	* **channel_invite**(*token, channel_id, u_id*)
		* users are not inviting someone that is already in the channel
		* Assuming channel_invite workes pretty much the same as channel_join
	* **channel_details**(*token, channel_id*)
		* basic details contains the names of all the members in the channels
	* **channel_messages**(*token, channel_id, start*)
		* the function need to be called multiple times to return the latest message if there is more than 50 messages
	* **channel_leave**(*token, channel_id*)
		* users cannot leave a channel that they are not in
	* **channel_join**(*token, channel_id*)
		* users cannot join a channel that they are already in
	* **channel_addowner**(*token, channel_id, u_id*)
		* users cannot add a person that is already an owner of the channel
	* **channel_removeowner**(*token, channel_id, u_id*)
		* users cannot remove a person that is not an owner of the channel

* ## **User**
	* **user_profile**(*token, u_id*)
		* assume the user is valid
		* assume the user has their full name, handle and email provided
	* **user_profile_setname**(*token, name_first, name_last*)
		* assume both their first and surname is less than 50 chars each
	* **user_profile_setemail**(*token, email*)
		* assume all emails are unique amongst users
	* **user_profile_sethandle**(*token, handle_str*)
		* assume all handles are unique
		* assume all handles are less than 20 chars
	* **user_profiles_uploadphoto**(*token, img_url, x_start, y_start, x_end, y_end*)
		* assume all images are within the dimensions given

* ## **Other**
	* **standup_start**(*token, channel_id*)
		* cannot call standup_start while standup_start is currently running (when earlier than time_finish)
	* **standup_send**(*token, channel_id, message*)
		* cannot call when standup_start is not active
	* **search**(*token, query_str*)
		* assume there is input
	* **admin_userpermission_change**(*token, u_id, permission_id*)
		* assume only the admin/owner has access to this function
