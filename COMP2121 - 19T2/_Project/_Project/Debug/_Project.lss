
AVRASM ver. 2.2.7  C:\Users\Imper\Documents\Atmel Studio\7.0\_Project\_Project\main.asm Sun Aug 18 18:57:14 2019

[builtin](2): Including file 'C:/Program Files (x86)\Atmel\Studio\7.0\Packs\atmel\ATmega_DFP\1.2.209\avrasm\inc\m2560def.inc'
C:\Users\Imper\Documents\Atmel Studio\7.0\_Project\_Project\main.asm(1): Including file 'C:/Program Files (x86)\Atmel\Studio\7.0\Packs\atmel\ATmega_DFP\1.2.209\avrasm\inc\m2560def.inc'
[builtin](2): Including file 'C:/Program Files (x86)\Atmel\Studio\7.0\Packs\atmel\ATmega_DFP\1.2.209\avrasm\inc\m2560def.inc'
C:\Users\Imper\Documents\Atmel Studio\7.0\_Project\_Project\main.asm(1): Including file 'C:/Program Files (x86)\Atmel\Studio\7.0\Packs\atmel\ATmega_DFP\1.2.209\avrasm\inc\m2560def.inc'
                                 
                                 .include "m2560def.inc"
                                 
                                 ;***** Created: 2011-02-09 12:03 ******* Source: ATmega2560.xml **********
                                 ;*************************************************************************
                                 ;* A P P L I C A T I O N   N O T E   F O R   T H E   A V R   F A M I L Y
                                 ;* 
                                 ;* Number            : AVR000
                                 ;* File Name         : "m2560def.inc"
                                 ;* Title             : Register/Bit Definitions for the ATmega2560
                                 ;* Date              : 2011-02-09
                                 ;* Version           : 2.35
                                 ;* Support E-mail    : avr@atmel.com
                                 ;* Target MCU        : ATmega2560
                                 ;* 
                                 ;* DESCRIPTION
                                 ;* When including this file in the assembly program file, all I/O register 
                                 ;* names and I/O register bit names appearing in the data book can be used.
                                 ;* In addition, the six registers forming the three data pointers X, Y and 
                                 ;* Z have been assigned names XL - ZH. Highest RAM address for Internal 
                                 ;* SRAM is also defined 
                                 ;* 
                                 ;* The Register names are represented by their hexadecimal address.
                                 ;* 
                                 ;* The Register Bit names are represented by their bit number (0-7).
                                 ;* 
                                 ;* Please observe the difference in using the bit names with instructions
                                 ;* such as "sbr"/"cbr" (set/clear bit in register) and "sbrs"/"sbrc"
                                 ;* (skip if bit in register set/cleared). The following example illustrates
                                 ;* this:
                                 ;* 
                                 ;* in    r16,PORTB             ;read PORTB latch
                                 ;* sbr   r16,(1<<PB6)+(1<<PB5) ;set PB6 and PB5 (use masks, not bit#)
                                 ;* out   PORTB,r16             ;output to PORTB
                                 ;* 
                                 ;* in    r16,TIFR              ;read the Timer Interrupt Flag Register
                                 ;* sbrc  r16,TOV0              ;test the overflow flag (use bit#)
                                 ;* rjmp  TOV0_is_set           ;jump if set
                                 ;* ...                         ;otherwise do something else
                                 ;*************************************************************************
                                 
                                 #ifndef _M2560DEF_INC_
                                 #define _M2560DEF_INC_
                                 
                                 
                                 #pragma partinc 0
                                 
                                 ; ***** SPECIFY DEVICE ***************************************************
                                 .device ATmega2560
                                 #pragma AVRPART ADMIN PART_NAME ATmega2560
                                 .equ	SIGNATURE_000	= 0x1e
                                 .equ	SIGNATURE_001	= 0x98
                                 .equ	SIGNATURE_002	= 0x01
                                 
                                 #pragma AVRPART CORE CORE_VERSION V3
                                 
                                 
                                 ; ***** I/O REGISTER DEFINITIONS *****************************************
                                 ; NOTE:
                                 ; Definitions marked "MEMORY MAPPED"are extended I/O ports
                                 ; and cannot be used with IN/OUT instructions
                                 .equ	UDR3	= 0x136	; MEMORY MAPPED
                                 .equ	UBRR3L	= 0x134	; MEMORY MAPPED
                                 .equ	UBRR3H	= 0x135	; MEMORY MAPPED
                                 .equ	UCSR3C	= 0x132	; MEMORY MAPPED
                                 .equ	UCSR3B	= 0x131	; MEMORY MAPPED
                                 .equ	UCSR3A	= 0x130	; MEMORY MAPPED
                                 .equ	OCR5CL	= 0x12c	; MEMORY MAPPED
                                 .equ	OCR5CH	= 0x12d	; MEMORY MAPPED
                                 .equ	OCR5BL	= 0x12a	; MEMORY MAPPED
                                 .equ	OCR5BH	= 0x12b	; MEMORY MAPPED
                                 .equ	OCR5AL	= 0x128	; MEMORY MAPPED
                                 .equ	OCR5AH	= 0x129	; MEMORY MAPPED
                                 .equ	ICR5H	= 0x127	; MEMORY MAPPED
                                 .equ	ICR5L	= 0x126	; MEMORY MAPPED
                                 .equ	TCNT5L	= 0x124	; MEMORY MAPPED
                                 .equ	TCNT5H	= 0x125	; MEMORY MAPPED
                                 .equ	TCCR5C	= 0x122	; MEMORY MAPPED
                                 .equ	TCCR5B	= 0x121	; MEMORY MAPPED
                                 .equ	TCCR5A	= 0x120	; MEMORY MAPPED
                                 .equ	PORTL	= 0x10b	; MEMORY MAPPED
                                 .equ	DDRL	= 0x10a	; MEMORY MAPPED
                                 .equ	PINL	= 0x109	; MEMORY MAPPED
                                 .equ	PORTK	= 0x108	; MEMORY MAPPED
                                 .equ	DDRK	= 0x107	; MEMORY MAPPED
                                 .equ	PINK	= 0x106	; MEMORY MAPPED
                                 .equ	PORTJ	= 0x105	; MEMORY MAPPED
                                 .equ	DDRJ	= 0x104	; MEMORY MAPPED
                                 .equ	PINJ	= 0x103	; MEMORY MAPPED
                                 .equ	PORTH	= 0x102	; MEMORY MAPPED
                                 .equ	DDRH	= 0x101	; MEMORY MAPPED
                                 .equ	PINH	= 0x100	; MEMORY MAPPED
                                 .equ	UDR2	= 0xd6	; MEMORY MAPPED
                                 .equ	UBRR2L	= 0xd4	; MEMORY MAPPED
                                 .equ	UBRR2H	= 0xd5	; MEMORY MAPPED
                                 .equ	UCSR2C	= 0xd2	; MEMORY MAPPED
                                 .equ	UCSR2B	= 0xd1	; MEMORY MAPPED
                                 .equ	UCSR2A	= 0xd0	; MEMORY MAPPED
                                 .equ	UDR1	= 0xce	; MEMORY MAPPED
                                 .equ	UBRR1L	= 0xcc	; MEMORY MAPPED
                                 .equ	UBRR1H	= 0xcd	; MEMORY MAPPED
                                 .equ	UCSR1C	= 0xca	; MEMORY MAPPED
                                 .equ	UCSR1B	= 0xc9	; MEMORY MAPPED
                                 .equ	UCSR1A	= 0xc8	; MEMORY MAPPED
                                 .equ	UDR0	= 0xc6	; MEMORY MAPPED
                                 .equ	UBRR0L	= 0xc4	; MEMORY MAPPED
                                 .equ	UBRR0H	= 0xc5	; MEMORY MAPPED
                                 .equ	UCSR0C	= 0xc2	; MEMORY MAPPED
                                 .equ	UCSR0B	= 0xc1	; MEMORY MAPPED
                                 .equ	UCSR0A	= 0xc0	; MEMORY MAPPED
                                 .equ	TWAMR	= 0xbd	; MEMORY MAPPED
                                 .equ	TWCR	= 0xbc	; MEMORY MAPPED
                                 .equ	TWDR	= 0xbb	; MEMORY MAPPED
                                 .equ	TWAR	= 0xba	; MEMORY MAPPED
                                 .equ	TWSR	= 0xb9	; MEMORY MAPPED
                                 .equ	TWBR	= 0xb8	; MEMORY MAPPED
                                 .equ	ASSR	= 0xb6	; MEMORY MAPPED
                                 .equ	OCR2B	= 0xb4	; MEMORY MAPPED
                                 .equ	OCR2A	= 0xb3	; MEMORY MAPPED
                                 .equ	TCNT2	= 0xb2	; MEMORY MAPPED
                                 .equ	TCCR2B	= 0xb1	; MEMORY MAPPED
                                 .equ	TCCR2A	= 0xb0	; MEMORY MAPPED
                                 .equ	OCR4CL	= 0xac	; MEMORY MAPPED
                                 .equ	OCR4CH	= 0xad	; MEMORY MAPPED
                                 .equ	OCR4BL	= 0xaa	; MEMORY MAPPED
                                 .equ	OCR4BH	= 0xab	; MEMORY MAPPED
                                 .equ	OCR4AL	= 0xa8	; MEMORY MAPPED
                                 .equ	OCR4AH	= 0xa9	; MEMORY MAPPED
                                 .equ	ICR4L	= 0xa6	; MEMORY MAPPED
                                 .equ	ICR4H	= 0xa7	; MEMORY MAPPED
                                 .equ	TCNT4L	= 0xa4	; MEMORY MAPPED
                                 .equ	TCNT4H	= 0xa5	; MEMORY MAPPED
                                 .equ	TCCR4C	= 0xa2	; MEMORY MAPPED
                                 .equ	TCCR4B	= 0xa1	; MEMORY MAPPED
                                 .equ	TCCR4A	= 0xa0	; MEMORY MAPPED
                                 .equ	OCR3CL	= 0x9c	; MEMORY MAPPED
                                 .equ	OCR3CH	= 0x9d	; MEMORY MAPPED
                                 .equ	OCR3BL	= 0x9a	; MEMORY MAPPED
                                 .equ	OCR3BH	= 0x9b	; MEMORY MAPPED
                                 .equ	OCR3AL	= 0x98	; MEMORY MAPPED
                                 .equ	OCR3AH	= 0x99	; MEMORY MAPPED
                                 .equ	ICR3L	= 0x96	; MEMORY MAPPED
                                 .equ	ICR3H	= 0x97	; MEMORY MAPPED
                                 .equ	TCNT3L	= 0x94	; MEMORY MAPPED
                                 .equ	TCNT3H	= 0x95	; MEMORY MAPPED
                                 .equ	TCCR3C	= 0x92	; MEMORY MAPPED
                                 .equ	TCCR3B	= 0x91	; MEMORY MAPPED
                                 .equ	TCCR3A	= 0x90	; MEMORY MAPPED
                                 .equ	OCR1CL	= 0x8c	; MEMORY MAPPED
                                 .equ	OCR1CH	= 0x8d	; MEMORY MAPPED
                                 .equ	OCR1BL	= 0x8a	; MEMORY MAPPED
                                 .equ	OCR1BH	= 0x8b	; MEMORY MAPPED
                                 .equ	OCR1AL	= 0x88	; MEMORY MAPPED
                                 .equ	OCR1AH	= 0x89	; MEMORY MAPPED
                                 .equ	ICR1L	= 0x86	; MEMORY MAPPED
                                 .equ	ICR1H	= 0x87	; MEMORY MAPPED
                                 .equ	TCNT1L	= 0x84	; MEMORY MAPPED
                                 .equ	TCNT1H	= 0x85	; MEMORY MAPPED
                                 .equ	TCCR1C	= 0x82	; MEMORY MAPPED
                                 .equ	TCCR1B	= 0x81	; MEMORY MAPPED
                                 .equ	TCCR1A	= 0x80	; MEMORY MAPPED
                                 .equ	DIDR1	= 0x7f	; MEMORY MAPPED
                                 .equ	DIDR0	= 0x7e	; MEMORY MAPPED
                                 .equ	DIDR2	= 0x7d	; MEMORY MAPPED
                                 .equ	ADMUX	= 0x7c	; MEMORY MAPPED
                                 .equ	ADCSRB	= 0x7b	; MEMORY MAPPED
                                 .equ	ADCSRA	= 0x7a	; MEMORY MAPPED
                                 .equ	ADCH	= 0x79	; MEMORY MAPPED
                                 .equ	ADCL	= 0x78	; MEMORY MAPPED
                                 .equ	XMCRB	= 0x75	; MEMORY MAPPED
                                 .equ	XMCRA	= 0x74	; MEMORY MAPPED
                                 .equ	TIMSK5	= 0x73	; MEMORY MAPPED
                                 .equ	TIMSK4	= 0x72	; MEMORY MAPPED
                                 .equ	TIMSK3	= 0x71	; MEMORY MAPPED
                                 .equ	TIMSK2	= 0x70	; MEMORY MAPPED
                                 .equ	TIMSK1	= 0x6f	; MEMORY MAPPED
                                 .equ	TIMSK0	= 0x6e	; MEMORY MAPPED
                                 .equ	PCMSK2	= 0x6d	; MEMORY MAPPED
                                 .equ	PCMSK1	= 0x6c	; MEMORY MAPPED
                                 .equ	PCMSK0	= 0x6b	; MEMORY MAPPED
                                 .equ	EICRB	= 0x6a	; MEMORY MAPPED
                                 .equ	EICRA	= 0x69	; MEMORY MAPPED
                                 .equ	PCICR	= 0x68	; MEMORY MAPPED
                                 .equ	OSCCAL	= 0x66	; MEMORY MAPPED
                                 .equ	PRR1	= 0x65	; MEMORY MAPPED
                                 .equ	PRR0	= 0x64	; MEMORY MAPPED
                                 .equ	CLKPR	= 0x61	; MEMORY MAPPED
                                 .equ	WDTCSR	= 0x60	; MEMORY MAPPED
                                 .equ	SREG	= 0x3f
                                 .equ	SPL	= 0x3d
                                 .equ	SPH	= 0x3e
                                 .equ	EIND	= 0x3c
                                 .equ	RAMPZ	= 0x3b
                                 .equ	SPMCSR	= 0x37
                                 .equ	MCUCR	= 0x35
                                 .equ	MCUSR	= 0x34
                                 .equ	SMCR	= 0x33
                                 .equ	OCDR	= 0x31
                                 .equ	ACSR	= 0x30
                                 .equ	SPDR	= 0x2e
                                 .equ	SPSR	= 0x2d
                                 .equ	SPCR	= 0x2c
                                 .equ	GPIOR2	= 0x2b
                                 .equ	GPIOR1	= 0x2a
                                 .equ	OCR0B	= 0x28
                                 .equ	OCR0A	= 0x27
                                 .equ	TCNT0	= 0x26
                                 .equ	TCCR0B	= 0x25
                                 .equ	TCCR0A	= 0x24
                                 .equ	GTCCR	= 0x23
                                 .equ	EEARH	= 0x22
                                 .equ	EEARL	= 0x21
                                 .equ	EEDR	= 0x20
                                 .equ	EECR	= 0x1f
                                 .equ	GPIOR0	= 0x1e
                                 .equ	EIMSK	= 0x1d
                                 .equ	EIFR	= 0x1c
                                 .equ	PCIFR	= 0x1b
                                 .equ	TIFR5	= 0x1a
                                 .equ	TIFR4	= 0x19
                                 .equ	TIFR3	= 0x18
                                 .equ	TIFR2	= 0x17
                                 .equ	TIFR1	= 0x16
                                 .equ	TIFR0	= 0x15
                                 .equ	PORTG	= 0x14
                                 .equ	DDRG	= 0x13
                                 .equ	PING	= 0x12
                                 .equ	PORTF	= 0x11
                                 .equ	DDRF	= 0x10
                                 .equ	PINF	= 0x0f
                                 .equ	PORTE	= 0x0e
                                 .equ	DDRE	= 0x0d
                                 .equ	PINE	= 0x0c
                                 .equ	PORTD	= 0x0b
                                 .equ	DDRD	= 0x0a
                                 .equ	PIND	= 0x09
                                 .equ	PORTC	= 0x08
                                 .equ	DDRC	= 0x07
                                 .equ	PINC	= 0x06
                                 .equ	PORTB	= 0x05
                                 .equ	DDRB	= 0x04
                                 .equ	PINB	= 0x03
                                 .equ	PORTA	= 0x02
                                 .equ	DDRA	= 0x01
                                 .equ	PINA	= 0x00
                                 
                                 
                                 ; ***** BIT DEFINITIONS **************************************************
                                 
                                 ; ***** ANALOG_COMPARATOR ************
                                 ; ADCSRB - ADC Control and Status Register B
                                 .equ	ACME	= 6	; Analog Comparator Multiplexer Enable
                                 
                                 ; ACSR - Analog Comparator Control And Status Register
                                 .equ	ACIS0	= 0	; Analog Comparator Interrupt Mode Select bit 0
                                 .equ	ACIS1	= 1	; Analog Comparator Interrupt Mode Select bit 1
                                 .equ	ACIC	= 2	; Analog Comparator Input Capture Enable
                                 .equ	ACIE	= 3	; Analog Comparator Interrupt Enable
                                 .equ	ACI	= 4	; Analog Comparator Interrupt Flag
                                 .equ	ACO	= 5	; Analog Compare Output
                                 .equ	ACBG	= 6	; Analog Comparator Bandgap Select
                                 .equ	ACD	= 7	; Analog Comparator Disable
                                 
                                 ; DIDR1 - Digital Input Disable Register 1
                                 .equ	AIN0D	= 0	; AIN0 Digital Input Disable
                                 .equ	AIN1D	= 1	; AIN1 Digital Input Disable
                                 
                                 
                                 ; ***** USART0 ***********************
                                 ; UDR0 - USART I/O Data Register
                                 .equ	UDR0_0	= 0	; USART I/O Data Register bit 0
                                 .equ	UDR0_1	= 1	; USART I/O Data Register bit 1
                                 .equ	UDR0_2	= 2	; USART I/O Data Register bit 2
                                 .equ	UDR0_3	= 3	; USART I/O Data Register bit 3
                                 .equ	UDR0_4	= 4	; USART I/O Data Register bit 4
                                 .equ	UDR0_5	= 5	; USART I/O Data Register bit 5
                                 .equ	UDR0_6	= 6	; USART I/O Data Register bit 6
                                 .equ	UDR0_7	= 7	; USART I/O Data Register bit 7
                                 
                                 ; UCSR0A - USART Control and Status Register A
                                 .equ	MPCM0	= 0	; Multi-processor Communication Mode
                                 .equ	U2X0	= 1	; Double the USART transmission speed
                                 .equ	UPE0	= 2	; Parity Error
                                 .equ	DOR0	= 3	; Data overRun
                                 .equ	FE0	= 4	; Framing Error
                                 .equ	UDRE0	= 5	; USART Data Register Empty
                                 .equ	TXC0	= 6	; USART Transmitt Complete
                                 .equ	RXC0	= 7	; USART Receive Complete
                                 
                                 ; UCSR0B - USART Control and Status Register B
                                 .equ	TXB80	= 0	; Transmit Data Bit 8
                                 .equ	RXB80	= 1	; Receive Data Bit 8
                                 .equ	UCSZ02	= 2	; Character Size
                                 .equ	TXEN0	= 3	; Transmitter Enable
                                 .equ	RXEN0	= 4	; Receiver Enable
                                 .equ	UDRIE0	= 5	; USART Data register Empty Interrupt Enable
                                 .equ	TXCIE0	= 6	; TX Complete Interrupt Enable
                                 .equ	RXCIE0	= 7	; RX Complete Interrupt Enable
                                 
                                 ; UCSR0C - USART Control and Status Register C
                                 .equ	UCPOL0	= 0	; Clock Polarity
                                 .equ	UCSZ00	= 1	; Character Size
                                 .equ	UCPHA0	= UCSZ00	; For compatibility
                                 .equ	UCSZ01	= 2	; Character Size
                                 .equ	UDORD0	= UCSZ01	; For compatibility
                                 .equ	USBS0	= 3	; Stop Bit Select
                                 .equ	UPM00	= 4	; Parity Mode Bit 0
                                 .equ	UPM01	= 5	; Parity Mode Bit 1
                                 .equ	UMSEL00	= 6	; USART Mode Select
                                 .equ	UMSEL0	= UMSEL00	; For compatibility
                                 .equ	UMSEL01	= 7	; USART Mode Select
                                 .equ	UMSEL1	= UMSEL01	; For compatibility
                                 
                                 ; UBRR0H - USART Baud Rate Register High Byte
                                 .equ	UBRR8	= 0	; USART Baud Rate Register bit 8
                                 .equ	UBRR9	= 1	; USART Baud Rate Register bit 9
                                 .equ	UBRR10	= 2	; USART Baud Rate Register bit 10
                                 .equ	UBRR11	= 3	; USART Baud Rate Register bit 11
                                 
                                 ; UBRR0L - USART Baud Rate Register Low Byte
                                 .equ	_UBRR0	= 0	; USART Baud Rate Register bit 0
                                 .equ	_UBRR1	= 1	; USART Baud Rate Register bit 1
                                 .equ	UBRR2	= 2	; USART Baud Rate Register bit 2
                                 .equ	UBRR3	= 3	; USART Baud Rate Register bit 3
                                 .equ	UBRR4	= 4	; USART Baud Rate Register bit 4
                                 .equ	UBRR5	= 5	; USART Baud Rate Register bit 5
                                 .equ	UBRR6	= 6	; USART Baud Rate Register bit 6
                                 .equ	UBRR7	= 7	; USART Baud Rate Register bit 7
                                 
                                 
                                 ; ***** TWI **************************
                                 ; TWAMR - TWI (Slave) Address Mask Register
                                 .equ	TWAM0	= 1	; 
                                 .equ	TWAMR0	= TWAM0	; For compatibility
                                 .equ	TWAM1	= 2	; 
                                 .equ	TWAMR1	= TWAM1	; For compatibility
                                 .equ	TWAM2	= 3	; 
                                 .equ	TWAMR2	= TWAM2	; For compatibility
                                 .equ	TWAM3	= 4	; 
                                 .equ	TWAMR3	= TWAM3	; For compatibility
                                 .equ	TWAM4	= 5	; 
                                 .equ	TWAMR4	= TWAM4	; For compatibility
                                 .equ	TWAM5	= 6	; 
                                 .equ	TWAMR5	= TWAM5	; For compatibility
                                 .equ	TWAM6	= 7	; 
                                 .equ	TWAMR6	= TWAM6	; For compatibility
                                 
                                 ; TWBR - TWI Bit Rate register
                                 .equ	TWBR0	= 0	; 
                                 .equ	TWBR1	= 1	; 
                                 .equ	TWBR2	= 2	; 
                                 .equ	TWBR3	= 3	; 
                                 .equ	TWBR4	= 4	; 
                                 .equ	TWBR5	= 5	; 
                                 .equ	TWBR6	= 6	; 
                                 .equ	TWBR7	= 7	; 
                                 
                                 ; TWCR - TWI Control Register
                                 .equ	TWIE	= 0	; TWI Interrupt Enable
                                 .equ	TWEN	= 2	; TWI Enable Bit
                                 .equ	TWWC	= 3	; TWI Write Collition Flag
                                 .equ	TWSTO	= 4	; TWI Stop Condition Bit
                                 .equ	TWSTA	= 5	; TWI Start Condition Bit
                                 .equ	TWEA	= 6	; TWI Enable Acknowledge Bit
                                 .equ	TWINT	= 7	; TWI Interrupt Flag
                                 
                                 ; TWSR - TWI Status Register
                                 .equ	TWPS0	= 0	; TWI Prescaler
                                 .equ	TWPS1	= 1	; TWI Prescaler
                                 .equ	TWS3	= 3	; TWI Status
                                 .equ	TWS4	= 4	; TWI Status
                                 .equ	TWS5	= 5	; TWI Status
                                 .equ	TWS6	= 6	; TWI Status
                                 .equ	TWS7	= 7	; TWI Status
                                 
                                 ; TWDR - TWI Data register
                                 .equ	TWD0	= 0	; TWI Data Register Bit 0
                                 .equ	TWD1	= 1	; TWI Data Register Bit 1
                                 .equ	TWD2	= 2	; TWI Data Register Bit 2
                                 .equ	TWD3	= 3	; TWI Data Register Bit 3
                                 .equ	TWD4	= 4	; TWI Data Register Bit 4
                                 .equ	TWD5	= 5	; TWI Data Register Bit 5
                                 .equ	TWD6	= 6	; TWI Data Register Bit 6
                                 .equ	TWD7	= 7	; TWI Data Register Bit 7
                                 
                                 ; TWAR - TWI (Slave) Address register
                                 .equ	TWGCE	= 0	; TWI General Call Recognition Enable Bit
                                 .equ	TWA0	= 1	; TWI (Slave) Address register Bit 0
                                 .equ	TWA1	= 2	; TWI (Slave) Address register Bit 1
                                 .equ	TWA2	= 3	; TWI (Slave) Address register Bit 2
                                 .equ	TWA3	= 4	; TWI (Slave) Address register Bit 3
                                 .equ	TWA4	= 5	; TWI (Slave) Address register Bit 4
                                 .equ	TWA5	= 6	; TWI (Slave) Address register Bit 5
                                 .equ	TWA6	= 7	; TWI (Slave) Address register Bit 6
                                 
                                 
                                 ; ***** SPI **************************
                                 ; SPDR - SPI Data Register
                                 .equ	SPDR0	= 0	; SPI Data Register bit 0
                                 .equ	SPDR1	= 1	; SPI Data Register bit 1
                                 .equ	SPDR2	= 2	; SPI Data Register bit 2
                                 .equ	SPDR3	= 3	; SPI Data Register bit 3
                                 .equ	SPDR4	= 4	; SPI Data Register bit 4
                                 .equ	SPDR5	= 5	; SPI Data Register bit 5
                                 .equ	SPDR6	= 6	; SPI Data Register bit 6
                                 .equ	SPDR7	= 7	; SPI Data Register bit 7
                                 
                                 ; SPSR - SPI Status Register
                                 .equ	SPI2X	= 0	; Double SPI Speed Bit
                                 .equ	WCOL	= 6	; Write Collision Flag
                                 .equ	SPIF	= 7	; SPI Interrupt Flag
                                 
                                 ; SPCR - SPI Control Register
                                 .equ	SPR0	= 0	; SPI Clock Rate Select 0
                                 .equ	SPR1	= 1	; SPI Clock Rate Select 1
                                 .equ	CPHA	= 2	; Clock Phase
                                 .equ	CPOL	= 3	; Clock polarity
                                 .equ	MSTR	= 4	; Master/Slave Select
                                 .equ	DORD	= 5	; Data Order
                                 .equ	SPE	= 6	; SPI Enable
                                 .equ	SPIE	= 7	; SPI Interrupt Enable
                                 
                                 
                                 ; ***** PORTA ************************
                                 ; PORTA - Port A Data Register
                                 .equ	PORTA0	= 0	; Port A Data Register bit 0
                                 .equ	PA0	= 0	; For compatibility
                                 .equ	PORTA1	= 1	; Port A Data Register bit 1
                                 .equ	PA1	= 1	; For compatibility
                                 .equ	PORTA2	= 2	; Port A Data Register bit 2
                                 .equ	PA2	= 2	; For compatibility
                                 .equ	PORTA3	= 3	; Port A Data Register bit 3
                                 .equ	PA3	= 3	; For compatibility
                                 .equ	PORTA4	= 4	; Port A Data Register bit 4
                                 .equ	PA4	= 4	; For compatibility
                                 .equ	PORTA5	= 5	; Port A Data Register bit 5
                                 .equ	PA5	= 5	; For compatibility
                                 .equ	PORTA6	= 6	; Port A Data Register bit 6
                                 .equ	PA6	= 6	; For compatibility
                                 .equ	PORTA7	= 7	; Port A Data Register bit 7
                                 .equ	PA7	= 7	; For compatibility
                                 
                                 ; DDRA - Port A Data Direction Register
                                 .equ	DDA0	= 0	; Data Direction Register, Port A, bit 0
                                 .equ	DDA1	= 1	; Data Direction Register, Port A, bit 1
                                 .equ	DDA2	= 2	; Data Direction Register, Port A, bit 2
                                 .equ	DDA3	= 3	; Data Direction Register, Port A, bit 3
                                 .equ	DDA4	= 4	; Data Direction Register, Port A, bit 4
                                 .equ	DDA5	= 5	; Data Direction Register, Port A, bit 5
                                 .equ	DDA6	= 6	; Data Direction Register, Port A, bit 6
                                 .equ	DDA7	= 7	; Data Direction Register, Port A, bit 7
                                 
                                 ; PINA - Port A Input Pins
                                 .equ	PINA0	= 0	; Input Pins, Port A bit 0
                                 .equ	PINA1	= 1	; Input Pins, Port A bit 1
                                 .equ	PINA2	= 2	; Input Pins, Port A bit 2
                                 .equ	PINA3	= 3	; Input Pins, Port A bit 3
                                 .equ	PINA4	= 4	; Input Pins, Port A bit 4
                                 .equ	PINA5	= 5	; Input Pins, Port A bit 5
                                 .equ	PINA6	= 6	; Input Pins, Port A bit 6
                                 .equ	PINA7	= 7	; Input Pins, Port A bit 7
                                 
                                 
                                 ; ***** PORTB ************************
                                 ; PORTB - Port B Data Register
                                 .equ	PORTB0	= 0	; Port B Data Register bit 0
                                 .equ	PB0	= 0	; For compatibility
                                 .equ	PORTB1	= 1	; Port B Data Register bit 1
                                 .equ	PB1	= 1	; For compatibility
                                 .equ	PORTB2	= 2	; Port B Data Register bit 2
                                 .equ	PB2	= 2	; For compatibility
                                 .equ	PORTB3	= 3	; Port B Data Register bit 3
                                 .equ	PB3	= 3	; For compatibility
                                 .equ	PORTB4	= 4	; Port B Data Register bit 4
                                 .equ	PB4	= 4	; For compatibility
                                 .equ	PORTB5	= 5	; Port B Data Register bit 5
                                 .equ	PB5	= 5	; For compatibility
                                 .equ	PORTB6	= 6	; Port B Data Register bit 6
                                 .equ	PB6	= 6	; For compatibility
                                 .equ	PORTB7	= 7	; Port B Data Register bit 7
                                 .equ	PB7	= 7	; For compatibility
                                 
                                 ; DDRB - Port B Data Direction Register
                                 .equ	DDB0	= 0	; Port B Data Direction Register bit 0
                                 .equ	DDB1	= 1	; Port B Data Direction Register bit 1
                                 .equ	DDB2	= 2	; Port B Data Direction Register bit 2
                                 .equ	DDB3	= 3	; Port B Data Direction Register bit 3
                                 .equ	DDB4	= 4	; Port B Data Direction Register bit 4
                                 .equ	DDB5	= 5	; Port B Data Direction Register bit 5
                                 .equ	DDB6	= 6	; Port B Data Direction Register bit 6
                                 .equ	DDB7	= 7	; Port B Data Direction Register bit 7
                                 
                                 ; PINB - Port B Input Pins
                                 .equ	PINB0	= 0	; Port B Input Pins bit 0
                                 .equ	PINB1	= 1	; Port B Input Pins bit 1
                                 .equ	PINB2	= 2	; Port B Input Pins bit 2
                                 .equ	PINB3	= 3	; Port B Input Pins bit 3
                                 .equ	PINB4	= 4	; Port B Input Pins bit 4
                                 .equ	PINB5	= 5	; Port B Input Pins bit 5
                                 .equ	PINB6	= 6	; Port B Input Pins bit 6
                                 .equ	PINB7	= 7	; Port B Input Pins bit 7
                                 
                                 
                                 ; ***** PORTC ************************
                                 ; PORTC - Port C Data Register
                                 .equ	PORTC0	= 0	; Port C Data Register bit 0
                                 .equ	PC0	= 0	; For compatibility
                                 .equ	PORTC1	= 1	; Port C Data Register bit 1
                                 .equ	PC1	= 1	; For compatibility
                                 .equ	PORTC2	= 2	; Port C Data Register bit 2
                                 .equ	PC2	= 2	; For compatibility
                                 .equ	PORTC3	= 3	; Port C Data Register bit 3
                                 .equ	PC3	= 3	; For compatibility
                                 .equ	PORTC4	= 4	; Port C Data Register bit 4
                                 .equ	PC4	= 4	; For compatibility
                                 .equ	PORTC5	= 5	; Port C Data Register bit 5
                                 .equ	PC5	= 5	; For compatibility
                                 .equ	PORTC6	= 6	; Port C Data Register bit 6
                                 .equ	PC6	= 6	; For compatibility
                                 .equ	PORTC7	= 7	; Port C Data Register bit 7
                                 .equ	PC7	= 7	; For compatibility
                                 
                                 ; DDRC - Port C Data Direction Register
                                 .equ	DDC0	= 0	; Port C Data Direction Register bit 0
                                 .equ	DDC1	= 1	; Port C Data Direction Register bit 1
                                 .equ	DDC2	= 2	; Port C Data Direction Register bit 2
                                 .equ	DDC3	= 3	; Port C Data Direction Register bit 3
                                 .equ	DDC4	= 4	; Port C Data Direction Register bit 4
                                 .equ	DDC5	= 5	; Port C Data Direction Register bit 5
                                 .equ	DDC6	= 6	; Port C Data Direction Register bit 6
                                 .equ	DDC7	= 7	; Port C Data Direction Register bit 7
                                 
                                 ; PINC - Port C Input Pins
                                 .equ	PINC0	= 0	; Port C Input Pins bit 0
                                 .equ	PINC1	= 1	; Port C Input Pins bit 1
                                 .equ	PINC2	= 2	; Port C Input Pins bit 2
                                 .equ	PINC3	= 3	; Port C Input Pins bit 3
                                 .equ	PINC4	= 4	; Port C Input Pins bit 4
                                 .equ	PINC5	= 5	; Port C Input Pins bit 5
                                 .equ	PINC6	= 6	; Port C Input Pins bit 6
                                 .equ	PINC7	= 7	; Port C Input Pins bit 7
                                 
                                 
                                 ; ***** PORTD ************************
                                 ; PORTD - Port D Data Register
                                 .equ	PORTD0	= 0	; Port D Data Register bit 0
                                 .equ	PD0	= 0	; For compatibility
                                 .equ	PORTD1	= 1	; Port D Data Register bit 1
                                 .equ	PD1	= 1	; For compatibility
                                 .equ	PORTD2	= 2	; Port D Data Register bit 2
                                 .equ	PD2	= 2	; For compatibility
                                 .equ	PORTD3	= 3	; Port D Data Register bit 3
                                 .equ	PD3	= 3	; For compatibility
                                 .equ	PORTD4	= 4	; Port D Data Register bit 4
                                 .equ	PD4	= 4	; For compatibility
                                 .equ	PORTD5	= 5	; Port D Data Register bit 5
                                 .equ	PD5	= 5	; For compatibility
                                 .equ	PORTD6	= 6	; Port D Data Register bit 6
                                 .equ	PD6	= 6	; For compatibility
                                 .equ	PORTD7	= 7	; Port D Data Register bit 7
                                 .equ	PD7	= 7	; For compatibility
                                 
                                 ; DDRD - Port D Data Direction Register
                                 .equ	DDD0	= 0	; Port D Data Direction Register bit 0
                                 .equ	DDD1	= 1	; Port D Data Direction Register bit 1
                                 .equ	DDD2	= 2	; Port D Data Direction Register bit 2
                                 .equ	DDD3	= 3	; Port D Data Direction Register bit 3
                                 .equ	DDD4	= 4	; Port D Data Direction Register bit 4
                                 .equ	DDD5	= 5	; Port D Data Direction Register bit 5
                                 .equ	DDD6	= 6	; Port D Data Direction Register bit 6
                                 .equ	DDD7	= 7	; Port D Data Direction Register bit 7
                                 
                                 ; PIND - Port D Input Pins
                                 .equ	PIND0	= 0	; Port D Input Pins bit 0
                                 .equ	PIND1	= 1	; Port D Input Pins bit 1
                                 .equ	PIND2	= 2	; Port D Input Pins bit 2
                                 .equ	PIND3	= 3	; Port D Input Pins bit 3
                                 .equ	PIND4	= 4	; Port D Input Pins bit 4
                                 .equ	PIND5	= 5	; Port D Input Pins bit 5
                                 .equ	PIND6	= 6	; Port D Input Pins bit 6
                                 .equ	PIND7	= 7	; Port D Input Pins bit 7
                                 
                                 
                                 ; ***** PORTE ************************
                                 ; PORTE - Data Register, Port E
                                 .equ	PORTE0	= 0	; 
                                 .equ	PE0	= 0	; For compatibility
                                 .equ	PORTE1	= 1	; 
                                 .equ	PE1	= 1	; For compatibility
                                 .equ	PORTE2	= 2	; 
                                 .equ	PE2	= 2	; For compatibility
                                 .equ	PORTE3	= 3	; 
                                 .equ	PE3	= 3	; For compatibility
                                 .equ	PORTE4	= 4	; 
                                 .equ	PE4	= 4	; For compatibility
                                 .equ	PORTE5	= 5	; 
                                 .equ	PE5	= 5	; For compatibility
                                 .equ	PORTE6	= 6	; 
                                 .equ	PE6	= 6	; For compatibility
                                 .equ	PORTE7	= 7	; 
                                 .equ	PE7	= 7	; For compatibility
                                 
                                 ; DDRE - Data Direction Register, Port E
                                 .equ	DDE0	= 0	; 
                                 .equ	DDE1	= 1	; 
                                 .equ	DDE2	= 2	; 
                                 .equ	DDE3	= 3	; 
                                 .equ	DDE4	= 4	; 
                                 .equ	DDE5	= 5	; 
                                 .equ	DDE6	= 6	; 
                                 .equ	DDE7	= 7	; 
                                 
                                 ; PINE - Input Pins, Port E
                                 .equ	PINE0	= 0	; 
                                 .equ	PINE1	= 1	; 
                                 .equ	PINE2	= 2	; 
                                 .equ	PINE3	= 3	; 
                                 .equ	PINE4	= 4	; 
                                 .equ	PINE5	= 5	; 
                                 .equ	PINE6	= 6	; 
                                 .equ	PINE7	= 7	; 
                                 
                                 
                                 ; ***** PORTF ************************
                                 ; PORTF - Data Register, Port F
                                 .equ	PORTF0	= 0	; 
                                 .equ	PF0	= 0	; For compatibility
                                 .equ	PORTF1	= 1	; 
                                 .equ	PF1	= 1	; For compatibility
                                 .equ	PORTF2	= 2	; 
                                 .equ	PF2	= 2	; For compatibility
                                 .equ	PORTF3	= 3	; 
                                 .equ	PF3	= 3	; For compatibility
                                 .equ	PORTF4	= 4	; 
                                 .equ	PF4	= 4	; For compatibility
                                 .equ	PORTF5	= 5	; 
                                 .equ	PF5	= 5	; For compatibility
                                 .equ	PORTF6	= 6	; 
                                 .equ	PF6	= 6	; For compatibility
                                 .equ	PORTF7	= 7	; 
                                 .equ	PF7	= 7	; For compatibility
                                 
                                 ; DDRF - Data Direction Register, Port F
                                 .equ	DDF0	= 0	; 
                                 .equ	DDF1	= 1	; 
                                 .equ	DDF2	= 2	; 
                                 .equ	DDF3	= 3	; 
                                 .equ	DDF4	= 4	; 
                                 .equ	DDF5	= 5	; 
                                 .equ	DDF6	= 6	; 
                                 .equ	DDF7	= 7	; 
                                 
                                 ; PINF - Input Pins, Port F
                                 .equ	PINF0	= 0	; 
                                 .equ	PINF1	= 1	; 
                                 .equ	PINF2	= 2	; 
                                 .equ	PINF3	= 3	; 
                                 .equ	PINF4	= 4	; 
                                 .equ	PINF5	= 5	; 
                                 .equ	PINF6	= 6	; 
                                 .equ	PINF7	= 7	; 
                                 
                                 
                                 ; ***** PORTG ************************
                                 ; PORTG - Data Register, Port G
                                 .equ	PORTG0	= 0	; 
                                 .equ	PG0	= 0	; For compatibility
                                 .equ	PORTG1	= 1	; 
                                 .equ	PG1	= 1	; For compatibility
                                 .equ	PORTG2	= 2	; 
                                 .equ	PG2	= 2	; For compatibility
                                 .equ	PORTG3	= 3	; 
                                 .equ	PG3	= 3	; For compatibility
                                 .equ	PORTG4	= 4	; 
                                 .equ	PG4	= 4	; For compatibility
                                 .equ	PORTG5	= 5	; 
                                 .equ	PG5	= 5	; For compatibility
                                 
                                 ; DDRG - Data Direction Register, Port G
                                 .equ	DDG0	= 0	; 
                                 .equ	DDG1	= 1	; 
                                 .equ	DDG2	= 2	; 
                                 .equ	DDG3	= 3	; 
                                 .equ	DDG4	= 4	; 
                                 .equ	DDG5	= 5	; 
                                 
                                 ; PING - Input Pins, Port G
                                 .equ	PING0	= 0	; 
                                 .equ	PING1	= 1	; 
                                 .equ	PING2	= 2	; 
                                 .equ	PING3	= 3	; 
                                 .equ	PING4	= 4	; 
                                 .equ	PING5	= 5	; 
                                 
                                 
                                 ; ***** PORTH ************************
                                 ; PORTH - PORT H Data Register
                                 .equ	PORTH0	= 0	; PORT H Data Register bit 0
                                 .equ	PH0	= 0	; For compatibility
                                 .equ	PORTH1	= 1	; PORT H Data Register bit 1
                                 .equ	PH1	= 1	; For compatibility
                                 .equ	PORTH2	= 2	; PORT H Data Register bit 2
                                 .equ	PH2	= 2	; For compatibility
                                 .equ	PORTH3	= 3	; PORT H Data Register bit 3
                                 .equ	PH3	= 3	; For compatibility
                                 .equ	PORTH4	= 4	; PORT H Data Register bit 4
                                 .equ	PH4	= 4	; For compatibility
                                 .equ	PORTH5	= 5	; PORT H Data Register bit 5
                                 .equ	PH5	= 5	; For compatibility
                                 .equ	PORTH6	= 6	; PORT H Data Register bit 6
                                 .equ	PH6	= 6	; For compatibility
                                 .equ	PORTH7	= 7	; PORT H Data Register bit 7
                                 .equ	PH7	= 7	; For compatibility
                                 
                                 ; DDRH - PORT H Data Direction Register
                                 .equ	DDH0	= 0	; PORT H Data Direction Register bit 0
                                 .equ	DDH1	= 1	; PORT H Data Direction Register bit 1
                                 .equ	DDH2	= 2	; PORT H Data Direction Register bit 2
                                 .equ	DDH3	= 3	; PORT H Data Direction Register bit 3
                                 .equ	DDH4	= 4	; PORT H Data Direction Register bit 4
                                 .equ	DDH5	= 5	; PORT H Data Direction Register bit 5
                                 .equ	DDH6	= 6	; PORT H Data Direction Register bit 6
                                 .equ	DDH7	= 7	; PORT H Data Direction Register bit 7
                                 
                                 ; PINH - PORT H Input Pins
                                 .equ	PINH0	= 0	; PORT H Input Pins bit 0
                                 .equ	PINH1	= 1	; PORT H Input Pins bit 1
                                 .equ	PINH2	= 2	; PORT H Input Pins bit 2
                                 .equ	PINH3	= 3	; PORT H Input Pins bit 3
                                 .equ	PINH4	= 4	; PORT H Input Pins bit 4
                                 .equ	PINH5	= 5	; PORT H Input Pins bit 5
                                 .equ	PINH6	= 6	; PORT H Input Pins bit 6
                                 .equ	PINH7	= 7	; PORT H Input Pins bit 7
                                 
                                 
                                 ; ***** PORTJ ************************
                                 ; PORTJ - PORT J Data Register
                                 .equ	PORTJ0	= 0	; PORT J Data Register bit 0
                                 .equ	PJ0	= 0	; For compatibility
                                 .equ	PORTJ1	= 1	; PORT J Data Register bit 1
                                 .equ	PJ1	= 1	; For compatibility
                                 .equ	PORTJ2	= 2	; PORT J Data Register bit 2
                                 .equ	PJ2	= 2	; For compatibility
                                 .equ	PORTJ3	= 3	; PORT J Data Register bit 3
                                 .equ	PJ3	= 3	; For compatibility
                                 .equ	PORTJ4	= 4	; PORT J Data Register bit 4
                                 .equ	PJ4	= 4	; For compatibility
                                 .equ	PORTJ5	= 5	; PORT J Data Register bit 5
                                 .equ	PJ5	= 5	; For compatibility
                                 .equ	PORTJ6	= 6	; PORT J Data Register bit 6
                                 .equ	PJ6	= 6	; For compatibility
                                 .equ	PORTJ7	= 7	; PORT J Data Register bit 7
                                 .equ	PJ7	= 7	; For compatibility
                                 
                                 ; DDRJ - PORT J Data Direction Register
                                 .equ	DDJ0	= 0	; PORT J Data Direction Register bit 0
                                 .equ	DDJ1	= 1	; PORT J Data Direction Register bit 1
                                 .equ	DDJ2	= 2	; PORT J Data Direction Register bit 2
                                 .equ	DDJ3	= 3	; PORT J Data Direction Register bit 3
                                 .equ	DDJ4	= 4	; PORT J Data Direction Register bit 4
                                 .equ	DDJ5	= 5	; PORT J Data Direction Register bit 5
                                 .equ	DDJ6	= 6	; PORT J Data Direction Register bit 6
                                 .equ	DDJ7	= 7	; PORT J Data Direction Register bit 7
                                 
                                 ; PINJ - PORT J Input Pins
                                 .equ	PINJ0	= 0	; PORT J Input Pins bit 0
                                 .equ	PINJ1	= 1	; PORT J Input Pins bit 1
                                 .equ	PINJ2	= 2	; PORT J Input Pins bit 2
                                 .equ	PINJ3	= 3	; PORT J Input Pins bit 3
                                 .equ	PINJ4	= 4	; PORT J Input Pins bit 4
                                 .equ	PINJ5	= 5	; PORT J Input Pins bit 5
                                 .equ	PINJ6	= 6	; PORT J Input Pins bit 6
                                 .equ	PINJ7	= 7	; PORT J Input Pins bit 7
                                 
                                 
                                 ; ***** PORTK ************************
                                 ; PORTK - PORT K Data Register
                                 .equ	PORTK0	= 0	; PORT K Data Register bit 0
                                 .equ	PK0	= 0	; For compatibility
                                 .equ	PORTK1	= 1	; PORT K Data Register bit 1
                                 .equ	PK1	= 1	; For compatibility
                                 .equ	PORTK2	= 2	; PORT K Data Register bit 2
                                 .equ	PK2	= 2	; For compatibility
                                 .equ	PORTK3	= 3	; PORT K Data Register bit 3
                                 .equ	PK3	= 3	; For compatibility
                                 .equ	PORTK4	= 4	; PORT K Data Register bit 4
                                 .equ	PK4	= 4	; For compatibility
                                 .equ	PORTK5	= 5	; PORT K Data Register bit 5
                                 .equ	PK5	= 5	; For compatibility
                                 .equ	PORTK6	= 6	; PORT K Data Register bit 6
                                 .equ	PK6	= 6	; For compatibility
                                 .equ	PORTK7	= 7	; PORT K Data Register bit 7
                                 .equ	PK7	= 7	; For compatibility
                                 
                                 ; DDRK - PORT K Data Direction Register
                                 .equ	DDK0	= 0	; PORT K Data Direction Register bit 0
                                 .equ	DDK1	= 1	; PORT K Data Direction Register bit 1
                                 .equ	DDK2	= 2	; PORT K Data Direction Register bit 2
                                 .equ	DDK3	= 3	; PORT K Data Direction Register bit 3
                                 .equ	DDK4	= 4	; PORT K Data Direction Register bit 4
                                 .equ	DDK5	= 5	; PORT K Data Direction Register bit 5
                                 .equ	DDK6	= 6	; PORT K Data Direction Register bit 6
                                 .equ	DDK7	= 7	; PORT K Data Direction Register bit 7
                                 
                                 ; PINK - PORT K Input Pins
                                 .equ	PINK0	= 0	; PORT K Input Pins bit 0
                                 .equ	PINK1	= 1	; PORT K Input Pins bit 1
                                 .equ	PINK2	= 2	; PORT K Input Pins bit 2
                                 .equ	PINK3	= 3	; PORT K Input Pins bit 3
                                 .equ	PINK4	= 4	; PORT K Input Pins bit 4
                                 .equ	PINK5	= 5	; PORT K Input Pins bit 5
                                 .equ	PINK6	= 6	; PORT K Input Pins bit 6
                                 .equ	PINK7	= 7	; PORT K Input Pins bit 7
                                 
                                 
                                 ; ***** PORTL ************************
                                 ; PORTL - PORT L Data Register
                                 .equ	PORTL0	= 0	; PORT L Data Register bit 0
                                 .equ	PL0	= 0	; For compatibility
                                 .equ	PORTL1	= 1	; PORT L Data Register bit 1
                                 .equ	PL1	= 1	; For compatibility
                                 .equ	PORTL2	= 2	; PORT L Data Register bit 2
                                 .equ	PL2	= 2	; For compatibility
                                 .equ	PORTL3	= 3	; PORT L Data Register bit 3
                                 .equ	PL3	= 3	; For compatibility
                                 .equ	PORTL4	= 4	; PORT L Data Register bit 4
                                 .equ	PL4	= 4	; For compatibility
                                 .equ	PORTL5	= 5	; PORT L Data Register bit 5
                                 .equ	PL5	= 5	; For compatibility
                                 .equ	PORTL6	= 6	; PORT L Data Register bit 6
                                 .equ	PL6	= 6	; For compatibility
                                 .equ	PORTL7	= 7	; PORT L Data Register bit 7
                                 .equ	PL7	= 7	; For compatibility
                                 
                                 ; DDRL - PORT L Data Direction Register
                                 .equ	DDL0	= 0	; PORT L Data Direction Register bit 0
                                 .equ	DDL1	= 1	; PORT L Data Direction Register bit 1
                                 .equ	DDL2	= 2	; PORT L Data Direction Register bit 2
                                 .equ	DDL3	= 3	; PORT L Data Direction Register bit 3
                                 .equ	DDL4	= 4	; PORT L Data Direction Register bit 4
                                 .equ	DDL5	= 5	; PORT L Data Direction Register bit 5
                                 .equ	DDL6	= 6	; PORT L Data Direction Register bit 6
                                 .equ	DDL7	= 7	; PORT L Data Direction Register bit 7
                                 
                                 ; PINL - PORT L Input Pins
                                 .equ	PINL0	= 0	; PORT L Input Pins bit 0
                                 .equ	PINL1	= 1	; PORT L Input Pins bit 1
                                 .equ	PINL2	= 2	; PORT L Input Pins bit 2
                                 .equ	PINL3	= 3	; PORT L Input Pins bit 3
                                 .equ	PINL4	= 4	; PORT L Input Pins bit 4
                                 .equ	PINL5	= 5	; PORT L Input Pins bit 5
                                 .equ	PINL6	= 6	; PORT L Input Pins bit 6
                                 .equ	PINL7	= 7	; PORT L Input Pins bit 7
                                 
                                 
                                 ; ***** TIMER_COUNTER_0 **************
                                 ; TIMSK0 - Timer/Counter0 Interrupt Mask Register
                                 .equ	TOIE0	= 0	; Timer/Counter0 Overflow Interrupt Enable
                                 .equ	OCIE0A	= 1	; Timer/Counter0 Output Compare Match A Interrupt Enable
                                 .equ	OCIE0B	= 2	; Timer/Counter0 Output Compare Match B Interrupt Enable
                                 
                                 ; TIFR0 - Timer/Counter0 Interrupt Flag register
                                 .equ	TOV0	= 0	; Timer/Counter0 Overflow Flag
                                 .equ	OCF0A	= 1	; Timer/Counter0 Output Compare Flag 0A
                                 .equ	OCF0B	= 2	; Timer/Counter0 Output Compare Flag 0B
                                 
                                 ; TCCR0A - Timer/Counter  Control Register A
                                 .equ	WGM00	= 0	; Waveform Generation Mode
                                 .equ	WGM01	= 1	; Waveform Generation Mode
                                 .equ	COM0B0	= 4	; Compare Output Mode, Fast PWm
                                 .equ	COM0B1	= 5	; Compare Output Mode, Fast PWm
                                 .equ	COM0A0	= 6	; Compare Output Mode, Phase Correct PWM Mode
                                 .equ	COM0A1	= 7	; Compare Output Mode, Phase Correct PWM Mode
                                 
                                 ; TCCR0B - Timer/Counter Control Register B
                                 .equ	CS00	= 0	; Clock Select
                                 .equ	CS01	= 1	; Clock Select
                                 .equ	CS02	= 2	; Clock Select
                                 .equ	WGM02	= 3	; 
                                 .equ	FOC0B	= 6	; Force Output Compare B
                                 .equ	FOC0A	= 7	; Force Output Compare A
                                 
                                 ; TCNT0 - Timer/Counter0
                                 .equ	TCNT0_0	= 0	; 
                                 .equ	TCNT0_1	= 1	; 
                                 .equ	TCNT0_2	= 2	; 
                                 .equ	TCNT0_3	= 3	; 
                                 .equ	TCNT0_4	= 4	; 
                                 .equ	TCNT0_5	= 5	; 
                                 .equ	TCNT0_6	= 6	; 
                                 .equ	TCNT0_7	= 7	; 
                                 
                                 ; OCR0A - Timer/Counter0 Output Compare Register
                                 .equ	OCR0A_0	= 0	; 
                                 .equ	OCR0A_1	= 1	; 
                                 .equ	OCR0A_2	= 2	; 
                                 .equ	OCR0A_3	= 3	; 
                                 .equ	OCR0A_4	= 4	; 
                                 .equ	OCR0A_5	= 5	; 
                                 .equ	OCR0A_6	= 6	; 
                                 .equ	OCR0A_7	= 7	; 
                                 
                                 ; OCR0B - Timer/Counter0 Output Compare Register
                                 .equ	OCR0B_0	= 0	; 
                                 .equ	OCR0B_1	= 1	; 
                                 .equ	OCR0B_2	= 2	; 
                                 .equ	OCR0B_3	= 3	; 
                                 .equ	OCR0B_4	= 4	; 
                                 .equ	OCR0B_5	= 5	; 
                                 .equ	OCR0B_6	= 6	; 
                                 .equ	OCR0B_7	= 7	; 
                                 
                                 ; GTCCR - General Timer/Counter Control Register
                                 .equ	PSRSYNC	= 0	; Prescaler Reset Timer/Counter1 and Timer/Counter0
                                 .equ	PSR10	= PSRSYNC	; For compatibility
                                 .equ	TSM	= 7	; Timer/Counter Synchronization Mode
                                 
                                 
                                 ; ***** TIMER_COUNTER_2 **************
                                 ; TIMSK2 - Timer/Counter Interrupt Mask register
                                 .equ	TOIE2	= 0	; Timer/Counter2 Overflow Interrupt Enable
                                 .equ	TOIE2A	= TOIE2	; For compatibility
                                 .equ	OCIE2A	= 1	; Timer/Counter2 Output Compare Match A Interrupt Enable
                                 .equ	OCIE2B	= 2	; Timer/Counter2 Output Compare Match B Interrupt Enable
                                 
                                 ; TIFR2 - Timer/Counter Interrupt Flag Register
                                 .equ	TOV2	= 0	; Timer/Counter2 Overflow Flag
                                 .equ	OCF2A	= 1	; Output Compare Flag 2A
                                 .equ	OCF2B	= 2	; Output Compare Flag 2B
                                 
                                 ; TCCR2A - Timer/Counter2 Control Register A
                                 .equ	WGM20	= 0	; Waveform Genration Mode
                                 .equ	WGM21	= 1	; Waveform Genration Mode
                                 .equ	COM2B0	= 4	; Compare Output Mode bit 0
                                 .equ	COM2B1	= 5	; Compare Output Mode bit 1
                                 .equ	COM2A0	= 6	; Compare Output Mode bit 1
                                 .equ	COM2A1	= 7	; Compare Output Mode bit 1
                                 
                                 ; TCCR2B - Timer/Counter2 Control Register B
                                 .equ	CS20	= 0	; Clock Select bit 0
                                 .equ	CS21	= 1	; Clock Select bit 1
                                 .equ	CS22	= 2	; Clock Select bit 2
                                 .equ	WGM22	= 3	; Waveform Generation Mode
                                 .equ	FOC2B	= 6	; Force Output Compare B
                                 .equ	FOC2A	= 7	; Force Output Compare A
                                 
                                 ; TCNT2 - Timer/Counter2
                                 .equ	TCNT2_0	= 0	; Timer/Counter 2 bit 0
                                 .equ	TCNT2_1	= 1	; Timer/Counter 2 bit 1
                                 .equ	TCNT2_2	= 2	; Timer/Counter 2 bit 2
                                 .equ	TCNT2_3	= 3	; Timer/Counter 2 bit 3
                                 .equ	TCNT2_4	= 4	; Timer/Counter 2 bit 4
                                 .equ	TCNT2_5	= 5	; Timer/Counter 2 bit 5
                                 .equ	TCNT2_6	= 6	; Timer/Counter 2 bit 6
                                 .equ	TCNT2_7	= 7	; Timer/Counter 2 bit 7
                                 
                                 ; OCR2A - Timer/Counter2 Output Compare Register A
                                 .equ	OCR2A_0	= 0	; Timer/Counter2 Output Compare Register Bit 0
                                 .equ	OCR2A_1	= 1	; Timer/Counter2 Output Compare Register Bit 1
                                 .equ	OCR2A_2	= 2	; Timer/Counter2 Output Compare Register Bit 2
                                 .equ	OCR2A_3	= 3	; Timer/Counter2 Output Compare Register Bit 3
                                 .equ	OCR2A_4	= 4	; Timer/Counter2 Output Compare Register Bit 4
                                 .equ	OCR2A_5	= 5	; Timer/Counter2 Output Compare Register Bit 5
                                 .equ	OCR2A_6	= 6	; Timer/Counter2 Output Compare Register Bit 6
                                 .equ	OCR2A_7	= 7	; Timer/Counter2 Output Compare Register Bit 7
                                 
                                 ; OCR2B - Timer/Counter2 Output Compare Register B
                                 .equ	OCR2B_0	= 0	; Timer/Counter2 Output Compare Register Bit 0
                                 .equ	OCR2B_1	= 1	; Timer/Counter2 Output Compare Register Bit 1
                                 .equ	OCR2B_2	= 2	; Timer/Counter2 Output Compare Register Bit 2
                                 .equ	OCR2B_3	= 3	; Timer/Counter2 Output Compare Register Bit 3
                                 .equ	OCR2B_4	= 4	; Timer/Counter2 Output Compare Register Bit 4
                                 .equ	OCR2B_5	= 5	; Timer/Counter2 Output Compare Register Bit 5
                                 .equ	OCR2B_6	= 6	; Timer/Counter2 Output Compare Register Bit 6
                                 .equ	OCR2B_7	= 7	; Timer/Counter2 Output Compare Register Bit 7
                                 
                                 ; ASSR - Asynchronous Status Register
                                 .equ	TCR2BUB	= 0	; Timer/Counter Control Register2 Update Busy
                                 .equ	TCR2AUB	= 1	; Timer/Counter Control Register2 Update Busy
                                 .equ	OCR2BUB	= 2	; Output Compare Register 2 Update Busy
                                 .equ	OCR2AUB	= 3	; Output Compare Register2 Update Busy
                                 .equ	TCN2UB	= 4	; Timer/Counter2 Update Busy
                                 .equ	AS2	= 5	; Asynchronous Timer/Counter2
                                 .equ	EXCLK	= 6	; Enable External Clock Input
                                 
                                 ; GTCCR - General Timer Counter Control register
                                 .equ	PSRASY	= 1	; Prescaler Reset Timer/Counter2
                                 .equ	PSR2	= PSRASY	; For compatibility
                                 ;.equ	TSM	= 7	; Timer/Counter Synchronization Mode
                                 
                                 
                                 ; ***** WATCHDOG *********************
                                 ; WDTCSR - Watchdog Timer Control Register
                                 .equ	WDP0	= 0	; Watch Dog Timer Prescaler bit 0
                                 .equ	WDP1	= 1	; Watch Dog Timer Prescaler bit 1
                                 .equ	WDP2	= 2	; Watch Dog Timer Prescaler bit 2
                                 .equ	WDE	= 3	; Watch Dog Enable
                                 .equ	WDCE	= 4	; Watchdog Change Enable
                                 .equ	WDP3	= 5	; Watchdog Timer Prescaler Bit 3
                                 .equ	WDIE	= 6	; Watchdog Timeout Interrupt Enable
                                 .equ	WDIF	= 7	; Watchdog Timeout Interrupt Flag
                                 
                                 
                                 ; ***** USART1 ***********************
                                 ; UDR1 - USART I/O Data Register
                                 .equ	UDR1_0	= 0	; USART I/O Data Register bit 0
                                 .equ	UDR1_1	= 1	; USART I/O Data Register bit 1
                                 .equ	UDR1_2	= 2	; USART I/O Data Register bit 2
                                 .equ	UDR1_3	= 3	; USART I/O Data Register bit 3
                                 .equ	UDR1_4	= 4	; USART I/O Data Register bit 4
                                 .equ	UDR1_5	= 5	; USART I/O Data Register bit 5
                                 .equ	UDR1_6	= 6	; USART I/O Data Register bit 6
                                 .equ	UDR1_7	= 7	; USART I/O Data Register bit 7
                                 
                                 ; UCSR1A - USART Control and Status Register A
                                 .equ	MPCM1	= 0	; Multi-processor Communication Mode
                                 .equ	U2X1	= 1	; Double the USART transmission speed
                                 .equ	UPE1	= 2	; Parity Error
                                 .equ	DOR1	= 3	; Data overRun
                                 .equ	FE1	= 4	; Framing Error
                                 .equ	UDRE1	= 5	; USART Data Register Empty
                                 .equ	TXC1	= 6	; USART Transmitt Complete
                                 .equ	RXC1	= 7	; USART Receive Complete
                                 
                                 ; UCSR1B - USART Control and Status Register B
                                 .equ	TXB81	= 0	; Transmit Data Bit 8
                                 .equ	RXB81	= 1	; Receive Data Bit 8
                                 .equ	UCSZ12	= 2	; Character Size
                                 .equ	TXEN1	= 3	; Transmitter Enable
                                 .equ	RXEN1	= 4	; Receiver Enable
                                 .equ	UDRIE1	= 5	; USART Data register Empty Interrupt Enable
                                 .equ	TXCIE1	= 6	; TX Complete Interrupt Enable
                                 .equ	RXCIE1	= 7	; RX Complete Interrupt Enable
                                 
                                 ; UCSR1C - USART Control and Status Register C
                                 .equ	UCPOL1	= 0	; Clock Polarity
                                 .equ	UCSZ10	= 1	; Character Size
                                 .equ	UCPHA1	= UCSZ10	; For compatibility
                                 .equ	UCSZ11	= 2	; Character Size
                                 .equ	UDORD1	= UCSZ11	; For compatibility
                                 .equ	USBS1	= 3	; Stop Bit Select
                                 .equ	UPM10	= 4	; Parity Mode Bit 0
                                 .equ	UPM11	= 5	; Parity Mode Bit 1
                                 .equ	UMSEL10	= 6	; USART Mode Select
                                 .equ	UMSEL11	= 7	; USART Mode Select
                                 
                                 ; UBRR1H - USART Baud Rate Register High Byte
                                 .equ	UBRR_8	= 0	; USART Baud Rate Register bit 8
                                 .equ	UBRR_9	= 1	; USART Baud Rate Register bit 9
                                 .equ	UBRR_10	= 2	; USART Baud Rate Register bit 10
                                 .equ	UBRR_11	= 3	; USART Baud Rate Register bit 11
                                 
                                 ; UBRR1L - USART Baud Rate Register Low Byte
                                 .equ	UBRR_0	= 0	; USART Baud Rate Register bit 0
                                 .equ	UBRR_1	= 1	; USART Baud Rate Register bit 1
                                 .equ	UBRR_2	= 2	; USART Baud Rate Register bit 2
                                 .equ	UBRR_3	= 3	; USART Baud Rate Register bit 3
                                 .equ	UBRR_4	= 4	; USART Baud Rate Register bit 4
                                 .equ	UBRR_5	= 5	; USART Baud Rate Register bit 5
                                 .equ	UBRR_6	= 6	; USART Baud Rate Register bit 6
                                 .equ	UBRR_7	= 7	; USART Baud Rate Register bit 7
                                 
                                 
                                 ; ***** EEPROM ***********************
                                 ; EEARH - EEPROM Address Register Low Byte
                                 .equ	EEAR8	= 0	; EEPROM Read/Write Access Bit 8
                                 .equ	EEAR9	= 1	; EEPROM Read/Write Access Bit 9
                                 .equ	EEAR10	= 2	; EEPROM Read/Write Access Bit 10
                                 .equ	EEAR11	= 3	; EEPROM Read/Write Access Bit 11
                                 
                                 ; EEARL - EEPROM Address Register Low Byte
                                 .equ	EEAR0	= 0	; EEPROM Read/Write Access Bit 0
                                 .equ	EEAR1	= 1	; EEPROM Read/Write Access Bit 1
                                 .equ	EEAR2	= 2	; EEPROM Read/Write Access Bit 2
                                 .equ	EEAR3	= 3	; EEPROM Read/Write Access Bit 3
                                 .equ	EEAR4	= 4	; EEPROM Read/Write Access Bit 4
                                 .equ	EEAR5	= 5	; EEPROM Read/Write Access Bit 5
                                 .equ	EEAR6	= 6	; EEPROM Read/Write Access Bit 6
                                 .equ	EEAR7	= 7	; EEPROM Read/Write Access Bit 7
                                 
                                 ; EEDR - EEPROM Data Register
                                 .equ	EEDR0	= 0	; EEPROM Data Register bit 0
                                 .equ	EEDR1	= 1	; EEPROM Data Register bit 1
                                 .equ	EEDR2	= 2	; EEPROM Data Register bit 2
                                 .equ	EEDR3	= 3	; EEPROM Data Register bit 3
                                 .equ	EEDR4	= 4	; EEPROM Data Register bit 4
                                 .equ	EEDR5	= 5	; EEPROM Data Register bit 5
                                 .equ	EEDR6	= 6	; EEPROM Data Register bit 6
                                 .equ	EEDR7	= 7	; EEPROM Data Register bit 7
                                 
                                 ; EECR - EEPROM Control Register
                                 .equ	EERE	= 0	; EEPROM Read Enable
                                 .equ	EEPE	= 1	; EEPROM Write Enable
                                 .equ	EEMPE	= 2	; EEPROM Master Write Enable
                                 .equ	EERIE	= 3	; EEPROM Ready Interrupt Enable
                                 .equ	EEPM0	= 4	; EEPROM Programming Mode Bit 0
                                 .equ	EEPM1	= 5	; EEPROM Programming Mode Bit 1
                                 
                                 
                                 ; ***** TIMER_COUNTER_5 **************
                                 ; TIMSK5 - Timer/Counter5 Interrupt Mask Register
                                 .equ	TOIE5	= 0	; Timer/Counter5 Overflow Interrupt Enable
                                 .equ	OCIE5A	= 1	; Timer/Counter5 Output Compare A Match Interrupt Enable
                                 .equ	OCIE5B	= 2	; Timer/Counter5 Output Compare B Match Interrupt Enable
                                 .equ	OCIE5C	= 3	; Timer/Counter5 Output Compare C Match Interrupt Enable
                                 .equ	ICIE5	= 5	; Timer/Counter5 Input Capture Interrupt Enable
                                 
                                 ; TIFR5 - Timer/Counter5 Interrupt Flag register
                                 .equ	TOV5	= 0	; Timer/Counter5 Overflow Flag
                                 .equ	OCF5A	= 1	; Output Compare Flag 5A
                                 .equ	OCF5B	= 2	; Output Compare Flag 5B
                                 .equ	OCF5C	= 3	; Output Compare Flag 5C
                                 .equ	ICF5	= 5	; Input Capture Flag 5
                                 
                                 ; TCCR5A - Timer/Counter5 Control Register A
                                 .equ	WGM50	= 0	; Waveform Generation Mode
                                 .equ	WGM51	= 1	; Waveform Generation Mode
                                 .equ	COM5C0	= 2	; Compare Output Mode 5C, bit 0
                                 .equ	COM5C1	= 3	; Compare Output Mode 5C, bit 1
                                 .equ	COM5B0	= 4	; Compare Output Mode 5B, bit 0
                                 .equ	COM5B1	= 5	; Compare Output Mode 5B, bit 1
                                 .equ	COM5A0	= 6	; Compare Output Mode 5A, bit 0
                                 .equ	COM5A1	= 7	; Compare Output Mode 1A, bit 1
                                 
                                 ; TCCR5B - Timer/Counter5 Control Register B
                                 .equ	CS50	= 0	; Prescaler source of Timer/Counter 5
                                 .equ	CS51	= 1	; Prescaler source of Timer/Counter 5
                                 .equ	CS52	= 2	; Prescaler source of Timer/Counter 5
                                 .equ	WGM52	= 3	; Waveform Generation Mode
                                 .equ	WGM53	= 4	; Waveform Generation Mode
                                 .equ	ICES5	= 6	; Input Capture 5 Edge Select
                                 .equ	ICNC5	= 7	; Input Capture 5 Noise Canceler
                                 
                                 ; TCCR5C - Timer/Counter 5 Control Register C
                                 .equ	FOC5C	= 5	; Force Output Compare 5C
                                 .equ	FOC5B	= 6	; Force Output Compare 5B
                                 .equ	FOC5A	= 7	; Force Output Compare 5A
                                 
                                 ; ICR5H - Timer/Counter5 Input Capture Register High Byte
                                 .equ	ICR5H0	= 0	; Timer/Counter5 Input Capture Register High Byte bit 0
                                 .equ	ICR5H1	= 1	; Timer/Counter5 Input Capture Register High Byte bit 1
                                 .equ	ICR5H2	= 2	; Timer/Counter5 Input Capture Register High Byte bit 2
                                 .equ	ICR5H3	= 3	; Timer/Counter5 Input Capture Register High Byte bit 3
                                 .equ	ICR5H4	= 4	; Timer/Counter5 Input Capture Register High Byte bit 4
                                 .equ	ICR5H5	= 5	; Timer/Counter5 Input Capture Register High Byte bit 5
                                 .equ	ICR5H6	= 6	; Timer/Counter5 Input Capture Register High Byte bit 6
                                 .equ	ICR5H7	= 7	; Timer/Counter5 Input Capture Register High Byte bit 7
                                 
                                 ; ICR5L - Timer/Counter5 Input Capture Register Low Byte
                                 .equ	ICR5L0	= 0	; Timer/Counter5 Input Capture Register Low Byte bit 0
                                 .equ	ICR5L1	= 1	; Timer/Counter5 Input Capture Register Low Byte bit 1
                                 .equ	ICR5L2	= 2	; Timer/Counter5 Input Capture Register Low Byte bit 2
                                 .equ	ICR5L3	= 3	; Timer/Counter5 Input Capture Register Low Byte bit 3
                                 .equ	ICR5L4	= 4	; Timer/Counter5 Input Capture Register Low Byte bit 4
                                 .equ	ICR5L5	= 5	; Timer/Counter5 Input Capture Register Low Byte bit 5
                                 .equ	ICR5L6	= 6	; Timer/Counter5 Input Capture Register Low Byte bit 6
                                 .equ	ICR5L7	= 7	; Timer/Counter5 Input Capture Register Low Byte bit 7
                                 
                                 
                                 ; ***** TIMER_COUNTER_4 **************
                                 ; TIMSK4 - Timer/Counter4 Interrupt Mask Register
                                 .equ	TOIE4	= 0	; Timer/Counter4 Overflow Interrupt Enable
                                 .equ	OCIE4A	= 1	; Timer/Counter4 Output Compare A Match Interrupt Enable
                                 .equ	OCIE4B	= 2	; Timer/Counter4 Output Compare B Match Interrupt Enable
                                 .equ	OCIE4C	= 3	; Timer/Counter4 Output Compare C Match Interrupt Enable
                                 .equ	ICIE4	= 5	; Timer/Counter4 Input Capture Interrupt Enable
                                 
                                 ; TIFR4 - Timer/Counter4 Interrupt Flag register
                                 .equ	TOV4	= 0	; Timer/Counter4 Overflow Flag
                                 .equ	OCF4A	= 1	; Output Compare Flag 4A
                                 .equ	OCF4B	= 2	; Output Compare Flag 4B
                                 .equ	OCF4C	= 3	; Output Compare Flag 4C
                                 .equ	ICF4	= 5	; Input Capture Flag 4
                                 
                                 ; TCCR4A - Timer/Counter4 Control Register A
                                 .equ	WGM40	= 0	; Waveform Generation Mode
                                 .equ	WGM41	= 1	; Waveform Generation Mode
                                 .equ	COM4C0	= 2	; Compare Output Mode 4C, bit 0
                                 .equ	COM4C1	= 3	; Compare Output Mode 4C, bit 1
                                 .equ	COM4B0	= 4	; Compare Output Mode 4B, bit 0
                                 .equ	COM4B1	= 5	; Compare Output Mode 4B, bit 1
                                 .equ	COM4A0	= 6	; Compare Output Mode 4A, bit 0
                                 .equ	COM4A1	= 7	; Compare Output Mode 1A, bit 1
                                 
                                 ; TCCR4B - Timer/Counter4 Control Register B
                                 .equ	CS40	= 0	; Prescaler source of Timer/Counter 4
                                 .equ	CS41	= 1	; Prescaler source of Timer/Counter 4
                                 .equ	CS42	= 2	; Prescaler source of Timer/Counter 4
                                 .equ	WGM42	= 3	; Waveform Generation Mode
                                 .equ	WGM43	= 4	; Waveform Generation Mode
                                 .equ	ICES4	= 6	; Input Capture 4 Edge Select
                                 .equ	ICNC4	= 7	; Input Capture 4 Noise Canceler
                                 
                                 ; TCCR4C - Timer/Counter 4 Control Register C
                                 .equ	FOC4C	= 5	; Force Output Compare 4C
                                 .equ	FOC4B	= 6	; Force Output Compare 4B
                                 .equ	FOC4A	= 7	; Force Output Compare 4A
                                 
                                 
                                 ; ***** TIMER_COUNTER_3 **************
                                 ; TIMSK3 - Timer/Counter3 Interrupt Mask Register
                                 .equ	TOIE3	= 0	; Timer/Counter3 Overflow Interrupt Enable
                                 .equ	OCIE3A	= 1	; Timer/Counter3 Output Compare A Match Interrupt Enable
                                 .equ	OCIE3B	= 2	; Timer/Counter3 Output Compare B Match Interrupt Enable
                                 .equ	OCIE3C	= 3	; Timer/Counter3 Output Compare C Match Interrupt Enable
                                 .equ	ICIE3	= 5	; Timer/Counter3 Input Capture Interrupt Enable
                                 
                                 ; TIFR3 - Timer/Counter3 Interrupt Flag register
                                 .equ	TOV3	= 0	; Timer/Counter3 Overflow Flag
                                 .equ	OCF3A	= 1	; Output Compare Flag 3A
                                 .equ	OCF3B	= 2	; Output Compare Flag 3B
                                 .equ	OCF3C	= 3	; Output Compare Flag 3C
                                 .equ	ICF3	= 5	; Input Capture Flag 3
                                 
                                 ; TCCR3A - Timer/Counter3 Control Register A
                                 .equ	WGM30	= 0	; Waveform Generation Mode
                                 .equ	WGM31	= 1	; Waveform Generation Mode
                                 .equ	COM3C0	= 2	; Compare Output Mode 3C, bit 0
                                 .equ	COM3C1	= 3	; Compare Output Mode 3C, bit 1
                                 .equ	COM3B0	= 4	; Compare Output Mode 3B, bit 0
                                 .equ	COM3B1	= 5	; Compare Output Mode 3B, bit 1
                                 .equ	COM3A0	= 6	; Compare Output Mode 3A, bit 0
                                 .equ	COM3A1	= 7	; Compare Output Mode 1A, bit 1
                                 
                                 ; TCCR3B - Timer/Counter3 Control Register B
                                 .equ	CS30	= 0	; Prescaler source of Timer/Counter 3
                                 .equ	CS31	= 1	; Prescaler source of Timer/Counter 3
                                 .equ	CS32	= 2	; Prescaler source of Timer/Counter 3
                                 .equ	WGM32	= 3	; Waveform Generation Mode
                                 .equ	WGM33	= 4	; Waveform Generation Mode
                                 .equ	ICES3	= 6	; Input Capture 3 Edge Select
                                 .equ	ICNC3	= 7	; Input Capture 3 Noise Canceler
                                 
                                 ; TCCR3C - Timer/Counter 3 Control Register C
                                 .equ	FOC3C	= 5	; Force Output Compare 3C
                                 .equ	FOC3B	= 6	; Force Output Compare 3B
                                 .equ	FOC3A	= 7	; Force Output Compare 3A
                                 
                                 
                                 ; ***** TIMER_COUNTER_1 **************
                                 ; TIMSK1 - Timer/Counter1 Interrupt Mask Register
                                 .equ	TOIE1	= 0	; Timer/Counter1 Overflow Interrupt Enable
                                 .equ	OCIE1A	= 1	; Timer/Counter1 Output Compare A Match Interrupt Enable
                                 .equ	OCIE1B	= 2	; Timer/Counter1 Output Compare B Match Interrupt Enable
                                 .equ	OCIE1C	= 3	; Timer/Counter1 Output Compare C Match Interrupt Enable
                                 .equ	ICIE1	= 5	; Timer/Counter1 Input Capture Interrupt Enable
                                 
                                 ; TIFR1 - Timer/Counter1 Interrupt Flag register
                                 .equ	TOV1	= 0	; Timer/Counter1 Overflow Flag
                                 .equ	OCF1A	= 1	; Output Compare Flag 1A
                                 .equ	OCF1B	= 2	; Output Compare Flag 1B
                                 .equ	OCF1C	= 3	; Output Compare Flag 1C
                                 .equ	ICF1	= 5	; Input Capture Flag 1
                                 
                                 ; TCCR1A - Timer/Counter1 Control Register A
                                 .equ	WGM10	= 0	; Waveform Generation Mode
                                 .equ	WGM11	= 1	; Waveform Generation Mode
                                 .equ	COM1C0	= 2	; Compare Output Mode 1C, bit 0
                                 .equ	COM1C1	= 3	; Compare Output Mode 1C, bit 1
                                 .equ	COM1B0	= 4	; Compare Output Mode 1B, bit 0
                                 .equ	COM1B1	= 5	; Compare Output Mode 1B, bit 1
                                 .equ	COM1A0	= 6	; Compare Output Mode 1A, bit 0
                                 .equ	COM1A1	= 7	; Compare Output Mode 1A, bit 1
                                 
                                 ; TCCR1B - Timer/Counter1 Control Register B
                                 .equ	CS10	= 0	; Prescaler source of Timer/Counter 1
                                 .equ	CS11	= 1	; Prescaler source of Timer/Counter 1
                                 .equ	CS12	= 2	; Prescaler source of Timer/Counter 1
                                 .equ	WGM12	= 3	; Waveform Generation Mode
                                 .equ	WGM13	= 4	; Waveform Generation Mode
                                 .equ	ICES1	= 6	; Input Capture 1 Edge Select
                                 .equ	ICNC1	= 7	; Input Capture 1 Noise Canceler
                                 
                                 ; TCCR1C - Timer/Counter 1 Control Register C
                                 .equ	FOC1C	= 5	; Force Output Compare 1C
                                 .equ	FOC1B	= 6	; Force Output Compare 1B
                                 .equ	FOC1A	= 7	; Force Output Compare 1A
                                 
                                 
                                 ; ***** JTAG *************************
                                 ; OCDR - On-Chip Debug Related Register in I/O Memory
                                 .equ	OCDR0	= 0	; On-Chip Debug Register Bit 0
                                 .equ	OCDR1	= 1	; On-Chip Debug Register Bit 1
                                 .equ	OCDR2	= 2	; On-Chip Debug Register Bit 2
                                 .equ	OCDR3	= 3	; On-Chip Debug Register Bit 3
                                 .equ	OCDR4	= 4	; On-Chip Debug Register Bit 4
                                 .equ	OCDR5	= 5	; On-Chip Debug Register Bit 5
                                 .equ	OCDR6	= 6	; On-Chip Debug Register Bit 6
                                 .equ	OCDR7	= 7	; On-Chip Debug Register Bit 7
                                 .equ	IDRD	= OCDR7	; For compatibility
                                 
                                 ; MCUCR - MCU Control Register
                                 .equ	JTD	= 7	; JTAG Interface Disable
                                 
                                 ; MCUSR - MCU Status Register
                                 .equ	JTRF	= 4	; JTAG Reset Flag
                                 
                                 
                                 ; ***** EXTERNAL_INTERRUPT ***********
                                 ; EICRA - External Interrupt Control Register A
                                 .equ	ISC00	= 0	; External Interrupt Sense Control Bit
                                 .equ	ISC01	= 1	; External Interrupt Sense Control Bit
                                 .equ	ISC10	= 2	; External Interrupt Sense Control Bit
                                 .equ	ISC11	= 3	; External Interrupt Sense Control Bit
                                 .equ	ISC20	= 4	; External Interrupt Sense Control Bit
                                 .equ	ISC21	= 5	; External Interrupt Sense Control Bit
                                 .equ	ISC30	= 6	; External Interrupt Sense Control Bit
                                 .equ	ISC31	= 7	; External Interrupt Sense Control Bit
                                 
                                 ; EICRB - External Interrupt Control Register B
                                 .equ	ISC40	= 0	; External Interrupt 7-4 Sense Control Bit
                                 .equ	ISC41	= 1	; External Interrupt 7-4 Sense Control Bit
                                 .equ	ISC50	= 2	; External Interrupt 7-4 Sense Control Bit
                                 .equ	ISC51	= 3	; External Interrupt 7-4 Sense Control Bit
                                 .equ	ISC60	= 4	; External Interrupt 7-4 Sense Control Bit
                                 .equ	ISC61	= 5	; External Interrupt 7-4 Sense Control Bit
                                 .equ	ISC70	= 6	; External Interrupt 7-4 Sense Control Bit
                                 .equ	ISC71	= 7	; External Interrupt 7-4 Sense Control Bit
                                 
                                 ; EIMSK - External Interrupt Mask Register
                                 .equ	INT0	= 0	; External Interrupt Request 0 Enable
                                 .equ	INT1	= 1	; External Interrupt Request 1 Enable
                                 .equ	INT2	= 2	; External Interrupt Request 2 Enable
                                 .equ	INT3	= 3	; External Interrupt Request 3 Enable
                                 .equ	INT4	= 4	; External Interrupt Request 4 Enable
                                 .equ	INT5	= 5	; External Interrupt Request 5 Enable
                                 .equ	INT6	= 6	; External Interrupt Request 6 Enable
                                 .equ	INT7	= 7	; External Interrupt Request 7 Enable
                                 
                                 ; EIFR - External Interrupt Flag Register
                                 .equ	INTF0	= 0	; External Interrupt Flag 0
                                 .equ	INTF1	= 1	; External Interrupt Flag 1
                                 .equ	INTF2	= 2	; External Interrupt Flag 2
                                 .equ	INTF3	= 3	; External Interrupt Flag 3
                                 .equ	INTF4	= 4	; External Interrupt Flag 4
                                 .equ	INTF5	= 5	; External Interrupt Flag 5
                                 .equ	INTF6	= 6	; External Interrupt Flag 6
                                 .equ	INTF7	= 7	; External Interrupt Flag 7
                                 
                                 ; PCICR - Pin Change Interrupt Control Register
                                 .equ	PCIE0	= 0	; Pin Change Interrupt Enable 0
                                 .equ	PCIE1	= 1	; Pin Change Interrupt Enable 1
                                 .equ	PCIE2	= 2	; Pin Change Interrupt Enable 2
                                 
                                 ; PCIFR - Pin Change Interrupt Flag Register
                                 .equ	PCIF0	= 0	; Pin Change Interrupt Flag 0
                                 .equ	PCIF1	= 1	; Pin Change Interrupt Flag 1
                                 .equ	PCIF2	= 2	; Pin Change Interrupt Flag 2
                                 
                                 ; PCMSK2 - Pin Change Mask Register 2
                                 .equ	PCINT16	= 0	; Pin Change Enable Mask 16
                                 .equ	PCINT17	= 1	; Pin Change Enable Mask 17
                                 .equ	PCINT18	= 2	; Pin Change Enable Mask 18
                                 .equ	PCINT19	= 3	; Pin Change Enable Mask 19
                                 .equ	PCINT20	= 4	; Pin Change Enable Mask 20
                                 .equ	PCINT21	= 5	; Pin Change Enable Mask 21
                                 .equ	PCINT22	= 6	; Pin Change Enable Mask 22
                                 .equ	PCINT23	= 7	; Pin Change Enable Mask 23
                                 
                                 ; PCMSK1 - Pin Change Mask Register 1
                                 .equ	PCINT8	= 0	; Pin Change Enable Mask 8
                                 .equ	PCINT9	= 1	; Pin Change Enable Mask 9
                                 .equ	PCINT10	= 2	; Pin Change Enable Mask 10
                                 .equ	PCINT11	= 3	; Pin Change Enable Mask 11
                                 .equ	PCINT12	= 4	; Pin Change Enable Mask 12
                                 .equ	PCINT13	= 5	; Pin Change Enable Mask 13
                                 .equ	PCINT14	= 6	; Pin Change Enable Mask 14
                                 .equ	PCINT15	= 7	; Pin Change Enable Mask 15
                                 
                                 ; PCMSK0 - Pin Change Mask Register 0
                                 .equ	PCINT0	= 0	; Pin Change Enable Mask 0
                                 .equ	PCINT1	= 1	; Pin Change Enable Mask 1
                                 .equ	PCINT2	= 2	; Pin Change Enable Mask 2
                                 .equ	PCINT3	= 3	; Pin Change Enable Mask 3
                                 .equ	PCINT4	= 4	; Pin Change Enable Mask 4
                                 .equ	PCINT5	= 5	; Pin Change Enable Mask 5
                                 .equ	PCINT6	= 6	; Pin Change Enable Mask 6
                                 .equ	PCINT7	= 7	; Pin Change Enable Mask 7
                                 
                                 
                                 ; ***** CPU **************************
                                 ; SREG - Status Register
                                 .equ	SREG_C	= 0	; Carry Flag
                                 .equ	SREG_Z	= 1	; Zero Flag
                                 .equ	SREG_N	= 2	; Negative Flag
                                 .equ	SREG_V	= 3	; Two's Complement Overflow Flag
                                 .equ	SREG_S	= 4	; Sign Bit
                                 .equ	SREG_H	= 5	; Half Carry Flag
                                 .equ	SREG_T	= 6	; Bit Copy Storage
                                 .equ	SREG_I	= 7	; Global Interrupt Enable
                                 
                                 ; MCUCR - MCU Control Register
                                 .equ	IVCE	= 0	; Interrupt Vector Change Enable
                                 .equ	IVSEL	= 1	; Interrupt Vector Select
                                 .equ	PUD	= 4	; Pull-up disable
                                 ;.equ	JTD	= 7	; JTAG Interface Disable
                                 
                                 ; MCUSR - MCU Status Register
                                 .equ	PORF	= 0	; Power-on reset flag
                                 .equ	EXTRF	= 1	; External Reset Flag
                                 .equ	BORF	= 2	; Brown-out Reset Flag
                                 .equ	WDRF	= 3	; Watchdog Reset Flag
                                 ;.equ	JTRF	= 4	; JTAG Reset Flag
                                 
                                 ; XMCRA - External Memory Control Register A
                                 .equ	SRW00	= 0	; Wait state select bit lower page
                                 .equ	SRW01	= 1	; Wait state select bit lower page
                                 .equ	SRW10	= 2	; Wait state select bit upper page
                                 .equ	SRW11	= 3	; Wait state select bit upper page
                                 .equ	SRL0	= 4	; Wait state page limit
                                 .equ	SRL1	= 5	; Wait state page limit
                                 .equ	SRL2	= 6	; Wait state page limit
                                 .equ	SRE	= 7	; External SRAM Enable
                                 
                                 ; XMCRB - External Memory Control Register B
                                 .equ	XMM0	= 0	; External Memory High Mask
                                 .equ	XMM1	= 1	; External Memory High Mask
                                 .equ	XMM2	= 2	; External Memory High Mask
                                 .equ	XMBK	= 7	; External Memory Bus Keeper Enable
                                 
                                 ; OSCCAL - Oscillator Calibration Value
                                 .equ	CAL0	= 0	; Oscillator Calibration Value Bit0
                                 .equ	CAL1	= 1	; Oscillator Calibration Value Bit1
                                 .equ	CAL2	= 2	; Oscillator Calibration Value Bit2
                                 .equ	CAL3	= 3	; Oscillator Calibration Value Bit3
                                 .equ	CAL4	= 4	; Oscillator Calibration Value Bit4
                                 .equ	CAL5	= 5	; Oscillator Calibration Value Bit5
                                 .equ	CAL6	= 6	; Oscillator Calibration Value Bit6
                                 .equ	CAL7	= 7	; Oscillator Calibration Value Bit7
                                 
                                 ; CLKPR - 
                                 .equ	CLKPS0	= 0	; 
                                 .equ	CLKPS1	= 1	; 
                                 .equ	CLKPS2	= 2	; 
                                 .equ	CLKPS3	= 3	; 
                                 .equ	CLKPCE	= 7	; 
                                 
                                 ; SMCR - Sleep Mode Control Register
                                 .equ	SE	= 0	; Sleep Enable
                                 .equ	SM0	= 1	; Sleep Mode Select bit 0
                                 .equ	SM1	= 2	; Sleep Mode Select bit 1
                                 .equ	SM2	= 3	; Sleep Mode Select bit 2
                                 
                                 ; RAMPZ - RAM Page Z Select Register
                                 .equ	RAMPZ0	= 0	; RAM Page Z Select Register Bit 0
                                 .equ	RAMPZ1	= 1	; RAM Page Z Select Register Bit 1
                                 
                                 ; EIND - Extended Indirect Register
                                 .equ	EIND0	= 0	; Bit 0
                                 
                                 ; GPIOR2 - General Purpose IO Register 2
                                 .equ	GPIOR20	= 0	; General Purpose IO Register 2 bit 0
                                 .equ	GPIOR21	= 1	; General Purpose IO Register 2 bit 1
                                 .equ	GPIOR22	= 2	; General Purpose IO Register 2 bit 2
                                 .equ	GPIOR23	= 3	; General Purpose IO Register 2 bit 3
                                 .equ	GPIOR24	= 4	; General Purpose IO Register 2 bit 4
                                 .equ	GPIOR25	= 5	; General Purpose IO Register 2 bit 5
                                 .equ	GPIOR26	= 6	; General Purpose IO Register 2 bit 6
                                 .equ	GPIOR27	= 7	; General Purpose IO Register 2 bit 7
                                 
                                 ; GPIOR1 - General Purpose IO Register 1
                                 .equ	GPIOR10	= 0	; General Purpose IO Register 1 bit 0
                                 .equ	GPIOR11	= 1	; General Purpose IO Register 1 bit 1
                                 .equ	GPIOR12	= 2	; General Purpose IO Register 1 bit 2
                                 .equ	GPIOR13	= 3	; General Purpose IO Register 1 bit 3
                                 .equ	GPIOR14	= 4	; General Purpose IO Register 1 bit 4
                                 .equ	GPIOR15	= 5	; General Purpose IO Register 1 bit 5
                                 .equ	GPIOR16	= 6	; General Purpose IO Register 1 bit 6
                                 .equ	GPIOR17	= 7	; General Purpose IO Register 1 bit 7
                                 
                                 ; GPIOR0 - General Purpose IO Register 0
                                 .equ	GPIOR00	= 0	; General Purpose IO Register 0 bit 0
                                 .equ	GPIOR01	= 1	; General Purpose IO Register 0 bit 1
                                 .equ	GPIOR02	= 2	; General Purpose IO Register 0 bit 2
                                 .equ	GPIOR03	= 3	; General Purpose IO Register 0 bit 3
                                 .equ	GPIOR04	= 4	; General Purpose IO Register 0 bit 4
                                 .equ	GPIOR05	= 5	; General Purpose IO Register 0 bit 5
                                 .equ	GPIOR06	= 6	; General Purpose IO Register 0 bit 6
                                 .equ	GPIOR07	= 7	; General Purpose IO Register 0 bit 7
                                 
                                 ; PRR1 - Power Reduction Register1
                                 .equ	PRUSART1	= 0	; Power Reduction USART1
                                 .equ	PRUSART2	= 1	; Power Reduction USART2
                                 .equ	PRUSART3	= 2	; Power Reduction USART3
                                 .equ	PRTIM3	= 3	; Power Reduction Timer/Counter3
                                 .equ	PRTIM4	= 4	; Power Reduction Timer/Counter4
                                 .equ	PRTIM5	= 5	; Power Reduction Timer/Counter5
                                 
                                 ; PRR0 - Power Reduction Register0
                                 .equ	PRADC	= 0	; Power Reduction ADC
                                 .equ	PRUSART0	= 1	; Power Reduction USART
                                 .equ	PRSPI	= 2	; Power Reduction Serial Peripheral Interface
                                 .equ	PRTIM1	= 3	; Power Reduction Timer/Counter1
                                 .equ	PRTIM0	= 5	; Power Reduction Timer/Counter0
                                 .equ	PRTIM2	= 6	; Power Reduction Timer/Counter2
                                 .equ	PRTWI	= 7	; Power Reduction TWI
                                 
                                 
                                 ; ***** AD_CONVERTER *****************
                                 ; ADMUX - The ADC multiplexer Selection Register
                                 .equ	MUX0	= 0	; Analog Channel and Gain Selection Bits
                                 .equ	MUX1	= 1	; Analog Channel and Gain Selection Bits
                                 .equ	MUX2	= 2	; Analog Channel and Gain Selection Bits
                                 .equ	MUX3	= 3	; Analog Channel and Gain Selection Bits
                                 .equ	MUX4	= 4	; Analog Channel and Gain Selection Bits
                                 .equ	ADLAR	= 5	; Left Adjust Result
                                 .equ	REFS0	= 6	; Reference Selection Bit 0
                                 .equ	REFS1	= 7	; Reference Selection Bit 1
                                 
                                 ; ADCSRA - The ADC Control and Status register A
                                 .equ	ADPS0	= 0	; ADC  Prescaler Select Bits
                                 .equ	ADPS1	= 1	; ADC  Prescaler Select Bits
                                 .equ	ADPS2	= 2	; ADC  Prescaler Select Bits
                                 .equ	ADIE	= 3	; ADC Interrupt Enable
                                 .equ	ADIF	= 4	; ADC Interrupt Flag
                                 .equ	ADATE	= 5	; ADC  Auto Trigger Enable
                                 .equ	ADSC	= 6	; ADC Start Conversion
                                 .equ	ADEN	= 7	; ADC Enable
                                 
                                 ; ADCSRB - The ADC Control and Status register B
                                 .equ	ADTS0	= 0	; ADC Auto Trigger Source bit 0
                                 .equ	ADTS1	= 1	; ADC Auto Trigger Source bit 1
                                 .equ	ADTS2	= 2	; ADC Auto Trigger Source bit 2
                                 .equ	MUX5	= 3	; Analog Channel and Gain Selection Bits
                                 ;.equ	ACME	= 6	; 
                                 
                                 ; ADCH - ADC Data Register High Byte
                                 .equ	ADCH0	= 0	; ADC Data Register High Byte Bit 0
                                 .equ	ADCH1	= 1	; ADC Data Register High Byte Bit 1
                                 .equ	ADCH2	= 2	; ADC Data Register High Byte Bit 2
                                 .equ	ADCH3	= 3	; ADC Data Register High Byte Bit 3
                                 .equ	ADCH4	= 4	; ADC Data Register High Byte Bit 4
                                 .equ	ADCH5	= 5	; ADC Data Register High Byte Bit 5
                                 .equ	ADCH6	= 6	; ADC Data Register High Byte Bit 6
                                 .equ	ADCH7	= 7	; ADC Data Register High Byte Bit 7
                                 
                                 ; ADCL - ADC Data Register Low Byte
                                 .equ	ADCL0	= 0	; ADC Data Register Low Byte Bit 0
                                 .equ	ADCL1	= 1	; ADC Data Register Low Byte Bit 1
                                 .equ	ADCL2	= 2	; ADC Data Register Low Byte Bit 2
                                 .equ	ADCL3	= 3	; ADC Data Register Low Byte Bit 3
                                 .equ	ADCL4	= 4	; ADC Data Register Low Byte Bit 4
                                 .equ	ADCL5	= 5	; ADC Data Register Low Byte Bit 5
                                 .equ	ADCL6	= 6	; ADC Data Register Low Byte Bit 6
                                 .equ	ADCL7	= 7	; ADC Data Register Low Byte Bit 7
                                 
                                 ; DIDR0 - Digital Input Disable Register
                                 .equ	ADC0D	= 0	; 
                                 .equ	ADC1D	= 1	; 
                                 .equ	ADC2D	= 2	; 
                                 .equ	ADC3D	= 3	; 
                                 .equ	ADC4D	= 4	; 
                                 .equ	ADC5D	= 5	; 
                                 .equ	ADC6D	= 6	; 
                                 .equ	ADC7D	= 7	; 
                                 
                                 ; DIDR2 - Digital Input Disable Register
                                 .equ	ADC8D	= 0	; 
                                 .equ	ADC9D	= 1	; 
                                 .equ	ADC10D	= 2	; 
                                 .equ	ADC11D	= 3	; 
                                 .equ	ADC12D	= 4	; 
                                 .equ	ADC13D	= 5	; 
                                 .equ	ADC14D	= 6	; 
                                 .equ	ADC15D	= 7	; 
                                 
                                 
                                 ; ***** BOOT_LOAD ********************
                                 ; SPMCSR - Store Program Memory Control Register
                                 .equ	SPMEN	= 0	; Store Program Memory Enable
                                 .equ	PGERS	= 1	; Page Erase
                                 .equ	PGWRT	= 2	; Page Write
                                 .equ	BLBSET	= 3	; Boot Lock Bit Set
                                 .equ	RWWSRE	= 4	; Read While Write section read enable
                                 .equ	SIGRD	= 5	; Signature Row Read
                                 .equ	RWWSB	= 6	; Read While Write Section Busy
                                 .equ	SPMIE	= 7	; SPM Interrupt Enable
                                 
                                 
                                 ; ***** USART2 ***********************
                                 ; UDR2 - USART I/O Data Register
                                 .equ	UDR2_0	= 0	; USART I/O Data Register bit 0
                                 .equ	UDR2_1	= 1	; USART I/O Data Register bit 1
                                 .equ	UDR2_2	= 2	; USART I/O Data Register bit 2
                                 .equ	UDR2_3	= 3	; USART I/O Data Register bit 3
                                 .equ	UDR2_4	= 4	; USART I/O Data Register bit 4
                                 .equ	UDR2_5	= 5	; USART I/O Data Register bit 5
                                 .equ	UDR2_6	= 6	; USART I/O Data Register bit 6
                                 .equ	UDR2_7	= 7	; USART I/O Data Register bit 7
                                 
                                 ; UCSR2A - USART Control and Status Register A
                                 .equ	MPCM2	= 0	; Multi-processor Communication Mode
                                 .equ	U2X2	= 1	; Double the USART transmission speed
                                 .equ	UPE2	= 2	; Parity Error
                                 .equ	DOR2	= 3	; Data overRun
                                 .equ	FE2	= 4	; Framing Error
                                 .equ	UDRE2	= 5	; USART Data Register Empty
                                 .equ	TXC2	= 6	; USART Transmitt Complete
                                 .equ	RXC2	= 7	; USART Receive Complete
                                 
                                 ; UCSR2B - USART Control and Status Register B
                                 .equ	TXB82	= 0	; Transmit Data Bit 8
                                 .equ	RXB82	= 1	; Receive Data Bit 8
                                 .equ	UCSZ22	= 2	; Character Size
                                 .equ	TXEN2	= 3	; Transmitter Enable
                                 .equ	RXEN2	= 4	; Receiver Enable
                                 .equ	UDRIE2	= 5	; USART Data register Empty Interrupt Enable
                                 .equ	TXCIE2	= 6	; TX Complete Interrupt Enable
                                 .equ	RXCIE2	= 7	; RX Complete Interrupt Enable
                                 
                                 ; UCSR2C - USART Control and Status Register C
                                 .equ	UCPOL2	= 0	; Clock Polarity
                                 .equ	UCSZ20	= 1	; Character Size
                                 .equ	UCSZ21	= 2	; Character Size
                                 .equ	USBS2	= 3	; Stop Bit Select
                                 .equ	UPM20	= 4	; Parity Mode Bit 0
                                 .equ	UPM21	= 5	; Parity Mode Bit 1
                                 .equ	UMSEL20	= 6	; USART Mode Select
                                 .equ	UMSEL21	= 7	; USART Mode Select
                                 
                                 ; UBRR2H - USART Baud Rate Register High Byte
                                 ;.equ	UBRR8	= 0	; USART Baud Rate Register bit 8
                                 ;.equ	UBRR9	= 1	; USART Baud Rate Register bit 9
                                 ;.equ	UBRR10	= 2	; USART Baud Rate Register bit 10
                                 ;.equ	UBRR11	= 3	; USART Baud Rate Register bit 11
                                 
                                 ; UBRR2L - USART Baud Rate Register Low Byte
                                 .equ	UBRR0	= 0	; USART Baud Rate Register bit 0
                                 .equ	UBRR1	= 1	; USART Baud Rate Register bit 1
                                 ;.equ	UBRR2	= 2	; USART Baud Rate Register bit 2
                                 ;.equ	UBRR3	= 3	; USART Baud Rate Register bit 3
                                 ;.equ	UBRR4	= 4	; USART Baud Rate Register bit 4
                                 ;.equ	UBRR5	= 5	; USART Baud Rate Register bit 5
                                 ;.equ	UBRR6	= 6	; USART Baud Rate Register bit 6
                                 ;.equ	UBRR7	= 7	; USART Baud Rate Register bit 7
                                 
                                 
                                 ; ***** USART3 ***********************
                                 ; UDR3 - USART I/O Data Register
                                 .equ	UDR3_0	= 0	; USART I/O Data Register bit 0
                                 .equ	UDR3_1	= 1	; USART I/O Data Register bit 1
                                 .equ	UDR3_2	= 2	; USART I/O Data Register bit 2
                                 .equ	UDR3_3	= 3	; USART I/O Data Register bit 3
                                 .equ	UDR3_4	= 4	; USART I/O Data Register bit 4
                                 .equ	UDR3_5	= 5	; USART I/O Data Register bit 5
                                 .equ	UDR3_6	= 6	; USART I/O Data Register bit 6
                                 .equ	UDR3_7	= 7	; USART I/O Data Register bit 7
                                 
                                 ; UCSR3A - USART Control and Status Register A
                                 .equ	MPCM3	= 0	; Multi-processor Communication Mode
                                 .equ	U2X3	= 1	; Double the USART transmission speed
                                 .equ	UPE3	= 2	; Parity Error
                                 .equ	DOR3	= 3	; Data overRun
                                 .equ	FE3	= 4	; Framing Error
                                 .equ	UDRE3	= 5	; USART Data Register Empty
                                 .equ	TXC3	= 6	; USART Transmitt Complete
                                 .equ	RXC3	= 7	; USART Receive Complete
                                 
                                 ; UCSR3B - USART Control and Status Register B
                                 .equ	TXB83	= 0	; Transmit Data Bit 8
                                 .equ	RXB83	= 1	; Receive Data Bit 8
                                 .equ	UCSZ32	= 2	; Character Size
                                 .equ	TXEN3	= 3	; Transmitter Enable
                                 .equ	RXEN3	= 4	; Receiver Enable
                                 .equ	UDRIE3	= 5	; USART Data register Empty Interrupt Enable
                                 .equ	TXCIE3	= 6	; TX Complete Interrupt Enable
                                 .equ	RXCIE3	= 7	; RX Complete Interrupt Enable
                                 
                                 ; UCSR3C - USART Control and Status Register C
                                 .equ	UCPOL3	= 0	; Clock Polarity
                                 .equ	UCSZ30	= 1	; Character Size
                                 .equ	UCSZ31	= 2	; Character Size
                                 .equ	USBS3	= 3	; Stop Bit Select
                                 .equ	UPM30	= 4	; Parity Mode Bit 0
                                 .equ	UPM31	= 5	; Parity Mode Bit 1
                                 .equ	UMSEL30	= 6	; USART Mode Select
                                 .equ	UMSEL31	= 7	; USART Mode Select
                                 
                                 ; UBRR3H - USART Baud Rate Register High Byte
                                 ;.equ	UBRR8	= 0	; USART Baud Rate Register bit 8
                                 ;.equ	UBRR9	= 1	; USART Baud Rate Register bit 9
                                 ;.equ	UBRR10	= 2	; USART Baud Rate Register bit 10
                                 ;.equ	UBRR11	= 3	; USART Baud Rate Register bit 11
                                 
                                 ; UBRR3L - USART Baud Rate Register Low Byte
                                 ;.equ	UBRR0	= 0	; USART Baud Rate Register bit 0
                                 ;.equ	UBRR1	= 1	; USART Baud Rate Register bit 1
                                 ;.equ	UBRR2	= 2	; USART Baud Rate Register bit 2
                                 ;.equ	UBRR3	= 3	; USART Baud Rate Register bit 3
                                 ;.equ	UBRR4	= 4	; USART Baud Rate Register bit 4
                                 ;.equ	UBRR5	= 5	; USART Baud Rate Register bit 5
                                 ;.equ	UBRR6	= 6	; USART Baud Rate Register bit 6
                                 ;.equ	UBRR7	= 7	; USART Baud Rate Register bit 7
                                 
                                 
                                 
                                 ; ***** LOCKSBITS ********************************************************
                                 .equ	LB1	= 0	; Lock bit
                                 .equ	LB2	= 1	; Lock bit
                                 .equ	BLB01	= 2	; Boot Lock bit
                                 .equ	BLB02	= 3	; Boot Lock bit
                                 .equ	BLB11	= 4	; Boot lock bit
                                 .equ	BLB12	= 5	; Boot lock bit
                                 
                                 
                                 ; ***** FUSES ************************************************************
                                 ; LOW fuse bits
                                 .equ	CKSEL0	= 0	; Select Clock Source
                                 .equ	CKSEL1	= 1	; Select Clock Source
                                 .equ	CKSEL2	= 2	; Select Clock Source
                                 .equ	CKSEL3	= 3	; Select Clock Source
                                 .equ	SUT0	= 4	; Select start-up time
                                 .equ	SUT1	= 5	; Select start-up time
                                 .equ	CKOUT	= 6	; Clock output
                                 .equ	CKDIV8	= 7	; Divide clock by 8
                                 
                                 ; HIGH fuse bits
                                 .equ	BOOTRST	= 0	; Select Reset Vector
                                 .equ	BOOTSZ0	= 1	; Select Boot Size
                                 .equ	BOOTSZ1	= 2	; Select Boot Size
                                 .equ	EESAVE	= 3	; EEPROM memory is preserved through chip erase
                                 .equ	WDTON	= 4	; Watchdog timer always on
                                 .equ	SPIEN	= 5	; Enable Serial programming and Data Downloading
                                 .equ	JTAGEN	= 6	; Enable JTAG
                                 .equ	OCDEN	= 7	; Enable OCD
                                 
                                 ; EXTENDED fuse bits
                                 .equ	BODLEVEL0	= 0	; Brown-out Detector trigger level
                                 .equ	BODLEVEL1	= 1	; Brown-out Detector trigger level
                                 .equ	BODLEVEL2	= 2	; Brown-out Detector trigger level
                                 
                                 
                                 
                                 ; ***** CPU REGISTER DEFINITIONS *****************************************
                                 .def	XH	= r27
                                 .def	XL	= r26
                                 .def	YH	= r29
                                 .def	YL	= r28
                                 .def	ZH	= r31
                                 .def	ZL	= r30
                                 
                                 
                                 
                                 ; ***** DATA MEMORY DECLARATIONS *****************************************
                                 .equ	FLASHEND	= 0x1ffff	; Note: Word address
                                 .equ	IOEND	= 0x01ff
                                 .equ	SRAM_START	= 0x0200
                                 .equ	SRAM_SIZE	= 8192
                                 .equ	RAMEND	= 0x21ff
                                 .equ	XRAMEND	= 0xffff
                                 .equ	E2END	= 0x0fff
                                 .equ	EEPROMEND	= 0x0fff
                                 .equ	EEADRBITS	= 12
                                 #pragma AVRPART MEMORY PROG_FLASH 262144
                                 #pragma AVRPART MEMORY EEPROM 4096
                                 #pragma AVRPART MEMORY INT_SRAM SIZE 8192
                                 #pragma AVRPART MEMORY INT_SRAM START_ADDR 0x200
                                 
                                 
                                 
                                 ; ***** BOOTLOADER DECLARATIONS ******************************************
                                 .equ	NRWW_START_ADDR	= 0x1f000
                                 .equ	NRWW_STOP_ADDR	= 0x1ffff
                                 .equ	RWW_START_ADDR	= 0x0
                                 .equ	RWW_STOP_ADDR	= 0x1efff
                                 .equ	PAGESIZE	= 128
                                 .equ	FIRSTBOOTSTART	= 0x1fe00
                                 .equ	SECONDBOOTSTART	= 0x1fc00
                                 .equ	THIRDBOOTSTART	= 0x1f800
                                 .equ	FOURTHBOOTSTART	= 0x1f000
                                 .equ	SMALLBOOTSTART	= FIRSTBOOTSTART
                                 .equ	LARGEBOOTSTART	= FOURTHBOOTSTART
                                 
                                 
                                 
                                 ; ***** INTERRUPT VECTORS ************************************************
                                 .equ	INT0addr	= 0x0002	; External Interrupt Request 0
                                 .equ	INT1addr	= 0x0004	; External Interrupt Request 1
                                 .equ	INT2addr	= 0x0006	; External Interrupt Request 2
                                 .equ	INT3addr	= 0x0008	; External Interrupt Request 3
                                 .equ	INT4addr	= 0x000a	; External Interrupt Request 4
                                 .equ	INT5addr	= 0x000c	; External Interrupt Request 5
                                 .equ	INT6addr	= 0x000e	; External Interrupt Request 6
                                 .equ	INT7addr	= 0x0010	; External Interrupt Request 7
                                 .equ	PCI0addr	= 0x0012	; Pin Change Interrupt Request 0
                                 .equ	PCI1addr	= 0x0014	; Pin Change Interrupt Request 1
                                 .equ	PCI2addr	= 0x0016	; Pin Change Interrupt Request 2
                                 .equ	WDTaddr	= 0x0018	; Watchdog Time-out Interrupt
                                 .equ	OC2Aaddr	= 0x001a	; Timer/Counter2 Compare Match A
                                 .equ	OC2Baddr	= 0x001c	; Timer/Counter2 Compare Match B
                                 .equ	OVF2addr	= 0x001e	; Timer/Counter2 Overflow
                                 .equ	ICP1addr	= 0x0020	; Timer/Counter1 Capture Event
                                 .equ	OC1Aaddr	= 0x0022	; Timer/Counter1 Compare Match A
                                 .equ	OC1Baddr	= 0x0024	; Timer/Counter1 Compare Match B
                                 .equ	OC1Caddr	= 0x0026	; Timer/Counter1 Compare Match C
                                 .equ	OVF1addr	= 0x0028	; Timer/Counter1 Overflow
                                 .equ	OC0Aaddr	= 0x002a	; Timer/Counter0 Compare Match A
                                 .equ	OC0Baddr	= 0x002c	; Timer/Counter0 Compare Match B
                                 .equ	OVF0addr	= 0x002e	; Timer/Counter0 Overflow
                                 .equ	SPIaddr	= 0x0030	; SPI Serial Transfer Complete
                                 .equ	URXC0addr	= 0x0032	; USART0, Rx Complete
                                 .equ	UDRE0addr	= 0x0034	; USART0 Data register Empty
                                 .equ	UTXC0addr	= 0x0036	; USART0, Tx Complete
                                 .equ	ACIaddr	= 0x0038	; Analog Comparator
                                 .equ	ADCCaddr	= 0x003a	; ADC Conversion Complete
                                 .equ	ERDYaddr	= 0x003c	; EEPROM Ready
                                 .equ	ICP3addr	= 0x003e	; Timer/Counter3 Capture Event
                                 .equ	OC3Aaddr	= 0x0040	; Timer/Counter3 Compare Match A
                                 .equ	OC3Baddr	= 0x0042	; Timer/Counter3 Compare Match B
                                 .equ	OC3Caddr	= 0x0044	; Timer/Counter3 Compare Match C
                                 .equ	OVF3addr	= 0x0046	; Timer/Counter3 Overflow
                                 .equ	URXC1addr	= 0x0048	; USART1, Rx Complete
                                 .equ	UDRE1addr	= 0x004a	; USART1 Data register Empty
                                 .equ	UTXC1addr	= 0x004c	; USART1, Tx Complete
                                 .equ	TWIaddr	= 0x004e	; 2-wire Serial Interface
                                 .equ	SPMRaddr	= 0x0050	; Store Program Memory Read
                                 .equ	ICP4addr	= 0x0052	; Timer/Counter4 Capture Event
                                 .equ	OC4Aaddr	= 0x0054	; Timer/Counter4 Compare Match A
                                 .equ	OC4Baddr	= 0x0056	; Timer/Counter4 Compare Match B
                                 .equ	OC4Caddr	= 0x0058	; Timer/Counter4 Compare Match C
                                 .equ	OVF4addr	= 0x005a	; Timer/Counter4 Overflow
                                 .equ	ICP5addr	= 0x005c	; Timer/Counter5 Capture Event
                                 .equ	OC5Aaddr	= 0x005e	; Timer/Counter5 Compare Match A
                                 .equ	OC5Baddr	= 0x0060	; Timer/Counter5 Compare Match B
                                 .equ	OC5Caddr	= 0x0062	; Timer/Counter5 Compare Match C
                                 .equ	OVF5addr	= 0x0064	; Timer/Counter5 Overflow
                                 .equ	URXC2addr	= 0x0066	; USART2, Rx Complete
                                 .equ	UDRE2addr	= 0x0068	; USART2 Data register Empty
                                 .equ	UTXC2addr	= 0x006a	; USART2, Tx Complete
                                 .equ	URXC3addr	= 0x006c	; USART3, Rx Complete
                                 .equ	UDRE3addr	= 0x006e	; USART3 Data register Empty
                                 .equ	UTXC3addr	= 0x0070	; USART3, Tx Complete
                                 
                                 .equ	INT_VECTORS_SIZE	= 114	; size in words
                                 
                                 #endif  /* _M2560DEF_INC_ */
                                 
                                 ; ***** END OF FILE ******************************************************
                                 
                                 
                                 ;***** Created: 2011-02-09 12:03 ******* Source: ATmega2560.xml **********
                                 ;*************************************************************************
                                 ;* A P P L I C A T I O N   N O T E   F O R   T H E   A V R   F A M I L Y
                                 ;* 
                                 ;* Number            : AVR000
                                 ;* File Name         : "m2560def.inc"
                                 ;* Title             : Register/Bit Definitions for the ATmega2560
                                 ;* Date              : 2011-02-09
                                 ;* Version           : 2.35
                                 ;* Support E-mail    : avr@atmel.com
                                 ;* Target MCU        : ATmega2560
                                 ;* 
                                 ;* DESCRIPTION
                                 ;* When including this file in the assembly program file, all I/O register 
                                 ;* names and I/O register bit names appearing in the data book can be used.
                                 ;* In addition, the six registers forming the three data pointers X, Y and 
                                 ;* Z have been assigned names XL - ZH. Highest RAM address for Internal 
                                 ;* SRAM is also defined 
                                 ;* 
                                 ;* The Register names are represented by their hexadecimal address.
                                 ;* 
                                 ;* The Register Bit names are represented by their bit number (0-7).
                                 ;* 
                                 ;* Please observe the difference in using the bit names with instructions
                                 ;* such as "sbr"/"cbr" (set/clear bit in register) and "sbrs"/"sbrc"
                                 ;* (skip if bit in register set/cleared). The following example illustrates
                                 ;* this:
                                 ;* 
                                 ;* in    r16,PORTB             ;read PORTB latch
                                 ;* sbr   r16,(1<<PB6)+(1<<PB5) ;set PB6 and PB5 (use masks, not bit#)
                                 ;* out   PORTB,r16             ;output to PORTB
                                 ;* 
                                 ;* in    r16,TIFR              ;read the Timer Interrupt Flag Register
                                 ;* sbrc  r16,TOV0              ;test the overflow flag (use bit#)
                                 ;* rjmp  TOV0_is_set           ;jump if set
                                 ;* ...                         ;otherwise do something else
                                 ;*************************************************************************
                                 
                                 #ifndef _M2560DEF_INC_
                                 #endif  /* _M2560DEF_INC_ */
                                 
                                 ; ***** END OF FILE ******************************************************
                                 
                                 ;//=== Keypad Defs ===\\
                                 	.def temp =r16
                                 	.def row =r17
                                 	.def col =r18
                                 	.def mask =r19
                                 	.def temp2 =r20
                                 	.equ PORTLDIR = 0xF0
                                 	.equ INITCOLMASK = 0xEF
                                 	.equ INITROWMASK = 0x01
                                 	.equ ROWMASK = 0x0F
                                 
                                 ;//===  Personal use Defs and Equs ===\\
                                 	;Desperate times call for desperate measures
                                 	.def TravelTime = r8
                                 	.def currStation = r7
                                 	.def stopTime = r6
                                 
                                 	.def temp3 = r21
                                 	.def temp4 = r22
                                 	.def temp5 = r23
                                 
                                 	.def stationNum = r24
                                 	.equ motorSpeed = 0
                                 
                                 	.equ AsciiNum = 0b00110000
                                 	.equ AsciiLetter = 0b01000000
                                 	.equ AsciiHash = 0b00100011
                                 	.equ AsciiStar = 0b00101010
                                 
                                 	.equ LAST_COLUMN = 3
                                 	.equ UNSET_POSITION = 4
                                 	.equ MAX_CHARACTERS = 10
                                 
                                 	.equ hashcol = 0b10111111
                                 	.equ hashrow = 0b1000
                                 
                                 ;//=== Delay Defs and Equs ===\\
                                 	.equ F_CPU = 16000000
                                 	.equ DELAY_COUNTER = F_CPU / 4 / 100 - 4
                                 
                                 ;//=== Macro for LCD display ===\\
                                 	.macro clear;load in and clear 2 bytes of data
                                 		ldi YL, low(@0)
                                 		ldi YH, high(@0)
                                 		clr temp
                                 		st Y+, temp
                                 		st Y, temp
                                 	.endmacro
                                 
                                 	.macro do_lcd_command ;port in a command
                                 		ldi temp, @0
                                 		rcall lcd_command
                                 		rcall lcd_wait
                                 	.endmacro
                                 
                                 	.macro mov_lcd_command ;reg friendly ver.
                                 		mov temp, @0
                                 		rcall lcd_command
                                 		rcall lcd_wait
                                 	.endmacro
                                 
                                 	.macro do_lcd_data ;write out data
                                 		ldi temp, @0
                                 		rcall lcd_data
                                 		rcall lcd_wait
                                 	.endmacro
                                 
                                 	.macro mov_lcd_data ;reg friendly ver.
                                 		mov temp, @0
                                 		rcall lcd_data
                                 		rcall lcd_wait
                                 	.endmacro
                                 
                                 	.macro ascii_print
                                 		ldi temp, 48
                                 		mov temp2, @0
                                 		add temp2, temp
                                 		mov_lcd_data temp2
                                 	.endmacro
                                 
                                 .dseg
000200                           array: .byte 100 ;10x10 array for storing names
000264                           times: .byte 11 ;11x1 array for storing station to station times
                                 
                                 .cseg
                                 .org 0x0
000000 940c 000b                 jmp RESET
                                 
                                 .org INT0addr
000002 940c 0006                 jmp Button_pushed
                                 .org INT1addr
000004 940c 0006                 jmp Button_pushed
                                 
                                 ;External interrupt for either button being pushed
                                 ;Sets r5 to 0xFF
                                 Button_pushed:
000006 930f                      	push temp
000007 ef0f                      	ldi temp, 0xff
000008 2e50                      	mov r5, temp
000009 910f                      	pop temp
00000a 9518                      reti
                                 
                                 RESET:
                                 	;//Array Frame
00000b e0e0                      		ldi zl, low(array)
00000c e0f2                      		ldi zh, high(array)
00000d e6c4                      		ldi yl, low(times)
00000e e0d2                      		ldi yh, high(times)
                                 	;//Stack frame
00000f e90b                      		ldi temp, low(RAMEND-100)
000010 bf0d                      		out SPL, temp
000011 e201                      		ldi temp, high(RAMEND-100)
000012 bf0e                      		out SPH, temp
                                 
                                 	;//Keypad Set Up
000013 ef00                      		ldi temp, PORTLDIR ; columns are outputs, rows are inputs
000014 9300 010a                 		STS DDRL, temp     ; cannot use out
                                 
                                 	;//LCD Set Up
                                 		;//LCD pin Set Up
000016 ef0f                      			ser temp
000017 bb00                      			out DDRF, temp ;lcd pins as out
000018 b901                      			out DDRA, temp ;lcd control pins as out
000019 2700                      			clr temp
00001a bb01                      			out PORTF, temp ;lcd display as clear
00001b b902                      			out PORTA, temp ;lcd control as not writing or enabled
                                 
00001c e308
00001d d521
00001e d53a                      		do_lcd_command 0b00111000 ; 2x5x7
00001f e308
000020 d51e
000021 d537                      		do_lcd_command 0b00111000 ; 2x5x7
000022 e308
000023 d51b
000024 d534                      		do_lcd_command 0b00111000 ; 2x5x7
000025 e308
000026 d518
000027 d531                      		do_lcd_command 0b00111000 ; 2x5x7
000028 e308
000029 d515
00002a d52e                      		do_lcd_command 0b00111000 ; 2x5x7
00002b e008
00002c d512
00002d d52b                      		do_lcd_command 0b00001000 ; display off?
00002e e001
00002f d50f
000030 d528                      		do_lcd_command 0b00000001 ; clear display
000031 e006
000032 d50c
000033 d525                      		do_lcd_command 0b00000110 ; increment, no display shift
000034 e00e
000035 d509
000036 d522                      		do_lcd_command 0b00001110 ; Cursor on, bar, no blink
                                 
                                 	;//LED Set Up
000037 ef0f                      		ser temp
000038 b907                      		out DDRC, temp ;set LEDS to output
000039 2700                      		clr temp
00003a b908                      		out PORTC, temp ;set LEDS to 0
                                 	;//External Interrupt Set Up
                                 		;Currently just the buttons
00003b 2700                      		clr temp
00003c b90a                      		out DDRD, temp ;set interrupt port to input
00003d b90b                      		out PORTD, temp ;set interrupt port to 0
00003e e00a                      		ldi temp, (2 << ISC10 | 2 << ISC00) ;set falling edge interrupt for buttons
00003f 9300 0069                 		sts EICRA, temp ;Load in falling edge for ext. interrupt
000041 b30d                      		in temp, EIMSK ;load in current active ext. interrupts
000042 6003                      		ori temp, (1<<INT0) | (1<<INT1)  ;note int0 = 0, int1 = 1
000043 bb0d                      		out EIMSK, temp  ;enable ext. interrupts 0 and 1
000044 94f8                      		cli ;disable global interrupt
                                 	
                                 	;PWM and Motor Set Up
000045 ef0f                      		ser temp
000046 b90d                      		out DDRE, temp ;set motor power as output
000047 9300 0101                 		STS DDRH, temp
000049 e000                      		ldi temp,0 ;this value and the operation mode determines the PWM duty cycle
00004a 9300 00ac                 		sts OCR4CL, temp ;Load pulse width/speed into OC4C low register
00004c 2700                      		clr temp
00004d 9300 00ad                 		sts OCR4CH, temp ;Load pulse width/speed into 0C4C high register
00004f e001                      		ldi temp, (1<<CS30) ; CS30 = 1: no prescaling
000050 9300 00a1                 		sts TCCR4B, temp; set the prescaling value
000052 e009                      		ldi temp, (1<<WGM30)|(1<<COM4C1)
                                 		; WGM30=1: phase correct PWM, 8 bits
                                 		;COM4C1=1: make OC4C override the normal port functionality of the I/O pin PE2
000053 9300 00a0                 		sts TCCR4A, temp
000055 9478                      		sei
                                 	;//Other
                                 		;Station 1 Name
000056 e503                      			ldi temp, 'S'
000057 9301                      			st z+, temp
000058 e504                      			ldi temp, 'T'
000059 9301                      			st z+, temp
00005a e401                      			ldi temp, 'A'
00005b 9301                      			st z+, temp
00005c e504                      			ldi temp, 'T'
00005d 9301                      			st z+, temp
00005e e409                      			ldi temp, 'I'
00005f 9301                      			st z+, temp
000060 e40f                      			ldi temp, 'O'
000061 9301                      			st z+, temp
000062 e40e                      			ldi temp, 'N'
000063 9301                      			st z+, temp
000064 e200                      			ldi temp, ' '
000065 9301                      			st z+, temp
000066 e301                      			ldi temp, '1'
000067 9301                      			st z+, temp
000068 e201                      			ldi temp, '!'
000069 9301                      			st z+, temp
                                 		;Station 2 Name
00006a e503                      			ldi temp, 'S'
00006b 9301                      			st z+, temp
00006c e504                      			ldi temp, 'T'
00006d 9301                      			st z+, temp
00006e e401                      			ldi temp, 'A'
00006f 9301                      			st z+, temp
000070 e504                      			ldi temp, 'T'
000071 9301                      			st z+, temp
000072 e409                      			ldi temp, 'I'
000073 9301                      			st z+, temp
000074 e40f                      			ldi temp, 'O'
000075 9301                      			st z+, temp
000076 e40e                      			ldi temp, 'N'
000077 9301                      			st z+, temp
000078 e200                      			ldi temp, ' '
000079 9301                      			st z+, temp
00007a e302                      			ldi temp, '2'
00007b 9301                      			st z+, temp
00007c e201                      			ldi temp, '!'
00007d 9301                      			st z+, temp
                                 		;Time Array
00007e e005                      			ldi temp, 5 ;last to s1
00007f 9309                      			st y+, temp
000080 e003                      			ldi temp, 3 ;s1 to s2
000081 9309                      			st y+, temp
                                 	
000082 e0e0                      	ldi zl, low(array)
000083 e0f2                      	ldi zh, high(array)
000084 e6c4                      	ldi yl, low(times)
000085 e0d2                      	ldi yh, high(times)
000086 2700                      	clr temp
000087 e082                      	ldi stationNum, 2
000088 e002                      	ldi temp, 2
000089 2e60                      	mov stopTime, temp
00008a 940c 008c                 	jmp main
                                 
                                 main:
00008c 940e 01ba                 	call maxStations
00008e 940e 014e                 	call readInStations
000090 940e 02ae                 	call timeBetweenStations
000092 940e 032a                 	call stopTimeRequest
000094 940e 023b                 	call nextSection
                                 	loop:
000096 940e 047a                 	call readPrint ;internal eternal loop
000098 940c 0096                 	jmp loop
                                 
                                 ;//=== Keypad Start ===\\
                                 	;Keypadcheck | A subroutine that will loop until a key is pressed
                                 	;Changes the values of row and col to represent the key pressed
                                 	Keypad:
00009a ee3f                      			ldi mask, INITCOLMASK ;set mask to 0 only column 1/bit5
00009b 2722                      			clr col ; clear column counter
                                 
                                 		colloop:
00009c 9330 010b                 			STS PORTL, mask ; set column to mask value
                                 
00009e ef0f                      			ldi temp, 0xFF ; implement a delay so the
                                 		delay: ; hardware can stabilize
00009f 950a                      			dec temp
0000a0 f7f1                      			brne delay
0000a1 9100 0109                 			LDS temp, PINL ;Intake the keypad reg values 
0000a3 700f                      			andi temp, ROWMASK ; read only the row bits
0000a4 300f                      			cpi temp, 0xF ; check if any rows are grounded
0000a5 f051                      			breq nextcol ; if not go to the next column
0000a6 e031                      			ldi mask, INITROWMASK ; initialise row check
0000a7 2711                      			clr row ; initial row
                                 
                                 		rowloop:      
0000a8 2f40                      			mov temp2, temp
0000a9 2343                      			and temp2, mask ; check masked bit
0000aa f409                      			brne skipconv ; if the result is non-zero, we need to look again
0000ab 9508                      			ret ; if bit is clear, convert the bitcode and start again
                                 
                                 		skipconv:
0000ac 9513                      			inc row ; else move to the next row
0000ad 0f33                      			lsl mask ; shift the mask to the next bit
0000ae 940c 00a8                 			jmp rowloop
                                 
                                 		nextcol:     
0000b0 3023                      			cpi col, 3 ; check if we're on the last column
0000b1 f341                      			breq Keypad ; if so, no buttons were pushed, so start again.
                                 
0000b2 9408                      			sec ; else shift the column mask, we must set the carry bit
0000b3 1f33                      			rol mask ; and then rotate left by a bit, shifting the carry into bit zero. We need this to make sure all the rows have pull-up resistors
0000b4 9523                      			inc col ; increment column value
0000b5 940c 009c                 			jmp colloop ; and check the next column
                                 ;//=== Keypad End ===\\
                                 
                                 ;//=== Convertion Numbers Start ===\\
                                 	;Intakes rows and columns to give a row number
                                 	;Star is taken as end of squence
                                 	;temp is then 0 = no err, 1 = no num, 2 = big num err (>10)
                                 	;store value of key into temp3
                                 	convertNumbers:
0000b7 3023                      			cpi col, 3 ; if column is 3 we have a letter
0000b8 f0a9                      			breq notNumberReturn ;but no letters so keypad check
0000b9 3013                      			cpi row, 3 ; if row is 3 we have a symbol or 0
0000ba f0a9                      			breq symbols
0000bb 2f01                      			mov temp, row ; otherwise we have a number (1-9)
0000bc 0f00                      			lsl temp ; temp = row * 2
0000bd 0f01                      			add temp, row ; temp = row * 3
0000be 0f02                      			add temp, col ; add the column address
                                 			; to get the offset from 1
0000bf 9503                      			inc temp ; add 1. Value of switch is
                                 			; row*3 + col + 1.
                                 
0000c0 3050                      			cpi temp3, 0 ;if the current number is zero clr r9
0000c1 f409                      			brne convertNumbers_cont 
0000c2 2499                      			clr r9
                                 
                                 			convertNumbers_cont:
0000c3 e032                      			ldi mask, 2
0000c4 1693                      			cp r9, mask ;Stop Calculating after the second number
0000c5 f041                      			breq notNumberReturn
                                 			
0000c6 e04a                      			ldi temp2, 10 ;multiply temp3 by 10
0000c7 9f54                      			mul temp3, temp2
0000c8 2d50                      			mov temp3, r0
0000c9 0f50                      			add temp3, temp ;then add the curr num value
                                 
0000ca e340                      			ldi temp2, AsciiNum
0000cb 0f04                      			add temp, temp2
0000cc 940c 00ea                 			jmp convertNumbers_end
                                 
                                 		notNumberReturn:
0000ce e001                      			ldi temp, 1
0000cf 9508                      			ret ;return with value 1 in temp to show not a valid key
                                 
                                 		symbols:
0000d0 3020                      			cpi col, 0 ; check if we have a star
0000d1 f021                      			breq star
0000d2 3021                      			cpi col, 1 ; or if we have zero
0000d3 f069                      			breq zero
0000d4 e001                      			ldi temp, 1
0000d5 9508                      			ret ;return with value 1 in temp to show not a valid key
                                 
                                 		star: ;either store temp3 or clear it and err message
0000d6 305b                      			cpi temp3, 11 ;same or higher than 11 is err
0000d7 f4d0                      			brsh convertNumbers_error
0000d8 3050                      			cpi temp3, 0 ;is zero is also an err
0000d9 f0c1                      			breq convertNumbers_error
0000da 9563                      			inc temp4
0000db d495                      			rcall delay_30ms
0000dc e001
0000dd d461
0000de d47a                      			do_lcd_command 0b1
0000df 2700                      			clr temp
0000e0 9508                      			ret ;return with value 1 in temp to show that entry has not concluded
                                 
                                 		zero:
0000e1 3050                      			cpi temp3, 0 ;If current value is zero and input is zero
0000e2 f359                      			breq notNumberReturn ;Don't bother doing anything
0000e3 e032                      			ldi mask, 2
0000e4 1693                      			cp r9, mask
0000e5 f341                      			breq notNumberReturn
0000e6 e04a                      			ldi temp2, 10
0000e7 9f54                      			mul temp3, temp2
0000e8 2d50                      			mov temp3, r0
0000e9 e300                      			ldi temp, AsciiNum ; set to zero
                                 
                                 		convertNumbers_end:
0000ea 9493                      			inc r9 ;number of numbers entered counter
0000eb 2f00
0000ec d45d
0000ed d46b                      			mov_lcd_data temp ; write value to LCD
0000ee 940e 0571                 			call delay_30ms
0000f0 e001                      			ldi temp, 1
0000f1 9508                      			ret ;return with value 1 in temp to show that entry has not concluded
                                 
                                 		convertNumbers_error:
0000f2 e002                      			ldi temp, 2
0000f3 9508                      			ret ;return with value 2 in temp to show that the number was greater than 10
                                 
                                 ;//=== Convertion Numbers End ===\\
                                 
                                 ;//=== Convertion Characters Start ===\\
                                 	; Using row and col, determine which key was pressed
                                 	;    @0 is the register location to store result
                                 	.macro determine_key_press
                                 		; Key number value (1-9) is (row * 3) + col + 1
                                 		mov @0, row
                                 		lsl @0
                                 		add @0, row 
                                 		add @0, col 
                                 		inc @0
                                 	.endmacro
                                 
                                 
                                 	store_position_selection_relay:
0000f4 940c 0138                 		jmp store_position_selection
                                 	; Translates and stores (in SRAM) valid keypad presses into capital letters.
                                 	;    Achieves this by first reading a 'character position' specified by column 3 key selection
                                 	;       i.e. 'A' represents character position 0, 'B' as position 1, ... and 'C' as position 4 (if applicable)
                                 	;    Followed by selecting the desired keypad 'character block'
                                 	;       Example: character position 'A' (position 0) for keypad character block '2' returns capital letter 'A'
                                 	character_convert:
                                 
                                 		; Keys in the column 3 determine character position for the keypad character block which in turn 
                                 		;    determines the character selection
0000f6 3023                      		cpi col, LAST_COLUMN
0000f7 f3e1                      		breq store_position_selection_relay
                                 
                                 		; Check for zero or hash key presses
                                 		;     D key should be caught by the above case before this one
                                 		;         Only valid ones here are [*,0,#]
0000f8 3013                      		cpi row, 3 
0000f9 f0f9                      		breq zero_or_hash
                                 
                                 		; Check whether or not a position has been saved into position selection register
                                 		;    Return to caller if position has not been stored i.e. go back to listening for keypad press
0000fa 3054                      		cpi temp3, UNSET_POSITION
0000fb f169                      		breq characterConvert_end
                                 
                                 		; Character conversion entry point
                                 		;    Use character position selection and keypad character block selection to determine capital letter
0000fc 2f01
0000fd 0f00
0000fe 0f01
0000ff 0f02
000100 9503                      		determine_key_press temp
                                 
                                 		; Case where character block 1 is pressed
                                 		;    No letters are present in this block therefore do nothing
000101 3001                      		cpi temp, 1
000102 f131                      		breq characterConvert_end
                                 		
                                 		; Character conversion core algo
                                 		;    (key_distance_from_2 * 3) + 'A' + position_selection where, key_distance_from_2 = key press - 2,
                                 		;        'A' is decimal value 65 and position_selection is character position selection
000103 5002                      		subi temp, 2 ; calculate key_distance_from_2
000104 2f40                      		mov temp2, temp ; store result to temp2
                                 
                                 		; Multiply key_distance_from_2 by 3 which gives the character distance from '65'
                                 		;    (key_distance_from_2 * 2) + key_distance_from_2 = (key_distance_from_2 * 3) = Character distance from '65'
000105 0f00                      		lsl temp
000106 0f04                      		add temp, temp2
                                 
                                 		; Add calculated character distance from 'A' (the origin/ start)
000107 e441                      		ldi temp2, 'A'
000108 0f04                      		add temp, temp2
                                 
000109 2f41
00010a 0f44
00010b 0f41
00010c 0f42
00010d 9543                      		determine_key_press temp2 ; temp overwritten, we can determine the original key press as we still have row, col values saved 
                                 
                                 		; Position selection addition
                                 		;   Case where postion selection is 3
                                 		;      Need to catch this case for character blocks 7 and 9 as they have 4 character selections to choose from
                                 		;         i.e. Block 7 = [P,Q,R,S] and Block 9 = [W,X,Y,Z]
                                 
00010e 3048                      		cpi temp2, 8
00010f f008                      		brlo normalPositionAddition
000110 9503                      		inc temp		
                                 
                                 		normalPositionAddition:
000111 3053                      		cpi temp3, LAST_COLUMN
000112 f139                      		breq last_position_selection
                                 		
                                 		; Position selection anything but last column
000113 0f05                      		add temp, temp3
000114 2744                      		clr temp2 
                                 
000115 307a                      		cpi temp5, MAX_CHARACTERS
000116 f569                      		brne not_max_chars ; do nothing if we've reached max characters, just waiting for end of input
                                 
000117 940c 0129                 		jmp characterConvert_end
                                 
                                 		; *** Character convert helpers ***
                                 		zero_or_hash:
000119 3021                      			cpi col, 1 ; zero represents white space character
00011a f021                      			breq white_space
                                 
00011b 3020                      			cpi col, 0 ; hash represents end of input
00011c f079                      			breq end_of_input
                                 
                                 			; otherwise do nothing
00011d 940c 0129                 			jmp characterConvert_end
                                 
                                 		white_space:
00011f e000                      			ldi temp, 0
000120 16f0                      			cp r15, temp ;only decrement if there is already characters in there
000121 f411                      			brne normal_space
                                 
000122 94fa                      			dec r15 ;Decrease if space
000123 b8f8                      			out PORTC, r15
                                 
                                 			normal_space:
000124 e200                      			ldi temp, ' '
                                 			; do nothing if we've reached max characters, just waiting for end of input
000125 307a                      			cpi temp5, MAX_CHARACTERS
000126 f4e9                      			brne not_max_chars
                                 
000127 940c 0129                 			jmp characterConvert_end
                                 		
                                 		characterConvert_end:
                                 			; reset the position_selection
000129 e054                      			ldi temp3, 4
00012a d44d                      			rcall delay_10ms
00012b 9508                      			ret ; return to caller
                                 		
                                 		end_of_input:
                                 			; Calculate how many memory addresses we need to pad by
00012c e00a                      			ldi temp, MAX_CHARACTERS
00012d 2f47                      			mov temp2, temp5
00012e 1b04                      			sub temp, temp2 ; MAX_CHARACTERS - character_count = Padding
00012f e240                      			ldi temp2, ' ' ; Character to write to memory
                                 
000130 3000                      			cpi temp, 0 ; No padding required
000131 f019                      			breq end_of_input_exit
                                 
                                 			memory_padding:
000132 9341                      				st z+, temp2
000133 950a                      				dec temp ; Pad this amount of times
000134 f7e9                      				brne memory_padding
                                 
                                 			end_of_input_exit:
000135 e27a                      				ldi temp5, '*'
000136 940c 0129                 				jmp characterConvert_end
                                 		
                                 		; *** Position selection helpers ***
                                 		store_position_selection:
                                 			; Row is the character position to be used on next key press
000138 2f51                      			mov temp3, row 
000139 9508                      			ret 
                                 
                                 		; *** Character conversion core helpers ***
                                 		last_position_selection:
                                 			; Catches the case where blocks 1-6 and last position asked for 
00013a 3047                      			cpi temp2, 7
                                 			; Go back to listening for a key press
00013b f368                      			brlo characterConvert_end
                                 
00013c 3048                      			cpi temp2, 8 ; Catches the case for block 8
00013d f359                      			breq characterConvert_end
                                 
                                 			; Anything here has a valid last position selection
00013e 0f05                      			add temp, temp3
00013f 2744                      			clr temp2
                                 
                                 			; do nothing if we've reached max characters, just waiting for end of input
000140 307a                      			cpi temp5, MAX_CHARACTERS
000141 f411                      			brne not_max_chars
                                 
000142 940c 0129                 			jmp characterConvert_end
                                 
                                 		not_max_chars:
000144 94f3                      			inc r15 ;Increase r15
000145 b8f8                      			out PORTC, r15
                                 			; store in next memory address 
000146 9301                      			st z+, temp
                                 			; output this character onto LCD
000147 2f00
000148 d401
000149 d40f                      			mov_lcd_data temp
                                 			
00014a d426                      			rcall delay_30ms
00014b 9573                      			inc temp5
00014c 9508                      			ret
                                 ;//=== Convertion Characters End ===\\
                                 
                                 ;//=== Stations Names ===\\
                                 	; Prompts for a station name
                                 	; @0 is the current station number
                                 	.macro station_name_prompt
                                 		inc @0
                                 		do_lcd_command 0b00000001
                                 		do_lcd_data 'S'
                                 		do_lcd_data 'T'
                                 		do_lcd_data 'A'
                                 		do_lcd_data 'T'
                                 		do_lcd_data 'I'
                                 		do_lcd_data 'O'
                                 		do_lcd_data 'N'
                                 		do_lcd_data ' '
                                 		ldi temp, 0b00110000
                                 		add temp, @0
                                 		mov_lcd_data temp
                                 		do_lcd_data ' '
                                 		do_lcd_data 'N'
                                 		do_lcd_data 'A'
                                 		do_lcd_data 'M'
                                 		do_lcd_data 'E'
                                 		do_lcd_data ':'
                                 		do_lcd_command 0b11000000
                                 		dec @0
                                 	.endmacro
                                 
                                 	readInStations_end:
00014d 9508                      		ret
                                 
                                 	readInStations:
00014e e0e0                      		ldi zl, low(array)
00014f e0f2                      		ldi zh, high(array)
000150 e054                      		ldi temp3, 4
000151 e060                      		ldi temp4, 0
000152 2777                      		clr temp5
                                 
                                 		readInStations_start:
000153 24ff                      			clr r15
000154 1768                      			cp temp4, stationNum
000155 f3b9                      			breq readInStations_end
000156 2777                      			clr temp5
000157 9563
000158 e001
000159 d3e5
00015a d3fe
00015b e503
00015c d3ed
00015d d3fb
00015e e504
00015f d3ea
000160 d3f8
000161 e401
000162 d3e7
000163 d3f5
000164 e504
000165 d3e4
000166 d3f2
000167 e409
000168 d3e1
000169 d3ef
00016a e40f
00016b d3de
00016c d3ec
00016d e40e
00016e d3db
00016f d3e9
000170 e200
000171 d3d8
000172 d3e6
000173 e300
000174 0f06
000175 2f00
000176 d3d3
000177 d3e1
000178 e200
000179 d3d0
00017a d3de
00017b e40e
00017c d3cd
00017d d3db
00017e e401
00017f d3ca
000180 d3d8
000181 e40d
000182 d3c7
000183 d3d5
000184 e405
000185 d3c4
000186 d3d2
000187 e30a
000188 d3c1
000189 d3cf
00018a ec00
00018b d3b3
00018c d3cc
00018d 956a                      			station_name_prompt temp4
00018e 940c 0190                 			jmp readInStations_loop
                                 			
                                 			readInStations_loop:
000190 df09                      				rcall keypad
000191 df64                      				rcall character_convert
                                 
000192 327a                      				cpi temp5, '*'
000193 f7e1                      				brne readInStations_loop
                                 
000194 e001                      				ldi temp , 1
000195 16f0                      				cp r15, temp
000196 f024                      				brlt readInStations_error
                                 
000197 9563                      				inc temp4
000198 d3d3                      				rcall delay_100ms
000199 940c 0153                 				jmp readInStations_start
                                 
                                 		readInStations_error:
00019b 973a                      			sbiw z, 10
00019c e07a                      			ldi temp5, 10
                                 			readInStations_error_loop:
00019d e200                      				ldi temp, ' '
00019e 9301                      				st z+, temp
00019f 957a                      				dec temp5
0001a0 f7e1                      				brne readInStations_error_loop
0001a1 973a                      			sbiw z, 10
0001a2 e001
0001a3 d39b
0001a4 d3b4                      			do_lcd_command 0b1
0001a5 e405
0001a6 d3a3
0001a7 d3b1                      			do_lcd_data 'E'
0001a8 e702
0001a9 d3a0
0001aa d3ae                      			do_lcd_data 'r'
0001ab e702
0001ac d39d
0001ad d3ab                      			do_lcd_data	'r'
0001ae e60f
0001af d39a
0001b0 d3a8                      			do_lcd_data 'o'
0001b1 e702
0001b2 d397
0001b3 d3a5                      			do_lcd_data 'r'
0001b4 e200
0001b5 d394
0001b6 d3a2                      			do_lcd_data ' '
0001b7 d3b4                      			rcall delay_100ms
0001b8 cf9a                      			rjmp readInStations_start
                                 
                                 ;//=== Stations Names End ===\
                                 
                                 ;//=== Max Stations Start ===\\
                                 	.macro askForNumStation
                                 		do_lcd_command 0b1
                                 		do_lcd_data 'N'
                                 		do_lcd_data 'u'
                                 		do_lcd_data	'm'
                                 		do_lcd_data 'b'
                                 		do_lcd_data 'e'
                                 		do_lcd_data 'r'
                                 		do_lcd_data ' '
                                 		do_lcd_data 'o'
                                 		do_lcd_data 'f'
                                 		do_lcd_command 0b11000000 ;second line
                                 		do_lcd_data 'S'
                                 		do_lcd_data 't'
                                 		do_lcd_data 'a'
                                 		do_lcd_data	't'
                                 		do_lcd_data 'i'
                                 		do_lcd_data 'o'
                                 		do_lcd_data 'n'
                                 		do_lcd_data 's'
                                 		do_lcd_data ':'
                                 	.endmacro
                                 	maxStations_end: 
0001b9 9508                      		ret
                                 	maxStations:
0001ba 2766                      		clr temp4
                                 	maxStations_start:
0001bb 3061                      		cpi temp4, 1
0001bc f3e1                      		breq maxStations_end
0001bd 2755                      		clr temp3
0001be e001
0001bf d37f
0001c0 d398
0001c1 e40e
0001c2 d387
0001c3 d395
0001c4 e705
0001c5 d384
0001c6 d392
0001c7 e60d
0001c8 d381
0001c9 d38f
0001ca e602
0001cb d37e
0001cc d38c
0001cd e605
0001ce d37b
0001cf d389
0001d0 e702
0001d1 d378
0001d2 d386
0001d3 e200
0001d4 d375
0001d5 d383
0001d6 e60f
0001d7 d372
0001d8 d380
0001d9 e606
0001da d36f
0001db d37d
0001dc ec00
0001dd d361
0001de d37a
0001df e503
0001e0 d369
0001e1 d377
0001e2 e704
0001e3 d366
0001e4 d374
0001e5 e601
0001e6 d363
0001e7 d371
0001e8 e704
0001e9 d360
0001ea d36e
0001eb e609
0001ec d35d
0001ed d36b
0001ee e60f
0001ef d35a
0001f0 d368
0001f1 e60e
0001f2 d357
0001f3 d365
0001f4 e703
0001f5 d354
0001f6 d362
0001f7 e30a
0001f8 d351
0001f9 d35f                      		askForNumStation
0001fa 940c 01fc                 		jmp maxStations_loop
                                 
                                 	maxStations_loop: 
0001fc de9d                      		rcall keypad
0001fd deb9                      		rcall convertNumbers
0001fe 3001                      		cpi temp, 1 ;not num repeat
0001ff f3e1                      		breq maxStations_loop
000200 3002                      		cpi temp, 2 ;big num error
000201 f021                      		breq maxStations_error_message
000202 3052                      		cpi temp3, 2 ;lower than 2 error
000203 f0c8                      		brlo maxStations_error_message2
000204 2f85                      		mov stationNum, temp3
000205 cfb5                      		rjmp maxStations_start ;correct num
                                 
                                 	maxStations_error_message:
000206 e001
000207 d337
000208 d350                      		do_lcd_command 0b1
000209 e405
00020a d33f
00020b d34d                      		do_lcd_data 'E'
00020c e702
00020d d33c
00020e d34a                      		do_lcd_data 'r'
00020f e702
000210 d339
000211 d347                      		do_lcd_data	'r'
000212 e60f
000213 d336
000214 d344                      		do_lcd_data 'o'
000215 e702
000216 d333
000217 d341                      		do_lcd_data 'r'
000218 e200
000219 d330
00021a d33e                      		do_lcd_data ' '
00021b d355                      		rcall delay_30ms
00021c cf9e                      		rjmp maxStations_start
                                 
                                 	maxStations_error_message2:
00021d e001
00021e d320
00021f d339                      		do_lcd_command 0b1
000220 e405
000221 d328
000222 d336                      		do_lcd_data 'E'
000223 e702
000224 d325
000225 d333                      		do_lcd_data 'r'
000226 e702
000227 d322
000228 d330                      		do_lcd_data	'r'
000229 e60f
00022a d31f
00022b d32d                      		do_lcd_data 'o'
00022c e702
00022d d31c
00022e d32a                      		do_lcd_data 'r'
00022f e200
000230 d319
000231 d327                      		do_lcd_data ' '
000232 e30c
000233 d316
000234 d324                      		do_lcd_data '<'
000235 e302
000236 d313
000237 d321                      		do_lcd_data '2'
000238 d333                      		rcall delay_100ms
000239 2766                      		clr temp4
00023a cf80                      		rjmp maxStations_start
                                 ;//=== Max Stations End ===\\
                                 
                                 ;//=== Loading Bar Start ===\\
                                 	nextSection:
                                 		;message
00023b e001
00023c d302
00023d d31b                      		do_lcd_command 0b1
00023e e500
00023f d30a
000240 d318                      		do_lcd_data 'P'
000241 d32f                      		rcall delay_30ms
000242 e40c
000243 d306
000244 d314                      		do_lcd_data 'L'
000245 d32b                      		rcall delay_30ms
000246 e405
000247 d302
000248 d310                      		do_lcd_data	'E'
000249 d327                      		rcall delay_30ms
00024a e401
00024b d2fe
00024c d30c                      		do_lcd_data 'A'
00024d d323                      		rcall delay_30ms
00024e e503
00024f d2fa
000250 d308                      		do_lcd_data 'S'
000251 d31f                      		rcall delay_30ms
000252 e405
000253 d2f6
000254 d304                      		do_lcd_data 'E'
000255 d31b                      		rcall delay_30ms
000256 e200
000257 d2f2
000258 d300                      		do_lcd_data ' '
000259 e507
00025a d2ef
00025b d2fd                      		do_lcd_data 'W'
00025c d314                      		rcall delay_30ms
00025d e401
00025e d2eb
00025f d2f9                      		do_lcd_data 'A'
000260 d310                      		rcall delay_30ms
000261 e409
000262 d2e7
000263 d2f5                      		do_lcd_data 'I'
000264 d30c                      		rcall delay_30ms
000265 e504
000266 d2e3
000267 d2f1                      		do_lcd_data 'T'
000268 d308                      		rcall delay_30ms
000269 ec00
00026a d2d4
00026b d2ed                      		do_lcd_command 0b11000000
00026c e40c
00026d d2dc
00026e d2ea                      		do_lcd_data 'L'
00026f d301                      		rcall delay_30ms
000270 e40f
000271 d2d8
000272 d2e6                      		do_lcd_data 'O'
000273 d2fd                      		rcall delay_30ms
000274 e401
000275 d2d4
000276 d2e2                      		do_lcd_data 'A'
000277 d2f9                      		rcall delay_30ms
000278 e404
000279 d2d0
00027a d2de                      		do_lcd_data 'D'
00027b d2f5                      		rcall delay_30ms
00027c e409
00027d d2cc
00027e d2da                      		do_lcd_data 'I'
00027f d2f1                      		rcall delay_30ms
000280 e40e
000281 d2c8
000282 d2d6                      		do_lcd_data 'N'
000283 d2ed                      		rcall delay_30ms
000284 e407
000285 d2c4
000286 d2d2                      		do_lcd_data 'G'
000287 d2e9                      		rcall delay_30ms
000288 2744                      		clr temp2
                                 		nextSection_loop:
000289 9543                      		inc temp2
00028a e20d
00028b d2be
00028c d2cc                      		do_lcd_data 0b00101101
00028d e100
00028e d2b0
00028f d2c9                      		do_lcd_command 0b10000 ;go back one
000290 d2db                      		rcall delay_100ms
000291 e20f
000292 d2b7
000293 d2c5                      		do_lcd_data 0b00101111
000294 e100
000295 d2a9
000296 d2c2                      		do_lcd_command 0b10000
000297 d2d4                      		rcall delay_100ms
000298 e70c
000299 d2b0
00029a d2be                      		do_lcd_data 0b01111100
00029b e100
00029c d2a2
00029d d2bb                      		do_lcd_command 0b10000
00029e d2cd                      		rcall delay_100ms
00029f ec0d
0002a0 d2a9
0002a1 d2b7                      		do_lcd_data 0b11001101
0002a2 e100
0002a3 d29b
0002a4 d2b4                      		do_lcd_command 0b10000
0002a5 d2c6                      		rcall delay_100ms
0002a6 3041                      		cpi temp2, 1
0002a7 f308                      		brlo nextSection_loop
0002a8 9508                      		ret
                                 ;//=== Loading Bar End ===\\
                                 
                                 ;//=== Time Between Stations Start ===\\
                                 	.macro endWrap ;num
                                 		;Increase the value of the input unless its equal to the number of stations
                                 		;If it is, change it to 1
                                 		ldi temp, AsciiNum
                                 		sub @0, temp
                                 		cp @0, stationNum
                                 		brlo endWrap_end
                                 		sub @0, stationNum
                                 		endWrap_end:
                                 		inc @0
                                 		ldi temp, AsciiNum
                                 		add @0, temp
                                 	.endmacro
                                 	.macro askForTime ;Print message onto the lcd
                                 		do_lcd_data 'T'
                                 		do_lcd_data 'i'
                                 		do_lcd_data	'm'
                                 		do_lcd_data 'e'
                                 		do_lcd_data ' '
                                 		do_lcd_data 'f'
                                 		do_lcd_data 'r'
                                 		do_lcd_data 'o'
                                 		do_lcd_data 'm'
                                 		do_lcd_data ' '
                                 		do_lcd_command 0b11000000
                                 		do_lcd_data 'S'
                                 		ldi temp2, AsciiNum
                                 		add temp2, temp4
                                 		endWrap temp2
                                 		mov_lcd_data temp2
                                 		do_lcd_data ' '
                                 		do_lcd_data 't'
                                 		do_lcd_data 'o'
                                 		do_lcd_data ' '
                                 		do_lcd_data 'S'
                                 		endWrap temp2
                                 		mov_lcd_data temp2
                                 		do_lcd_data ':'
                                 	.endmacro
                                 	timeBetweenStations_end:
0002a9 916a                      		ld temp4, -Y ;load in last value
0002aa e6c4                      		ldi YL, low(times)
0002ab e0d2                      		ldi YH, high(times)
0002ac 8368                      		st y, temp4 ;store last value, see bellow note
0002ad 9508                      		ret
                                 	timeBetweenStations:
0002ae e001
0002af d28f
0002b0 d2a8                      		do_lcd_command 0b1
0002b1 9169                      		ld temp4, y+ ;leave the first value blank so the list of names and times match up
0002b2 2766                      		clr temp4
                                 		
                                 	timeBetweenStations_start:
0002b3 1768                      		cp temp4, stationNum
0002b4 f3a1                      		breq timeBetweenStations_end
0002b5 2755                      		clr temp3
0002b6 e504
0002b7 d292
0002b8 d2a0
0002b9 e609
0002ba d28f
0002bb d29d
0002bc e60d
0002bd d28c
0002be d29a
0002bf e605
0002c0 d289
0002c1 d297
0002c2 e200
0002c3 d286
0002c4 d294
0002c5 e606
0002c6 d283
0002c7 d291
0002c8 e702
0002c9 d280
0002ca d28e
0002cb e60f
0002cc d27d
0002cd d28b
0002ce e60d
0002cf d27a
0002d0 d288
0002d1 e200
0002d2 d277
0002d3 d285
0002d4 ec00
0002d5 d269
0002d6 d282
0002d7 e503
0002d8 d271
0002d9 d27f
0002da e340
0002db 0f46
0002dc e300
0002dd 1b40
0002de 1748
0002df f008
0002e0 1b48
0002e1 9543
0002e2 e300
0002e3 0f40
0002e4 2f04
0002e5 d264
0002e6 d272
0002e7 e200
0002e8 d261
0002e9 d26f
0002ea e704
0002eb d25e
0002ec d26c
0002ed e60f
0002ee d25b
0002ef d269
0002f0 e200
0002f1 d258
0002f2 d266
0002f3 e503
0002f4 d255
0002f5 d263
0002f6 e300
0002f7 1b40
0002f8 1748
0002f9 f008
0002fa 1b48
0002fb 9543
0002fc e300
0002fd 0f40
0002fe 2f04
0002ff d24a
000300 d258
000301 e30a
000302 d247
000303 d255                      		askForTime
000304 940c 0306                 		jmp timeBetweenStations_loop
                                 	timeBetweenStations_loop: 
000306 dd93                      		rcall keypad
000307 ddaf                      		rcall convertNumbers
000308 3001                      		cpi temp, 1 ;not num repeat
000309 f3e1                      		breq timeBetweenStations_loop
00030a 3002                      		cpi temp, 2 ;big num error
00030b f011                      		breq timeBetweenStations_error_message
                                 		;correct number stored into y
00030c 9359                      		st y+, temp3 ;store the correct num into y
00030d cfa5                      		rjmp timeBetweenStations_start
                                 
                                 	timeBetweenStations_error_message:
00030e e001
00030f d22f
000310 d248                      		do_lcd_command 0b1
000311 e405
000312 d237
000313 d245                      		do_lcd_data 'E'
000314 e702
000315 d234
000316 d242                      		do_lcd_data 'r'
000317 e702
000318 d231
000319 d23f                      		do_lcd_data	'r'
00031a e60f
00031b d22e
00031c d23c                      		do_lcd_data 'o'
00031d e702
00031e d22b
00031f d239                      		do_lcd_data 'r'
000320 e200
000321 d228
000322 d236                      		do_lcd_data ' '
                                 		
                                 
000323 d24d                      		rcall delay_30ms
000324 ec00
000325 d219
000326 d232                      		do_lcd_command 0b11000000 ;second row
000327 940c 02b3                 		jmp timeBetweenStations_start ;restart
                                 ;//=== Time Between Station End ===\\
                                 
                                 ;//=== Stop Time Request Start ===\\
                                 	.macro askForstopTime
                                 		do_lcd_command 0b1
                                 		do_lcd_data 'S'
                                 		do_lcd_data 't'
                                 		do_lcd_data	'o'
                                 		do_lcd_data 'p'
                                 		do_lcd_data ' '
                                 		do_lcd_data 't'
                                 		do_lcd_data 'i'
                                 		do_lcd_data 'm'
                                 		do_lcd_data 'e'
                                 		do_lcd_data ' '
                                 		do_lcd_data 'i'
                                 		do_lcd_data 's'
                                 		do_lcd_data	' '
                                 		do_lcd_command 0b11000000 ;second line
                                 		do_lcd_data ' '
                                 		do_lcd_data ' '
                                 		do_lcd_data ' '
                                 		do_lcd_data 's'
                                 		do_lcd_data 'e'
                                 		do_lcd_data 'c'
                                 		do_lcd_data 'o'
                                 		do_lcd_data 'n'
                                 		do_lcd_data 'd'
                                 		do_lcd_data 's'
                                 		clr temp2
                                 		back_10_loop:
                                 			do_lcd_command 0b10000 ;go back one
                                 			inc temp2
                                 		cpi temp2, 10
                                 		brlo back_10_loop
                                 	.endmacro
                                 	stopTimeRequest_end: 
000329 9508                      		ret
                                 	stopTimeRequest:
00032a 2766                      		clr temp4
                                 	stopTimeRequest_start:
00032b 3061                      		cpi temp4, 1
00032c f3e1                      		breq stopTimeRequest_end
00032d 2755                      		clr temp3
00032e e001
00032f d20f
000330 d228
000331 e503
000332 d217
000333 d225
000334 e704
000335 d214
000336 d222
000337 e60f
000338 d211
000339 d21f
00033a e700
00033b d20e
00033c d21c
00033d e200
00033e d20b
00033f d219
000340 e704
000341 d208
000342 d216
000343 e609
000344 d205
000345 d213
000346 e60d
000347 d202
000348 d210
000349 e605
00034a d1ff
00034b d20d
00034c e200
00034d d1fc
00034e d20a
00034f e609
000350 d1f9
000351 d207
000352 e703
000353 d1f6
000354 d204
000355 e200
000356 d1f3
000357 d201
000358 ec00
000359 d1e5
00035a d1fe
00035b e200
00035c d1ed
00035d d1fb
00035e e200
00035f d1ea
000360 d1f8
000361 e200
000362 d1e7
000363 d1f5
000364 e703
000365 d1e4
000366 d1f2
000367 e605
000368 d1e1
000369 d1ef
00036a e603
00036b d1de
00036c d1ec
00036d e60f
00036e d1db
00036f d1e9
000370 e60e
000371 d1d8
000372 d1e6
000373 e604
000374 d1d5
000375 d1e3
000376 e703
000377 d1d2
000378 d1e0
000379 2744
00037a e100
00037b d1c3
00037c d1dc
00037d 9543
00037e 304a
00037f f3d0                      		askForstopTime
000380 940c 0382                 		jmp stopTimeRequest_loop
                                 	stopTimeRequest_loop: 
000382 dd17                      		rcall keypad
000383 dd33                      		rcall convertNumbers
000384 3001                      		cpi temp, 1 ;not num repeat
000385 f3e1                      		breq stopTimeRequest_loop
000386 305b                      		cpi temp3, 11 ;big num error
000387 f420                      		brsh stopTimeRequest_error_message
000388 3052                      		cpi temp3, 2 ;lower than 2 error
000389 f110                      		brlo stopTimeRequest_error_message2
                                 		
00038a 2e65                      		mov stopTime, temp3
00038b cf9f                      		rjmp stopTimeRequest_start ;correct num
                                 	stopTimeRequest_error_message:
00038c e001
00038d d1b1
00038e d1ca                      		do_lcd_command 0b1
00038f e405
000390 d1b9
000391 d1c7                      		do_lcd_data 'E'
000392 e702
000393 d1b6
000394 d1c4                      		do_lcd_data 'r'
000395 e702
000396 d1b3
000397 d1c1                      		do_lcd_data	'r'
000398 e60f
000399 d1b0
00039a d1be                      		do_lcd_data 'o'
00039b e702
00039c d1ad
00039d d1bb                      		do_lcd_data 'r'
00039e e200
00039f d1aa
0003a0 d1b8                      		do_lcd_data ' '
0003a1 e30e
0003a2 d1a7
0003a3 d1b5                      		do_lcd_data '>'
0003a4 e301
0003a5 d1a4
0003a6 d1b2                      		do_lcd_data '1'
0003a7 e300
0003a8 d1a1
0003a9 d1af                      		do_lcd_data '0'
0003aa d1c1                      		rcall delay_100ms
0003ab cf7f                      		rjmp stopTimeRequest_start
                                 	stopTimeRequest_error_message2:
0003ac e001
0003ad d191
0003ae d1aa                      		do_lcd_command 0b1
0003af e405
0003b0 d199
0003b1 d1a7                      		do_lcd_data 'E'
0003b2 e702
0003b3 d196
0003b4 d1a4                      		do_lcd_data 'r'
0003b5 e702
0003b6 d193
0003b7 d1a1                      		do_lcd_data	'r'
0003b8 e60f
0003b9 d190
0003ba d19e                      		do_lcd_data 'o'
0003bb e702
0003bc d18d
0003bd d19b                      		do_lcd_data 'r'
0003be e200
0003bf d18a
0003c0 d198                      		do_lcd_data ' '
0003c1 e30c
0003c2 d187
0003c3 d195                      		do_lcd_data '<'
0003c4 e302
0003c5 d184
0003c6 d192                      		do_lcd_data '2'
0003c7 d1a4                      		rcall delay_100ms
0003c8 2766                      		clr temp4
0003c9 cf61                      		rjmp stopTimeRequest_start
                                 ;//=== Stop Time Request End ===\\
                                 
                                 ;//=== Read and Print Stations Start ===\\
                                 	.macro	PrintName
                                 		;"Next:" message
                                 			do_lcd_command 0b1
                                 			do_lcd_data 'N'
                                 			rcall delay_10ms
                                 			do_lcd_data 'E'
                                 			rcall delay_10ms
                                 			do_lcd_data 'X'
                                 			rcall delay_10ms
                                 			do_lcd_data 'T'
                                 			rcall delay_10ms
                                 			do_lcd_data ':'
                                 
                                 		;Name of Next Stop
                                 		clr r1
                                 		Loop_PN:
                                 			ld temp, z+
                                 			mov_lcd_data temp
                                 			inc r1
                                 			ldi temp, 10
                                 			cp r1, temp
                                 			brlo Loop_PN
                                 		;do_lcd_data '@'
                                 		rcall delay_100ms
                                 	.endmacro
                                 	
                                 	.macro hashCheck
                                 		push temp2
                                 		ldi mask, hashcol
                                 		sts PORTL, mask
                                 		ldi temp, 0xFF
                                 		hashCheck_stablisation:
                                 			dec temp2
                                 			brne hashCheck_stablisation
                                 		LDS temp2, PINL
                                 		andi temp2, ROWMASK
                                 		cpi temp2, ROWMASK
                                 		breq zeroReturn
                                 		ldi mask, hashrow
                                 		and temp2, mask
                                 		brne zeroReturn
                                 		ldi temp, 0xFF
                                 		mov @0, temp
                                 		out PORTC, temp
                                 		rcall delay_100ms
                                 		rjmp hashCheck_end
                                 
                                 		zeroReturn:
                                 			clr @0
                                 		hashCheck_end:
                                 		pop temp2
                                 	.endmacro
                                 
                                 	hashInterrupt:
                                 		;"EMERGENCY STOP" message
0003ca ec00
0003cb d173
0003cc d18c                      			do_lcd_command 0b11000000
0003cd e405
0003ce d17b
0003cf d189                      			do_lcd_data 'E'
0003d0 d1a7                      			rcall delay_10ms
0003d1 e40d
0003d2 d177
0003d3 d185                      			do_lcd_data 'M'
0003d4 d1a3                      			rcall delay_10ms
0003d5 e405
0003d6 d173
0003d7 d181                      			do_lcd_data 'E'
0003d8 d19f                      			rcall delay_10ms
0003d9 e502
0003da d16f
0003db d17d                      			do_lcd_data 'R'
0003dc d19b                      			rcall delay_10ms
0003dd e407
0003de d16b
0003df d179                      			do_lcd_data 'G'
0003e0 d197                      			rcall delay_10ms
0003e1 e405
0003e2 d167
0003e3 d175                      			do_lcd_data 'E'
0003e4 d193                      			rcall delay_10ms
0003e5 e40e
0003e6 d163
0003e7 d171                      			do_lcd_data 'N'
0003e8 d18f                      			rcall delay_10ms
0003e9 e403
0003ea d15f
0003eb d16d                      			do_lcd_data 'C'
0003ec d18b                      			rcall delay_10ms
0003ed e509
0003ee d15b
0003ef d169                      			do_lcd_data 'Y'
0003f0 d187                      			rcall delay_10ms
0003f1 e200
0003f2 d157
0003f3 d165                      			do_lcd_data ' '
0003f4 d183                      			rcall delay_10ms
0003f5 e503
0003f6 d153
0003f7 d161                      			do_lcd_data 'S'
0003f8 d17f                      			rcall delay_10ms
0003f9 e504
0003fa d14f
0003fb d15d                      			do_lcd_data 'T'
0003fc d17b                      			rcall delay_10ms
0003fd e40f
0003fe d14b
0003ff d159                      			do_lcd_data 'O'
000400 d177                      			rcall delay_10ms
000401 e500
000402 d147
000403 d155                      			do_lcd_data 'P'
000404 d173                      			rcall delay_10ms
                                 		
                                 
000405 92cf                      		push r12
000406 24cc                      		clr r12
000407 e000                      		ldi temp, 0
000408 9300 00ac                 		sts OCR4CL, temp
00040a 9300 00ad                 		sts OCR4CH, temp
                                 
                                 		interrupt_loop:
00040c 934f
00040d eb3f
00040e 9330 010b
000410 ef0f
000411 954a
000412 f7f1
000413 9140 0109
000415 704f
000416 304f
000417 f041
000418 e038
000419 2343
00041a f429
00041b ef0f
00041c 2f00
00041d b908
00041e d14d
00041f c001
000420 2700
000421 914f                      			hashCheck temp
000422 fd00                      			sbrc temp, 0
000423 c00f                      			rjmp hashInterrupt_end
                                 
000424 d153                      			rcall delay_10ms
000425 94c3                      			inc r12
000426 e104                      			ldi temp, 20
000427 16c0                      			cp r12, temp
000428 f318                      			brlo interrupt_loop
000429 e003                      			ldi temp, 0b11
00042a b908                      			out PORTC, temp
                                 
00042b e201                      			ldi temp, 33
00042c 16c0                      			cp r12, temp
00042d f2f0                      			brlo interrupt_loop
00042e e000                      			ldi temp, 0b00
00042f b908                      			out PORTC, temp
000430 e000                      			ldi temp, 0
000431 2ec0                      			mov r12, temp
000432 cfd9                      			rjmp interrupt_loop
                                 
                                 		hashInterrupt_end:
000433 e000                      		ldi temp, motorSpeed
000434 9300 00ac                 		sts OCR4CL, temp
000436 2700                      		clr temp
000437 9300 00ad                 		sts OCR4CH, temp
000439 90cf                      		pop r12
                                 		;Clear "EMERGENCY STOP" message
00043a ec00
00043b d103
00043c d11c                      			do_lcd_command 0b11000000
00043d e200
00043e d10b
00043f d119                      			do_lcd_data ' '
000440 e200
000441 d108
000442 d116                      			do_lcd_data ' '
000443 e200
000444 d105
000445 d113                      			do_lcd_data ' '
000446 e200
000447 d102
000448 d110                      			do_lcd_data ' '
000449 e200
00044a d0ff
00044b d10d                      			do_lcd_data ' '
00044c e200
00044d d0fc
00044e d10a                      			do_lcd_data ' '
00044f e200
000450 d0f9
000451 d107                      			do_lcd_data ' '
000452 e200
000453 d0f6
000454 d104                      			do_lcd_data ' '
000455 e200
000456 d0f3
000457 d101                      			do_lcd_data ' '
000458 e200
000459 d0f0
00045a d0fe                      			do_lcd_data ' '
00045b e200
00045c d0ed
00045d d0fb                      			do_lcd_data ' '
00045e e200
00045f d0ea
000460 d0f8                      			do_lcd_data ' '
000461 e200
000462 d0e7
000463 d0f5                      			do_lcd_data ' '
000464 e200
000465 d0e4
000466 d0f2                      			do_lcd_data ' '
000467 e200
000468 d0e1
000469 d0ef                      			do_lcd_data ' '
00046a e200
00046b d0de
00046c d0ec                      			do_lcd_data ' '
00046d ec00
00046e d0d0
00046f d0e9                      			do_lcd_command 0b11000000
000470 2422                      			clr r2
                                 			block_loop:
000471 9423                      				inc r2
000472 ef0f
000473 d0d6
000474 d0e4                      				do_lcd_data 0xff
000475 1423                      				cp r2, r3
000476 f7d1                      				brne block_loop
000477 ea0a                      		ldi temp, 0b10101010
000478 b908                      		out PORTC, temp
000479 9508                      	ret
                                 
                                 	.macro travelling
                                 		push r15
                                 		push r14
                                 		push r13
                                 		sei
                                 		ldi temp, motorSpeed
                                 		sts OCR4CL, temp
                                 		clr temp
                                 		sts OCR4CH, temp
                                 
                                 		ldi temp, 0b10101010
                                 		out PORTC, temp
                                 
                                 		clr r3
                                 		do_lcd_command 0b11000000
                                 		do_lcd_data 0xff
                                 
                                 		mov r14, TravelTime
                                 		travelling_loop:
                                 			inc r3
                                 			ldi temp, 100
                                 			mov r15, temp
                                 			in temp, pinc
                                 			com temp
                                 			out PORTC, temp
                                 			travelling_1s:
                                 				rcall delay_10ms
                                 				hashCheck temp
                                 				sbrc temp, 0
                                 				rcall hashInterrupt
                                 				dec r15
                                 				brne travelling_1s
                                 			do_lcd_data 0xff
                                 			dec r14
                                 			brne travelling_loop
                                 		
                                 		clr temp
                                 		out PORTC, temp
                                 		cli
                                 		pop r13
                                 		pop r14
                                 		pop r15
                                 	.endmacro
                                 
                                 	.macro stopping
                                 		do_lcd_command 0b1
                                 		do_lcd_data 'T'
                                 		do_lcd_data 'R'
                                 		do_lcd_data 'A'
                                 		do_lcd_data 'I'
                                 		do_lcd_data 'N'
                                 		do_lcd_data ' '
                                 		do_lcd_data 'S'
                                 		do_lcd_data 'T'
                                 		do_lcd_data 'O'
                                 		do_lcd_data 'P'
                                 		do_lcd_data 'P'
                                 		do_lcd_data 'I'
                                 		do_lcd_data 'N'
                                 		do_lcd_data 'G'
                                 		do_lcd_command 0b11000000
                                 
                                 		clr temp
                                 		sts OCR4CL, temp
                                 		sts OCR4CH, temp
                                 		mov r15, stopTime
                                 		clr r14
                                 		clr temp
                                 		out PORTC, temp
                                 		stopping_loop:
                                 			ldi temp, 100
                                 			mov r14, temp
                                 			stopping_1s:
                                 				in temp, pinc
                                 				inc temp
                                 				out PORTC, temp
                                 				rcall delay_10ms
                                 				dec r14
                                 				brne stopping_1s
                                 			dec r15
                                 			brne stopping_loop
                                 		ldi temp, 0
                                 		mov r5, temp
                                 	.endmacro
                                 
                                 	readPrint:
00047a e001
00047b d0c3
00047c d0dc                      		do_lcd_command 0B1
00047d e0e0                      		ldi zl, low(array)
00047e e0f2                      		ldi zh, high(array)
00047f e6c4                      		ldi yl, low(times)
000480 e0d2                      		ldi yh, high(times)
000481 2477                      		clr currStation
000482 9473                      		inc currStation
000483 963a                      		adiw z, 10
000484 9109                      		ld temp, y+
000485 9109                      		ld temp, y+
000486 2e80                      		mov TravelTime, temp
                                 
                                 	readPrint_loop:
000487 e001
000488 d0b6
000489 d0cf
00048a e40e
00048b d0be
00048c d0cc
00048d d0ea
00048e e405
00048f d0ba
000490 d0c8
000491 d0e6
000492 e508
000493 d0b6
000494 d0c4
000495 d0e2
000496 e504
000497 d0b2
000498 d0c0
000499 d0de
00049a e30a
00049b d0ae
00049c d0bc
00049d 2411
00049e 9101
00049f 2f00
0004a0 d0a9
0004a1 d0b7
0004a2 9413
0004a3 e00a
0004a4 1610
0004a5 f3c0
0004a6 d0c5                      		PrintName
0004a7 9473                      		inc currStation		
0004a8 1678                      		cp currStation, stationNum ;last name check
0004a9 f028                      		brlo readPrint_normalLoop ;not last name
                                 		
0004aa e0e0                      		ldi zl, low(array) ;reset it to the start of name array
0004ab e0f2                      		ldi zh, high(array)
0004ac e6c4                      		ldi yl, low(times)
0004ad e0d2                      		ldi yh, high(times)
0004ae 2477                      		clr currStation
                                 
                                 		readPrint_normalLoop:
0004af 92ff
0004b0 92ef
0004b1 92df
0004b2 9478
0004b3 e000
0004b4 9300 00ac
0004b6 2700
0004b7 9300 00ad
0004b9 ea0a
0004ba b908
0004bb 2433
0004bc ec00
0004bd d081
0004be d09a
0004bf ef0f
0004c0 d089
0004c1 d097
0004c2 2ce8
0004c3 9433
0004c4 e604
0004c5 2ef0
0004c6 b106
0004c7 9500
0004c8 b908
0004c9 d0ae
0004ca 934f
0004cb eb3f
0004cc 9330 010b
0004ce ef0f
0004cf 954a
0004d0 f7f1
0004d1 9140 0109
0004d3 704f
0004d4 304f
0004d5 f041
0004d6 e038
0004d7 2343
0004d8 f429
0004d9 ef0f
0004da 2f00
0004db b908
0004dc d08f
0004dd c001
0004de 2700
0004df 914f
0004e0 fd00
0004e1 dee8
0004e2 94fa
0004e3 f729
0004e4 ef0f
0004e5 d064
0004e6 d072
0004e7 94ea
0004e8 f6d1
0004e9 2700
0004ea b908
0004eb 94f8
0004ec 90df
0004ed 90ef
0004ee 90ff                      		travelling
0004ef ef0f                      		ldi temp, 0xFF
0004f0 1505                      		cp temp, r5 ;check if button interrupt was triggered
0004f1 f411                      		brne readPrint_cont_relay
0004f2 940c 04f6                 		jmp readPrint_stopping
0004f4 940c 053b                 		readPrint_cont_relay: jmp readPrint_cont
                                 		readPrint_stopping:
0004f6 e001
0004f7 d047
0004f8 d060
0004f9 e504
0004fa d04f
0004fb d05d
0004fc e502
0004fd d04c
0004fe d05a
0004ff e401
000500 d049
000501 d057
000502 e409
000503 d046
000504 d054
000505 e40e
000506 d043
000507 d051
000508 e200
000509 d040
00050a d04e
00050b e503
00050c d03d
00050d d04b
00050e e504
00050f d03a
000510 d048
000511 e40f
000512 d037
000513 d045
000514 e500
000515 d034
000516 d042
000517 e500
000518 d031
000519 d03f
00051a e409
00051b d02e
00051c d03c
00051d e40e
00051e d02b
00051f d039
000520 e407
000521 d028
000522 d036
000523 ec00
000524 d01a
000525 d033
000526 2700
000527 9300 00ac
000529 9300 00ad
00052b 2cf6
00052c 24ee
00052d 2700
00052e b908
00052f e604
000530 2ee0
000531 b106
000532 9503
000533 b908
000534 d043
000535 94ea
000536 f7d1
000537 94fa
000538 f7b1
000539 e000
00053a 2e50                      		stopping
                                 
                                 		readPrint_cont:
00053b 9109                      		ld temp, y+
00053c 2e80                      		mov TravelTime, temp
00053d 940c 0487                 		jmp readPrint_loop
                                 
                                 
                                 ;//=== Read and Print Stations End ===\\
                                 
                                 
                                 ;//=== LCD screen commands ===\\\
                                 	.equ LCD_RS = 7
                                 	.equ LCD_E = 6
                                 	.equ LCD_RW = 5
                                 	.equ LCD_BE = 4
                                 
                                 	.macro lcd_set
                                 		sbi PORTA, @0
                                 	.endmacro
                                 	.macro lcd_clr
                                 		cbi PORTA, @0
                                 	.endmacro
                                 
                                 	; Send a command to the LCD (temp)
                                 		lcd_command:
00053f bb01                      			out PORTF, temp
000540 0000                      			nop
000541 9a16                      			lcd_set LCD_E
000542 0000                      			nop
000543 0000                      			nop
000544 0000                      			nop
000545 9816                      			lcd_clr LCD_E
000546 0000                      			nop
000547 0000                      			nop
000548 0000                      			nop
000549 9508                      			ret
                                 
                                 		lcd_data:
00054a bb01                      			out PORTF, temp
00054b 9a17                      			lcd_set LCD_RS
00054c 0000                      			nop
00054d 0000                      			nop
00054e 0000                      			nop
00054f 9a16                      			lcd_set LCD_E
000550 0000                      			nop
000551 0000                      			nop
000552 0000                      			nop
000553 9816                      			lcd_clr LCD_E
000554 0000                      			nop
000555 0000                      			nop
000556 0000                      			nop
000557 9817                      			lcd_clr LCD_RS
000558 9508                      			ret
                                 
                                 		lcd_wait:
000559 930f                      			push temp
00055a 2700                      			clr temp
00055b bb00                      			out DDRF, temp
00055c bb01                      			out PORTF, temp
00055d 9a15                      			lcd_set LCD_RW
                                 		lcd_wait_loop:
00055e 0000                      			nop
00055f 9a16                      			lcd_set LCD_E
000560 0000                      			nop
000561 0000                      			nop
000562 0000                      			nop
000563 b10f                      			in temp, PINF
000564 9816                      			lcd_clr LCD_E
000565 fd07                      			sbrc temp, 7
000566 cff7                      			rjmp lcd_wait_loop
000567 9815                      			lcd_clr LCD_RW
000568 ef0f                      			ser temp
000569 bb00                      			out DDRF, temp
00056a 910f                      			pop temp
00056b 9508                      			ret
                                 	
                                 	delay_100ms:
00056c d004                      		rcall delay_30ms
00056d d003                      		rcall delay_30ms
00056e d002                      		rcall delay_30ms
00056f d008                      		rcall delay_10ms
000570 9508                      		ret
                                 	
                                 	delay_30ms:
000571 938f                      		push r24
000572 e18e                      		ldi r24, 30
                                 		delay_loop_loop:
000573 d004                      		rcall delay_10ms
000574 958a                      		dec r24
000575 f7e9                      		brne delay_loop_loop
000576 918f                      		pop r24
000577 9508                      		ret
                                 
                                 	delay_10ms: ;80000c
                                 		;prologue
000578 938f                      		push r24 ;2c
000579 939f                      		push r25 ;2c
00057a e99c                      		ldi r25, high(Delay_Counter) ;1c
00057b e38c                      		ldi r24, low(Delay_Counter) ;1c
                                 
                                 		delay_loop:
00057c 9701                      			sbiw r25:r24, 1 ;2c
00057d f7f1                      			brne delay_loop ;2c if looping 1c if pass through
00057e 919f                      			pop r25 ;2c
00057f 918f                      			pop r24 ;2c
000580 0000                      			nop ;1c
000581 0000                      			nop ;1c
000582 0000                      			nop ;1c
000583 9508                      			ret ;4c


RESOURCE USE INFORMATION
------------------------

Notice:
The register and instruction counts are symbol table hit counts,
and hence implicitly used resources are not counted, eg, the
'lpm' instruction without operands implicitly uses r0 and z,
none of which are counted.

x,y,z are separate entities in the symbol table and are
counted separately from r26..r31 here.

.dseg memory usage only counts static data declared with .byte

"ATmega2560" register use summary:
x  :   0 y  :   9 z  :  27 r0 :   2 r1 :   3 r2 :   3 r3 :   3 r4 :   0 
r5 :   3 r6 :   3 r7 :   5 r8 :   3 r9 :   4 r10:   0 r11:   0 r12:   7 
r13:   2 r14:   7 r15:  13 r16: 464 r17:  11 r18:  12 r19:  18 r20:  60 
r21:  25 r22:  19 r23:  11 r24:  17 r25:   4 r26:   0 r27:   0 r28:   5 
r29:   5 r30:   5 r31:   5 
Registers used: 29 out of 35 (82.9%)

"ATmega2560" instruction use summary:
.lds  :   0 .sts  :   0 adc   :   0 add   :  16 adiw  :   1 and   :   3 
andi  :   3 asr   :   0 bclr  :   0 bld   :   0 brbc  :   0 brbs  :   0 
brcc  :   0 brcs  :   0 break :   0 breq  :  30 brge  :   0 brhc  :   0 
brhs  :   0 brid  :   0 brie  :   0 brlo  :  12 brlt  :   1 brmi  :   0 
brne  :  22 brpl  :   0 brsh  :   2 brtc  :   0 brts  :   0 brvc  :   0 
brvs  :   0 bset  :   0 bst   :   0 call  :   7 cbi   :   5 cbr   :   0 
clc   :   0 clh   :   0 cli   :   2 cln   :   0 clr   :  39 cls   :   0 
clt   :   0 clv   :   0 clz   :   0 com   :   1 cp    :  14 cpc   :   0 
cpi   :  39 cpse  :   0 dec   :  12 eicall:   0 eijmp :   0 elpm  :   0 
eor   :   0 fmul  :   0 fmuls :   0 fmulsu:   0 icall :   0 ijmp  :   0 
in    :   4 inc   :  23 jmp   :  23 ld    :   6 ldd   :   0 ldi   : 338 
lds   :   3 lpm   :   0 lsl   :   5 lsr   :   0 mov   :  29 movw  :   0 
mul   :   2 muls  :   0 mulsu :   0 neg   :   0 nop   :  23 or    :   0 
ori   :   1 out   :  29 pop   :  11 push  :  11 rcall : 539 ret   :  21 
reti  :   1 rjmp  :  13 rol   :   1 ror   :   0 sbc   :   0 sbci  :   0 
sbi   :   5 sbic  :   0 sbis  :   0 sbiw  :   3 sbr   :   0 sbrc  :   3 
sbrs  :   0 sec   :   1 seh   :   0 sei   :   2 sen   :   0 ser   :   4 
ses   :   0 set   :   0 sev   :   0 sez   :   0 sleep :   0 spm   :   0 
st    :  27 std   :   0 sts   :  18 sub   :   5 subi  :   1 swap  :   0 
tst   :   0 wdr   :   0 
Instructions used: 46 out of 116 (39.7%)

"ATmega2560" memory use summary [bytes]:
Segment   Begin    End      Code   Data   Used    Size   Use%
---------------------------------------------------------------
[.cseg] 0x000000 0x000b08   2824      0   2824  262144   1.1%
[.dseg] 0x000200 0x00026f      0    111    111    8192   1.4%
[.eseg] 0x000000 0x000000      0      0      0    4096   0.0%

Assembly complete, 0 errors, 0 warnings
