
AVRASM ver. 2.2.7  C:\Users\Imper\Documents\Atmel Studio\7.0\_Project\_Project\main.asm Sun Aug 11 16:10:44 2019

[builtin](2): Including file 'C:/Program Files (x86)\Atmel\Studio\7.0\Packs\atmel\ATmega_DFP\1.2.209\avrasm\inc\m2560def.inc'
C:\Users\Imper\Documents\Atmel Studio\7.0\_Project\_Project\main.asm(1): Including file 'C:/Program Files (x86)\Atmel\Studio\7.0\Packs\atmel\ATmega_DFP\1.2.209\avrasm\inc\m2560def.inc'
[builtin](2): Including file 'C:/Program Files (x86)\Atmel\Studio\7.0\Packs\atmel\ATmega_DFP\1.2.209\avrasm\inc\m2560def.inc'
C:\Users\Imper\Documents\Atmel Studio\7.0\_Project\_Project\main.asm(1): Including file 'C:/Program Files (x86)\Atmel\Studio\7.0\Packs\atmel\ATmega_DFP\1.2.209\avrasm\inc\m2560def.inc'
                                 
                                 .include "m2560def.inc"
                                 
                                 ;***** Created: 2011-02-09 12:03 ******* Source: ATmega2560.xml **********
                                 ;*************************************************************************
                                 ;* A P P L I C A T I O N   N O T E   F O R   T H E   A V R   F A M I L Y
                                 ;* 
                                 ;* Number            : AVR000
                                 ;* File Name         : "m2560def.inc"
                                 ;* Title             : Register/Bit Definitions for the ATmega2560
                                 ;* Date              : 2011-02-09
                                 ;* Version           : 2.35
                                 ;* Support E-mail    : avr@atmel.com
                                 ;* Target MCU        : ATmega2560
                                 ;* 
                                 ;* DESCRIPTION
                                 ;* When including this file in the assembly program file, all I/O register 
                                 ;* names and I/O register bit names appearing in the data book can be used.
                                 ;* In addition, the six registers forming the three data pointers X, Y and 
                                 ;* Z have been assigned names XL - ZH. Highest RAM address for Internal 
                                 ;* SRAM is also defined 
                                 ;* 
                                 ;* The Register names are represented by their hexadecimal address.
                                 ;* 
                                 ;* The Register Bit names are represented by their bit number (0-7).
                                 ;* 
                                 ;* Please observe the difference in using the bit names with instructions
                                 ;* such as "sbr"/"cbr" (set/clear bit in register) and "sbrs"/"sbrc"
                                 ;* (skip if bit in register set/cleared). The following example illustrates
                                 ;* this:
                                 ;* 
                                 ;* in    r16,PORTB             ;read PORTB latch
                                 ;* sbr   r16,(1<<PB6)+(1<<PB5) ;set PB6 and PB5 (use masks, not bit#)
                                 ;* out   PORTB,r16             ;output to PORTB
                                 ;* 
                                 ;* in    r16,TIFR              ;read the Timer Interrupt Flag Register
                                 ;* sbrc  r16,TOV0              ;test the overflow flag (use bit#)
                                 ;* rjmp  TOV0_is_set           ;jump if set
                                 ;* ...                         ;otherwise do something else
                                 ;*************************************************************************
                                 
                                 #ifndef _M2560DEF_INC_
                                 #define _M2560DEF_INC_
                                 
                                 
                                 #pragma partinc 0
                                 
                                 ; ***** SPECIFY DEVICE ***************************************************
                                 .device ATmega2560
                                 #pragma AVRPART ADMIN PART_NAME ATmega2560
                                 .equ	SIGNATURE_000	= 0x1e
                                 .equ	SIGNATURE_001	= 0x98
                                 .equ	SIGNATURE_002	= 0x01
                                 
                                 #pragma AVRPART CORE CORE_VERSION V3
                                 
                                 
                                 ; ***** I/O REGISTER DEFINITIONS *****************************************
                                 ; NOTE:
                                 ; Definitions marked "MEMORY MAPPED"are extended I/O ports
                                 ; and cannot be used with IN/OUT instructions
                                 .equ	UDR3	= 0x136	; MEMORY MAPPED
                                 .equ	UBRR3L	= 0x134	; MEMORY MAPPED
                                 .equ	UBRR3H	= 0x135	; MEMORY MAPPED
                                 .equ	UCSR3C	= 0x132	; MEMORY MAPPED
                                 .equ	UCSR3B	= 0x131	; MEMORY MAPPED
                                 .equ	UCSR3A	= 0x130	; MEMORY MAPPED
                                 .equ	OCR5CL	= 0x12c	; MEMORY MAPPED
                                 .equ	OCR5CH	= 0x12d	; MEMORY MAPPED
                                 .equ	OCR5BL	= 0x12a	; MEMORY MAPPED
                                 .equ	OCR5BH	= 0x12b	; MEMORY MAPPED
                                 .equ	OCR5AL	= 0x128	; MEMORY MAPPED
                                 .equ	OCR5AH	= 0x129	; MEMORY MAPPED
                                 .equ	ICR5H	= 0x127	; MEMORY MAPPED
                                 .equ	ICR5L	= 0x126	; MEMORY MAPPED
                                 .equ	TCNT5L	= 0x124	; MEMORY MAPPED
                                 .equ	TCNT5H	= 0x125	; MEMORY MAPPED
                                 .equ	TCCR5C	= 0x122	; MEMORY MAPPED
                                 .equ	TCCR5B	= 0x121	; MEMORY MAPPED
                                 .equ	TCCR5A	= 0x120	; MEMORY MAPPED
                                 .equ	PORTL	= 0x10b	; MEMORY MAPPED
                                 .equ	DDRL	= 0x10a	; MEMORY MAPPED
                                 .equ	PINL	= 0x109	; MEMORY MAPPED
                                 .equ	PORTK	= 0x108	; MEMORY MAPPED
                                 .equ	DDRK	= 0x107	; MEMORY MAPPED
                                 .equ	PINK	= 0x106	; MEMORY MAPPED
                                 .equ	PORTJ	= 0x105	; MEMORY MAPPED
                                 .equ	DDRJ	= 0x104	; MEMORY MAPPED
                                 .equ	PINJ	= 0x103	; MEMORY MAPPED
                                 .equ	PORTH	= 0x102	; MEMORY MAPPED
                                 .equ	DDRH	= 0x101	; MEMORY MAPPED
                                 .equ	PINH	= 0x100	; MEMORY MAPPED
                                 .equ	UDR2	= 0xd6	; MEMORY MAPPED
                                 .equ	UBRR2L	= 0xd4	; MEMORY MAPPED
                                 .equ	UBRR2H	= 0xd5	; MEMORY MAPPED
                                 .equ	UCSR2C	= 0xd2	; MEMORY MAPPED
                                 .equ	UCSR2B	= 0xd1	; MEMORY MAPPED
                                 .equ	UCSR2A	= 0xd0	; MEMORY MAPPED
                                 .equ	UDR1	= 0xce	; MEMORY MAPPED
                                 .equ	UBRR1L	= 0xcc	; MEMORY MAPPED
                                 .equ	UBRR1H	= 0xcd	; MEMORY MAPPED
                                 .equ	UCSR1C	= 0xca	; MEMORY MAPPED
                                 .equ	UCSR1B	= 0xc9	; MEMORY MAPPED
                                 .equ	UCSR1A	= 0xc8	; MEMORY MAPPED
                                 .equ	UDR0	= 0xc6	; MEMORY MAPPED
                                 .equ	UBRR0L	= 0xc4	; MEMORY MAPPED
                                 .equ	UBRR0H	= 0xc5	; MEMORY MAPPED
                                 .equ	UCSR0C	= 0xc2	; MEMORY MAPPED
                                 .equ	UCSR0B	= 0xc1	; MEMORY MAPPED
                                 .equ	UCSR0A	= 0xc0	; MEMORY MAPPED
                                 .equ	TWAMR	= 0xbd	; MEMORY MAPPED
                                 .equ	TWCR	= 0xbc	; MEMORY MAPPED
                                 .equ	TWDR	= 0xbb	; MEMORY MAPPED
                                 .equ	TWAR	= 0xba	; MEMORY MAPPED
                                 .equ	TWSR	= 0xb9	; MEMORY MAPPED
                                 .equ	TWBR	= 0xb8	; MEMORY MAPPED
                                 .equ	ASSR	= 0xb6	; MEMORY MAPPED
                                 .equ	OCR2B	= 0xb4	; MEMORY MAPPED
                                 .equ	OCR2A	= 0xb3	; MEMORY MAPPED
                                 .equ	TCNT2	= 0xb2	; MEMORY MAPPED
                                 .equ	TCCR2B	= 0xb1	; MEMORY MAPPED
                                 .equ	TCCR2A	= 0xb0	; MEMORY MAPPED
                                 .equ	OCR4CL	= 0xac	; MEMORY MAPPED
                                 .equ	OCR4CH	= 0xad	; MEMORY MAPPED
                                 .equ	OCR4BL	= 0xaa	; MEMORY MAPPED
                                 .equ	OCR4BH	= 0xab	; MEMORY MAPPED
                                 .equ	OCR4AL	= 0xa8	; MEMORY MAPPED
                                 .equ	OCR4AH	= 0xa9	; MEMORY MAPPED
                                 .equ	ICR4L	= 0xa6	; MEMORY MAPPED
                                 .equ	ICR4H	= 0xa7	; MEMORY MAPPED
                                 .equ	TCNT4L	= 0xa4	; MEMORY MAPPED
                                 .equ	TCNT4H	= 0xa5	; MEMORY MAPPED
                                 .equ	TCCR4C	= 0xa2	; MEMORY MAPPED
                                 .equ	TCCR4B	= 0xa1	; MEMORY MAPPED
                                 .equ	TCCR4A	= 0xa0	; MEMORY MAPPED
                                 .equ	OCR3CL	= 0x9c	; MEMORY MAPPED
                                 .equ	OCR3CH	= 0x9d	; MEMORY MAPPED
                                 .equ	OCR3BL	= 0x9a	; MEMORY MAPPED
                                 .equ	OCR3BH	= 0x9b	; MEMORY MAPPED
                                 .equ	OCR3AL	= 0x98	; MEMORY MAPPED
                                 .equ	OCR3AH	= 0x99	; MEMORY MAPPED
                                 .equ	ICR3L	= 0x96	; MEMORY MAPPED
                                 .equ	ICR3H	= 0x97	; MEMORY MAPPED
                                 .equ	TCNT3L	= 0x94	; MEMORY MAPPED
                                 .equ	TCNT3H	= 0x95	; MEMORY MAPPED
                                 .equ	TCCR3C	= 0x92	; MEMORY MAPPED
                                 .equ	TCCR3B	= 0x91	; MEMORY MAPPED
                                 .equ	TCCR3A	= 0x90	; MEMORY MAPPED
                                 .equ	OCR1CL	= 0x8c	; MEMORY MAPPED
                                 .equ	OCR1CH	= 0x8d	; MEMORY MAPPED
                                 .equ	OCR1BL	= 0x8a	; MEMORY MAPPED
                                 .equ	OCR1BH	= 0x8b	; MEMORY MAPPED
                                 .equ	OCR1AL	= 0x88	; MEMORY MAPPED
                                 .equ	OCR1AH	= 0x89	; MEMORY MAPPED
                                 .equ	ICR1L	= 0x86	; MEMORY MAPPED
                                 .equ	ICR1H	= 0x87	; MEMORY MAPPED
                                 .equ	TCNT1L	= 0x84	; MEMORY MAPPED
                                 .equ	TCNT1H	= 0x85	; MEMORY MAPPED
                                 .equ	TCCR1C	= 0x82	; MEMORY MAPPED
                                 .equ	TCCR1B	= 0x81	; MEMORY MAPPED
                                 .equ	TCCR1A	= 0x80	; MEMORY MAPPED
                                 .equ	DIDR1	= 0x7f	; MEMORY MAPPED
                                 .equ	DIDR0	= 0x7e	; MEMORY MAPPED
                                 .equ	DIDR2	= 0x7d	; MEMORY MAPPED
                                 .equ	ADMUX	= 0x7c	; MEMORY MAPPED
                                 .equ	ADCSRB	= 0x7b	; MEMORY MAPPED
                                 .equ	ADCSRA	= 0x7a	; MEMORY MAPPED
                                 .equ	ADCH	= 0x79	; MEMORY MAPPED
                                 .equ	ADCL	= 0x78	; MEMORY MAPPED
                                 .equ	XMCRB	= 0x75	; MEMORY MAPPED
                                 .equ	XMCRA	= 0x74	; MEMORY MAPPED
                                 .equ	TIMSK5	= 0x73	; MEMORY MAPPED
                                 .equ	TIMSK4	= 0x72	; MEMORY MAPPED
                                 .equ	TIMSK3	= 0x71	; MEMORY MAPPED
                                 .equ	TIMSK2	= 0x70	; MEMORY MAPPED
                                 .equ	TIMSK1	= 0x6f	; MEMORY MAPPED
                                 .equ	TIMSK0	= 0x6e	; MEMORY MAPPED
                                 .equ	PCMSK2	= 0x6d	; MEMORY MAPPED
                                 .equ	PCMSK1	= 0x6c	; MEMORY MAPPED
                                 .equ	PCMSK0	= 0x6b	; MEMORY MAPPED
                                 .equ	EICRB	= 0x6a	; MEMORY MAPPED
                                 .equ	EICRA	= 0x69	; MEMORY MAPPED
                                 .equ	PCICR	= 0x68	; MEMORY MAPPED
                                 .equ	OSCCAL	= 0x66	; MEMORY MAPPED
                                 .equ	PRR1	= 0x65	; MEMORY MAPPED
                                 .equ	PRR0	= 0x64	; MEMORY MAPPED
                                 .equ	CLKPR	= 0x61	; MEMORY MAPPED
                                 .equ	WDTCSR	= 0x60	; MEMORY MAPPED
                                 .equ	SREG	= 0x3f
                                 .equ	SPL	= 0x3d
                                 .equ	SPH	= 0x3e
                                 .equ	EIND	= 0x3c
                                 .equ	RAMPZ	= 0x3b
                                 .equ	SPMCSR	= 0x37
                                 .equ	MCUCR	= 0x35
                                 .equ	MCUSR	= 0x34
                                 .equ	SMCR	= 0x33
                                 .equ	OCDR	= 0x31
                                 .equ	ACSR	= 0x30
                                 .equ	SPDR	= 0x2e
                                 .equ	SPSR	= 0x2d
                                 .equ	SPCR	= 0x2c
                                 .equ	GPIOR2	= 0x2b
                                 .equ	GPIOR1	= 0x2a
                                 .equ	OCR0B	= 0x28
                                 .equ	OCR0A	= 0x27
                                 .equ	TCNT0	= 0x26
                                 .equ	TCCR0B	= 0x25
                                 .equ	TCCR0A	= 0x24
                                 .equ	GTCCR	= 0x23
                                 .equ	EEARH	= 0x22
                                 .equ	EEARL	= 0x21
                                 .equ	EEDR	= 0x20
                                 .equ	EECR	= 0x1f
                                 .equ	GPIOR0	= 0x1e
                                 .equ	EIMSK	= 0x1d
                                 .equ	EIFR	= 0x1c
                                 .equ	PCIFR	= 0x1b
                                 .equ	TIFR5	= 0x1a
                                 .equ	TIFR4	= 0x19
                                 .equ	TIFR3	= 0x18
                                 .equ	TIFR2	= 0x17
                                 .equ	TIFR1	= 0x16
                                 .equ	TIFR0	= 0x15
                                 .equ	PORTG	= 0x14
                                 .equ	DDRG	= 0x13
                                 .equ	PING	= 0x12
                                 .equ	PORTF	= 0x11
                                 .equ	DDRF	= 0x10
                                 .equ	PINF	= 0x0f
                                 .equ	PORTE	= 0x0e
                                 .equ	DDRE	= 0x0d
                                 .equ	PINE	= 0x0c
                                 .equ	PORTD	= 0x0b
                                 .equ	DDRD	= 0x0a
                                 .equ	PIND	= 0x09
                                 .equ	PORTC	= 0x08
                                 .equ	DDRC	= 0x07
                                 .equ	PINC	= 0x06
                                 .equ	PORTB	= 0x05
                                 .equ	DDRB	= 0x04
                                 .equ	PINB	= 0x03
                                 .equ	PORTA	= 0x02
                                 .equ	DDRA	= 0x01
                                 .equ	PINA	= 0x00
                                 
                                 
                                 ; ***** BIT DEFINITIONS **************************************************
                                 
                                 ; ***** ANALOG_COMPARATOR ************
                                 ; ADCSRB - ADC Control and Status Register B
                                 .equ	ACME	= 6	; Analog Comparator Multiplexer Enable
                                 
                                 ; ACSR - Analog Comparator Control And Status Register
                                 .equ	ACIS0	= 0	; Analog Comparator Interrupt Mode Select bit 0
                                 .equ	ACIS1	= 1	; Analog Comparator Interrupt Mode Select bit 1
                                 .equ	ACIC	= 2	; Analog Comparator Input Capture Enable
                                 .equ	ACIE	= 3	; Analog Comparator Interrupt Enable
                                 .equ	ACI	= 4	; Analog Comparator Interrupt Flag
                                 .equ	ACO	= 5	; Analog Compare Output
                                 .equ	ACBG	= 6	; Analog Comparator Bandgap Select
                                 .equ	ACD	= 7	; Analog Comparator Disable
                                 
                                 ; DIDR1 - Digital Input Disable Register 1
                                 .equ	AIN0D	= 0	; AIN0 Digital Input Disable
                                 .equ	AIN1D	= 1	; AIN1 Digital Input Disable
                                 
                                 
                                 ; ***** USART0 ***********************
                                 ; UDR0 - USART I/O Data Register
                                 .equ	UDR0_0	= 0	; USART I/O Data Register bit 0
                                 .equ	UDR0_1	= 1	; USART I/O Data Register bit 1
                                 .equ	UDR0_2	= 2	; USART I/O Data Register bit 2
                                 .equ	UDR0_3	= 3	; USART I/O Data Register bit 3
                                 .equ	UDR0_4	= 4	; USART I/O Data Register bit 4
                                 .equ	UDR0_5	= 5	; USART I/O Data Register bit 5
                                 .equ	UDR0_6	= 6	; USART I/O Data Register bit 6
                                 .equ	UDR0_7	= 7	; USART I/O Data Register bit 7
                                 
                                 ; UCSR0A - USART Control and Status Register A
                                 .equ	MPCM0	= 0	; Multi-processor Communication Mode
                                 .equ	U2X0	= 1	; Double the USART transmission speed
                                 .equ	UPE0	= 2	; Parity Error
                                 .equ	DOR0	= 3	; Data overRun
                                 .equ	FE0	= 4	; Framing Error
                                 .equ	UDRE0	= 5	; USART Data Register Empty
                                 .equ	TXC0	= 6	; USART Transmitt Complete
                                 .equ	RXC0	= 7	; USART Receive Complete
                                 
                                 ; UCSR0B - USART Control and Status Register B
                                 .equ	TXB80	= 0	; Transmit Data Bit 8
                                 .equ	RXB80	= 1	; Receive Data Bit 8
                                 .equ	UCSZ02	= 2	; Character Size
                                 .equ	TXEN0	= 3	; Transmitter Enable
                                 .equ	RXEN0	= 4	; Receiver Enable
                                 .equ	UDRIE0	= 5	; USART Data register Empty Interrupt Enable
                                 .equ	TXCIE0	= 6	; TX Complete Interrupt Enable
                                 .equ	RXCIE0	= 7	; RX Complete Interrupt Enable
                                 
                                 ; UCSR0C - USART Control and Status Register C
                                 .equ	UCPOL0	= 0	; Clock Polarity
                                 .equ	UCSZ00	= 1	; Character Size
                                 .equ	UCPHA0	= UCSZ00	; For compatibility
                                 .equ	UCSZ01	= 2	; Character Size
                                 .equ	UDORD0	= UCSZ01	; For compatibility
                                 .equ	USBS0	= 3	; Stop Bit Select
                                 .equ	UPM00	= 4	; Parity Mode Bit 0
                                 .equ	UPM01	= 5	; Parity Mode Bit 1
                                 .equ	UMSEL00	= 6	; USART Mode Select
                                 .equ	UMSEL0	= UMSEL00	; For compatibility
                                 .equ	UMSEL01	= 7	; USART Mode Select
                                 .equ	UMSEL1	= UMSEL01	; For compatibility
                                 
                                 ; UBRR0H - USART Baud Rate Register High Byte
                                 .equ	UBRR8	= 0	; USART Baud Rate Register bit 8
                                 .equ	UBRR9	= 1	; USART Baud Rate Register bit 9
                                 .equ	UBRR10	= 2	; USART Baud Rate Register bit 10
                                 .equ	UBRR11	= 3	; USART Baud Rate Register bit 11
                                 
                                 ; UBRR0L - USART Baud Rate Register Low Byte
                                 .equ	_UBRR0	= 0	; USART Baud Rate Register bit 0
                                 .equ	_UBRR1	= 1	; USART Baud Rate Register bit 1
                                 .equ	UBRR2	= 2	; USART Baud Rate Register bit 2
                                 .equ	UBRR3	= 3	; USART Baud Rate Register bit 3
                                 .equ	UBRR4	= 4	; USART Baud Rate Register bit 4
                                 .equ	UBRR5	= 5	; USART Baud Rate Register bit 5
                                 .equ	UBRR6	= 6	; USART Baud Rate Register bit 6
                                 .equ	UBRR7	= 7	; USART Baud Rate Register bit 7
                                 
                                 
                                 ; ***** TWI **************************
                                 ; TWAMR - TWI (Slave) Address Mask Register
                                 .equ	TWAM0	= 1	; 
                                 .equ	TWAMR0	= TWAM0	; For compatibility
                                 .equ	TWAM1	= 2	; 
                                 .equ	TWAMR1	= TWAM1	; For compatibility
                                 .equ	TWAM2	= 3	; 
                                 .equ	TWAMR2	= TWAM2	; For compatibility
                                 .equ	TWAM3	= 4	; 
                                 .equ	TWAMR3	= TWAM3	; For compatibility
                                 .equ	TWAM4	= 5	; 
                                 .equ	TWAMR4	= TWAM4	; For compatibility
                                 .equ	TWAM5	= 6	; 
                                 .equ	TWAMR5	= TWAM5	; For compatibility
                                 .equ	TWAM6	= 7	; 
                                 .equ	TWAMR6	= TWAM6	; For compatibility
                                 
                                 ; TWBR - TWI Bit Rate register
                                 .equ	TWBR0	= 0	; 
                                 .equ	TWBR1	= 1	; 
                                 .equ	TWBR2	= 2	; 
                                 .equ	TWBR3	= 3	; 
                                 .equ	TWBR4	= 4	; 
                                 .equ	TWBR5	= 5	; 
                                 .equ	TWBR6	= 6	; 
                                 .equ	TWBR7	= 7	; 
                                 
                                 ; TWCR - TWI Control Register
                                 .equ	TWIE	= 0	; TWI Interrupt Enable
                                 .equ	TWEN	= 2	; TWI Enable Bit
                                 .equ	TWWC	= 3	; TWI Write Collition Flag
                                 .equ	TWSTO	= 4	; TWI Stop Condition Bit
                                 .equ	TWSTA	= 5	; TWI Start Condition Bit
                                 .equ	TWEA	= 6	; TWI Enable Acknowledge Bit
                                 .equ	TWINT	= 7	; TWI Interrupt Flag
                                 
                                 ; TWSR - TWI Status Register
                                 .equ	TWPS0	= 0	; TWI Prescaler
                                 .equ	TWPS1	= 1	; TWI Prescaler
                                 .equ	TWS3	= 3	; TWI Status
                                 .equ	TWS4	= 4	; TWI Status
                                 .equ	TWS5	= 5	; TWI Status
                                 .equ	TWS6	= 6	; TWI Status
                                 .equ	TWS7	= 7	; TWI Status
                                 
                                 ; TWDR - TWI Data register
                                 .equ	TWD0	= 0	; TWI Data Register Bit 0
                                 .equ	TWD1	= 1	; TWI Data Register Bit 1
                                 .equ	TWD2	= 2	; TWI Data Register Bit 2
                                 .equ	TWD3	= 3	; TWI Data Register Bit 3
                                 .equ	TWD4	= 4	; TWI Data Register Bit 4
                                 .equ	TWD5	= 5	; TWI Data Register Bit 5
                                 .equ	TWD6	= 6	; TWI Data Register Bit 6
                                 .equ	TWD7	= 7	; TWI Data Register Bit 7
                                 
                                 ; TWAR - TWI (Slave) Address register
                                 .equ	TWGCE	= 0	; TWI General Call Recognition Enable Bit
                                 .equ	TWA0	= 1	; TWI (Slave) Address register Bit 0
                                 .equ	TWA1	= 2	; TWI (Slave) Address register Bit 1
                                 .equ	TWA2	= 3	; TWI (Slave) Address register Bit 2
                                 .equ	TWA3	= 4	; TWI (Slave) Address register Bit 3
                                 .equ	TWA4	= 5	; TWI (Slave) Address register Bit 4
                                 .equ	TWA5	= 6	; TWI (Slave) Address register Bit 5
                                 .equ	TWA6	= 7	; TWI (Slave) Address register Bit 6
                                 
                                 
                                 ; ***** SPI **************************
                                 ; SPDR - SPI Data Register
                                 .equ	SPDR0	= 0	; SPI Data Register bit 0
                                 .equ	SPDR1	= 1	; SPI Data Register bit 1
                                 .equ	SPDR2	= 2	; SPI Data Register bit 2
                                 .equ	SPDR3	= 3	; SPI Data Register bit 3
                                 .equ	SPDR4	= 4	; SPI Data Register bit 4
                                 .equ	SPDR5	= 5	; SPI Data Register bit 5
                                 .equ	SPDR6	= 6	; SPI Data Register bit 6
                                 .equ	SPDR7	= 7	; SPI Data Register bit 7
                                 
                                 ; SPSR - SPI Status Register
                                 .equ	SPI2X	= 0	; Double SPI Speed Bit
                                 .equ	WCOL	= 6	; Write Collision Flag
                                 .equ	SPIF	= 7	; SPI Interrupt Flag
                                 
                                 ; SPCR - SPI Control Register
                                 .equ	SPR0	= 0	; SPI Clock Rate Select 0
                                 .equ	SPR1	= 1	; SPI Clock Rate Select 1
                                 .equ	CPHA	= 2	; Clock Phase
                                 .equ	CPOL	= 3	; Clock polarity
                                 .equ	MSTR	= 4	; Master/Slave Select
                                 .equ	DORD	= 5	; Data Order
                                 .equ	SPE	= 6	; SPI Enable
                                 .equ	SPIE	= 7	; SPI Interrupt Enable
                                 
                                 
                                 ; ***** PORTA ************************
                                 ; PORTA - Port A Data Register
                                 .equ	PORTA0	= 0	; Port A Data Register bit 0
                                 .equ	PA0	= 0	; For compatibility
                                 .equ	PORTA1	= 1	; Port A Data Register bit 1
                                 .equ	PA1	= 1	; For compatibility
                                 .equ	PORTA2	= 2	; Port A Data Register bit 2
                                 .equ	PA2	= 2	; For compatibility
                                 .equ	PORTA3	= 3	; Port A Data Register bit 3
                                 .equ	PA3	= 3	; For compatibility
                                 .equ	PORTA4	= 4	; Port A Data Register bit 4
                                 .equ	PA4	= 4	; For compatibility
                                 .equ	PORTA5	= 5	; Port A Data Register bit 5
                                 .equ	PA5	= 5	; For compatibility
                                 .equ	PORTA6	= 6	; Port A Data Register bit 6
                                 .equ	PA6	= 6	; For compatibility
                                 .equ	PORTA7	= 7	; Port A Data Register bit 7
                                 .equ	PA7	= 7	; For compatibility
                                 
                                 ; DDRA - Port A Data Direction Register
                                 .equ	DDA0	= 0	; Data Direction Register, Port A, bit 0
                                 .equ	DDA1	= 1	; Data Direction Register, Port A, bit 1
                                 .equ	DDA2	= 2	; Data Direction Register, Port A, bit 2
                                 .equ	DDA3	= 3	; Data Direction Register, Port A, bit 3
                                 .equ	DDA4	= 4	; Data Direction Register, Port A, bit 4
                                 .equ	DDA5	= 5	; Data Direction Register, Port A, bit 5
                                 .equ	DDA6	= 6	; Data Direction Register, Port A, bit 6
                                 .equ	DDA7	= 7	; Data Direction Register, Port A, bit 7
                                 
                                 ; PINA - Port A Input Pins
                                 .equ	PINA0	= 0	; Input Pins, Port A bit 0
                                 .equ	PINA1	= 1	; Input Pins, Port A bit 1
                                 .equ	PINA2	= 2	; Input Pins, Port A bit 2
                                 .equ	PINA3	= 3	; Input Pins, Port A bit 3
                                 .equ	PINA4	= 4	; Input Pins, Port A bit 4
                                 .equ	PINA5	= 5	; Input Pins, Port A bit 5
                                 .equ	PINA6	= 6	; Input Pins, Port A bit 6
                                 .equ	PINA7	= 7	; Input Pins, Port A bit 7
                                 
                                 
                                 ; ***** PORTB ************************
                                 ; PORTB - Port B Data Register
                                 .equ	PORTB0	= 0	; Port B Data Register bit 0
                                 .equ	PB0	= 0	; For compatibility
                                 .equ	PORTB1	= 1	; Port B Data Register bit 1
                                 .equ	PB1	= 1	; For compatibility
                                 .equ	PORTB2	= 2	; Port B Data Register bit 2
                                 .equ	PB2	= 2	; For compatibility
                                 .equ	PORTB3	= 3	; Port B Data Register bit 3
                                 .equ	PB3	= 3	; For compatibility
                                 .equ	PORTB4	= 4	; Port B Data Register bit 4
                                 .equ	PB4	= 4	; For compatibility
                                 .equ	PORTB5	= 5	; Port B Data Register bit 5
                                 .equ	PB5	= 5	; For compatibility
                                 .equ	PORTB6	= 6	; Port B Data Register bit 6
                                 .equ	PB6	= 6	; For compatibility
                                 .equ	PORTB7	= 7	; Port B Data Register bit 7
                                 .equ	PB7	= 7	; For compatibility
                                 
                                 ; DDRB - Port B Data Direction Register
                                 .equ	DDB0	= 0	; Port B Data Direction Register bit 0
                                 .equ	DDB1	= 1	; Port B Data Direction Register bit 1
                                 .equ	DDB2	= 2	; Port B Data Direction Register bit 2
                                 .equ	DDB3	= 3	; Port B Data Direction Register bit 3
                                 .equ	DDB4	= 4	; Port B Data Direction Register bit 4
                                 .equ	DDB5	= 5	; Port B Data Direction Register bit 5
                                 .equ	DDB6	= 6	; Port B Data Direction Register bit 6
                                 .equ	DDB7	= 7	; Port B Data Direction Register bit 7
                                 
                                 ; PINB - Port B Input Pins
                                 .equ	PINB0	= 0	; Port B Input Pins bit 0
                                 .equ	PINB1	= 1	; Port B Input Pins bit 1
                                 .equ	PINB2	= 2	; Port B Input Pins bit 2
                                 .equ	PINB3	= 3	; Port B Input Pins bit 3
                                 .equ	PINB4	= 4	; Port B Input Pins bit 4
                                 .equ	PINB5	= 5	; Port B Input Pins bit 5
                                 .equ	PINB6	= 6	; Port B Input Pins bit 6
                                 .equ	PINB7	= 7	; Port B Input Pins bit 7
                                 
                                 
                                 ; ***** PORTC ************************
                                 ; PORTC - Port C Data Register
                                 .equ	PORTC0	= 0	; Port C Data Register bit 0
                                 .equ	PC0	= 0	; For compatibility
                                 .equ	PORTC1	= 1	; Port C Data Register bit 1
                                 .equ	PC1	= 1	; For compatibility
                                 .equ	PORTC2	= 2	; Port C Data Register bit 2
                                 .equ	PC2	= 2	; For compatibility
                                 .equ	PORTC3	= 3	; Port C Data Register bit 3
                                 .equ	PC3	= 3	; For compatibility
                                 .equ	PORTC4	= 4	; Port C Data Register bit 4
                                 .equ	PC4	= 4	; For compatibility
                                 .equ	PORTC5	= 5	; Port C Data Register bit 5
                                 .equ	PC5	= 5	; For compatibility
                                 .equ	PORTC6	= 6	; Port C Data Register bit 6
                                 .equ	PC6	= 6	; For compatibility
                                 .equ	PORTC7	= 7	; Port C Data Register bit 7
                                 .equ	PC7	= 7	; For compatibility
                                 
                                 ; DDRC - Port C Data Direction Register
                                 .equ	DDC0	= 0	; Port C Data Direction Register bit 0
                                 .equ	DDC1	= 1	; Port C Data Direction Register bit 1
                                 .equ	DDC2	= 2	; Port C Data Direction Register bit 2
                                 .equ	DDC3	= 3	; Port C Data Direction Register bit 3
                                 .equ	DDC4	= 4	; Port C Data Direction Register bit 4
                                 .equ	DDC5	= 5	; Port C Data Direction Register bit 5
                                 .equ	DDC6	= 6	; Port C Data Direction Register bit 6
                                 .equ	DDC7	= 7	; Port C Data Direction Register bit 7
                                 
                                 ; PINC - Port C Input Pins
                                 .equ	PINC0	= 0	; Port C Input Pins bit 0
                                 .equ	PINC1	= 1	; Port C Input Pins bit 1
                                 .equ	PINC2	= 2	; Port C Input Pins bit 2
                                 .equ	PINC3	= 3	; Port C Input Pins bit 3
                                 .equ	PINC4	= 4	; Port C Input Pins bit 4
                                 .equ	PINC5	= 5	; Port C Input Pins bit 5
                                 .equ	PINC6	= 6	; Port C Input Pins bit 6
                                 .equ	PINC7	= 7	; Port C Input Pins bit 7
                                 
                                 
                                 ; ***** PORTD ************************
                                 ; PORTD - Port D Data Register
                                 .equ	PORTD0	= 0	; Port D Data Register bit 0
                                 .equ	PD0	= 0	; For compatibility
                                 .equ	PORTD1	= 1	; Port D Data Register bit 1
                                 .equ	PD1	= 1	; For compatibility
                                 .equ	PORTD2	= 2	; Port D Data Register bit 2
                                 .equ	PD2	= 2	; For compatibility
                                 .equ	PORTD3	= 3	; Port D Data Register bit 3
                                 .equ	PD3	= 3	; For compatibility
                                 .equ	PORTD4	= 4	; Port D Data Register bit 4
                                 .equ	PD4	= 4	; For compatibility
                                 .equ	PORTD5	= 5	; Port D Data Register bit 5
                                 .equ	PD5	= 5	; For compatibility
                                 .equ	PORTD6	= 6	; Port D Data Register bit 6
                                 .equ	PD6	= 6	; For compatibility
                                 .equ	PORTD7	= 7	; Port D Data Register bit 7
                                 .equ	PD7	= 7	; For compatibility
                                 
                                 ; DDRD - Port D Data Direction Register
                                 .equ	DDD0	= 0	; Port D Data Direction Register bit 0
                                 .equ	DDD1	= 1	; Port D Data Direction Register bit 1
                                 .equ	DDD2	= 2	; Port D Data Direction Register bit 2
                                 .equ	DDD3	= 3	; Port D Data Direction Register bit 3
                                 .equ	DDD4	= 4	; Port D Data Direction Register bit 4
                                 .equ	DDD5	= 5	; Port D Data Direction Register bit 5
                                 .equ	DDD6	= 6	; Port D Data Direction Register bit 6
                                 .equ	DDD7	= 7	; Port D Data Direction Register bit 7
                                 
                                 ; PIND - Port D Input Pins
                                 .equ	PIND0	= 0	; Port D Input Pins bit 0
                                 .equ	PIND1	= 1	; Port D Input Pins bit 1
                                 .equ	PIND2	= 2	; Port D Input Pins bit 2
                                 .equ	PIND3	= 3	; Port D Input Pins bit 3
                                 .equ	PIND4	= 4	; Port D Input Pins bit 4
                                 .equ	PIND5	= 5	; Port D Input Pins bit 5
                                 .equ	PIND6	= 6	; Port D Input Pins bit 6
                                 .equ	PIND7	= 7	; Port D Input Pins bit 7
                                 
                                 
                                 ; ***** PORTE ************************
                                 ; PORTE - Data Register, Port E
                                 .equ	PORTE0	= 0	; 
                                 .equ	PE0	= 0	; For compatibility
                                 .equ	PORTE1	= 1	; 
                                 .equ	PE1	= 1	; For compatibility
                                 .equ	PORTE2	= 2	; 
                                 .equ	PE2	= 2	; For compatibility
                                 .equ	PORTE3	= 3	; 
                                 .equ	PE3	= 3	; For compatibility
                                 .equ	PORTE4	= 4	; 
                                 .equ	PE4	= 4	; For compatibility
                                 .equ	PORTE5	= 5	; 
                                 .equ	PE5	= 5	; For compatibility
                                 .equ	PORTE6	= 6	; 
                                 .equ	PE6	= 6	; For compatibility
                                 .equ	PORTE7	= 7	; 
                                 .equ	PE7	= 7	; For compatibility
                                 
                                 ; DDRE - Data Direction Register, Port E
                                 .equ	DDE0	= 0	; 
                                 .equ	DDE1	= 1	; 
                                 .equ	DDE2	= 2	; 
                                 .equ	DDE3	= 3	; 
                                 .equ	DDE4	= 4	; 
                                 .equ	DDE5	= 5	; 
                                 .equ	DDE6	= 6	; 
                                 .equ	DDE7	= 7	; 
                                 
                                 ; PINE - Input Pins, Port E
                                 .equ	PINE0	= 0	; 
                                 .equ	PINE1	= 1	; 
                                 .equ	PINE2	= 2	; 
                                 .equ	PINE3	= 3	; 
                                 .equ	PINE4	= 4	; 
                                 .equ	PINE5	= 5	; 
                                 .equ	PINE6	= 6	; 
                                 .equ	PINE7	= 7	; 
                                 
                                 
                                 ; ***** PORTF ************************
                                 ; PORTF - Data Register, Port F
                                 .equ	PORTF0	= 0	; 
                                 .equ	PF0	= 0	; For compatibility
                                 .equ	PORTF1	= 1	; 
                                 .equ	PF1	= 1	; For compatibility
                                 .equ	PORTF2	= 2	; 
                                 .equ	PF2	= 2	; For compatibility
                                 .equ	PORTF3	= 3	; 
                                 .equ	PF3	= 3	; For compatibility
                                 .equ	PORTF4	= 4	; 
                                 .equ	PF4	= 4	; For compatibility
                                 .equ	PORTF5	= 5	; 
                                 .equ	PF5	= 5	; For compatibility
                                 .equ	PORTF6	= 6	; 
                                 .equ	PF6	= 6	; For compatibility
                                 .equ	PORTF7	= 7	; 
                                 .equ	PF7	= 7	; For compatibility
                                 
                                 ; DDRF - Data Direction Register, Port F
                                 .equ	DDF0	= 0	; 
                                 .equ	DDF1	= 1	; 
                                 .equ	DDF2	= 2	; 
                                 .equ	DDF3	= 3	; 
                                 .equ	DDF4	= 4	; 
                                 .equ	DDF5	= 5	; 
                                 .equ	DDF6	= 6	; 
                                 .equ	DDF7	= 7	; 
                                 
                                 ; PINF - Input Pins, Port F
                                 .equ	PINF0	= 0	; 
                                 .equ	PINF1	= 1	; 
                                 .equ	PINF2	= 2	; 
                                 .equ	PINF3	= 3	; 
                                 .equ	PINF4	= 4	; 
                                 .equ	PINF5	= 5	; 
                                 .equ	PINF6	= 6	; 
                                 .equ	PINF7	= 7	; 
                                 
                                 
                                 ; ***** PORTG ************************
                                 ; PORTG - Data Register, Port G
                                 .equ	PORTG0	= 0	; 
                                 .equ	PG0	= 0	; For compatibility
                                 .equ	PORTG1	= 1	; 
                                 .equ	PG1	= 1	; For compatibility
                                 .equ	PORTG2	= 2	; 
                                 .equ	PG2	= 2	; For compatibility
                                 .equ	PORTG3	= 3	; 
                                 .equ	PG3	= 3	; For compatibility
                                 .equ	PORTG4	= 4	; 
                                 .equ	PG4	= 4	; For compatibility
                                 .equ	PORTG5	= 5	; 
                                 .equ	PG5	= 5	; For compatibility
                                 
                                 ; DDRG - Data Direction Register, Port G
                                 .equ	DDG0	= 0	; 
                                 .equ	DDG1	= 1	; 
                                 .equ	DDG2	= 2	; 
                                 .equ	DDG3	= 3	; 
                                 .equ	DDG4	= 4	; 
                                 .equ	DDG5	= 5	; 
                                 
                                 ; PING - Input Pins, Port G
                                 .equ	PING0	= 0	; 
                                 .equ	PING1	= 1	; 
                                 .equ	PING2	= 2	; 
                                 .equ	PING3	= 3	; 
                                 .equ	PING4	= 4	; 
                                 .equ	PING5	= 5	; 
                                 
                                 
                                 ; ***** PORTH ************************
                                 ; PORTH - PORT H Data Register
                                 .equ	PORTH0	= 0	; PORT H Data Register bit 0
                                 .equ	PH0	= 0	; For compatibility
                                 .equ	PORTH1	= 1	; PORT H Data Register bit 1
                                 .equ	PH1	= 1	; For compatibility
                                 .equ	PORTH2	= 2	; PORT H Data Register bit 2
                                 .equ	PH2	= 2	; For compatibility
                                 .equ	PORTH3	= 3	; PORT H Data Register bit 3
                                 .equ	PH3	= 3	; For compatibility
                                 .equ	PORTH4	= 4	; PORT H Data Register bit 4
                                 .equ	PH4	= 4	; For compatibility
                                 .equ	PORTH5	= 5	; PORT H Data Register bit 5
                                 .equ	PH5	= 5	; For compatibility
                                 .equ	PORTH6	= 6	; PORT H Data Register bit 6
                                 .equ	PH6	= 6	; For compatibility
                                 .equ	PORTH7	= 7	; PORT H Data Register bit 7
                                 .equ	PH7	= 7	; For compatibility
                                 
                                 ; DDRH - PORT H Data Direction Register
                                 .equ	DDH0	= 0	; PORT H Data Direction Register bit 0
                                 .equ	DDH1	= 1	; PORT H Data Direction Register bit 1
                                 .equ	DDH2	= 2	; PORT H Data Direction Register bit 2
                                 .equ	DDH3	= 3	; PORT H Data Direction Register bit 3
                                 .equ	DDH4	= 4	; PORT H Data Direction Register bit 4
                                 .equ	DDH5	= 5	; PORT H Data Direction Register bit 5
                                 .equ	DDH6	= 6	; PORT H Data Direction Register bit 6
                                 .equ	DDH7	= 7	; PORT H Data Direction Register bit 7
                                 
                                 ; PINH - PORT H Input Pins
                                 .equ	PINH0	= 0	; PORT H Input Pins bit 0
                                 .equ	PINH1	= 1	; PORT H Input Pins bit 1
                                 .equ	PINH2	= 2	; PORT H Input Pins bit 2
                                 .equ	PINH3	= 3	; PORT H Input Pins bit 3
                                 .equ	PINH4	= 4	; PORT H Input Pins bit 4
                                 .equ	PINH5	= 5	; PORT H Input Pins bit 5
                                 .equ	PINH6	= 6	; PORT H Input Pins bit 6
                                 .equ	PINH7	= 7	; PORT H Input Pins bit 7
                                 
                                 
                                 ; ***** PORTJ ************************
                                 ; PORTJ - PORT J Data Register
                                 .equ	PORTJ0	= 0	; PORT J Data Register bit 0
                                 .equ	PJ0	= 0	; For compatibility
                                 .equ	PORTJ1	= 1	; PORT J Data Register bit 1
                                 .equ	PJ1	= 1	; For compatibility
                                 .equ	PORTJ2	= 2	; PORT J Data Register bit 2
                                 .equ	PJ2	= 2	; For compatibility
                                 .equ	PORTJ3	= 3	; PORT J Data Register bit 3
                                 .equ	PJ3	= 3	; For compatibility
                                 .equ	PORTJ4	= 4	; PORT J Data Register bit 4
                                 .equ	PJ4	= 4	; For compatibility
                                 .equ	PORTJ5	= 5	; PORT J Data Register bit 5
                                 .equ	PJ5	= 5	; For compatibility
                                 .equ	PORTJ6	= 6	; PORT J Data Register bit 6
                                 .equ	PJ6	= 6	; For compatibility
                                 .equ	PORTJ7	= 7	; PORT J Data Register bit 7
                                 .equ	PJ7	= 7	; For compatibility
                                 
                                 ; DDRJ - PORT J Data Direction Register
                                 .equ	DDJ0	= 0	; PORT J Data Direction Register bit 0
                                 .equ	DDJ1	= 1	; PORT J Data Direction Register bit 1
                                 .equ	DDJ2	= 2	; PORT J Data Direction Register bit 2
                                 .equ	DDJ3	= 3	; PORT J Data Direction Register bit 3
                                 .equ	DDJ4	= 4	; PORT J Data Direction Register bit 4
                                 .equ	DDJ5	= 5	; PORT J Data Direction Register bit 5
                                 .equ	DDJ6	= 6	; PORT J Data Direction Register bit 6
                                 .equ	DDJ7	= 7	; PORT J Data Direction Register bit 7
                                 
                                 ; PINJ - PORT J Input Pins
                                 .equ	PINJ0	= 0	; PORT J Input Pins bit 0
                                 .equ	PINJ1	= 1	; PORT J Input Pins bit 1
                                 .equ	PINJ2	= 2	; PORT J Input Pins bit 2
                                 .equ	PINJ3	= 3	; PORT J Input Pins bit 3
                                 .equ	PINJ4	= 4	; PORT J Input Pins bit 4
                                 .equ	PINJ5	= 5	; PORT J Input Pins bit 5
                                 .equ	PINJ6	= 6	; PORT J Input Pins bit 6
                                 .equ	PINJ7	= 7	; PORT J Input Pins bit 7
                                 
                                 
                                 ; ***** PORTK ************************
                                 ; PORTK - PORT K Data Register
                                 .equ	PORTK0	= 0	; PORT K Data Register bit 0
                                 .equ	PK0	= 0	; For compatibility
                                 .equ	PORTK1	= 1	; PORT K Data Register bit 1
                                 .equ	PK1	= 1	; For compatibility
                                 .equ	PORTK2	= 2	; PORT K Data Register bit 2
                                 .equ	PK2	= 2	; For compatibility
                                 .equ	PORTK3	= 3	; PORT K Data Register bit 3
                                 .equ	PK3	= 3	; For compatibility
                                 .equ	PORTK4	= 4	; PORT K Data Register bit 4
                                 .equ	PK4	= 4	; For compatibility
                                 .equ	PORTK5	= 5	; PORT K Data Register bit 5
                                 .equ	PK5	= 5	; For compatibility
                                 .equ	PORTK6	= 6	; PORT K Data Register bit 6
                                 .equ	PK6	= 6	; For compatibility
                                 .equ	PORTK7	= 7	; PORT K Data Register bit 7
                                 .equ	PK7	= 7	; For compatibility
                                 
                                 ; DDRK - PORT K Data Direction Register
                                 .equ	DDK0	= 0	; PORT K Data Direction Register bit 0
                                 .equ	DDK1	= 1	; PORT K Data Direction Register bit 1
                                 .equ	DDK2	= 2	; PORT K Data Direction Register bit 2
                                 .equ	DDK3	= 3	; PORT K Data Direction Register bit 3
                                 .equ	DDK4	= 4	; PORT K Data Direction Register bit 4
                                 .equ	DDK5	= 5	; PORT K Data Direction Register bit 5
                                 .equ	DDK6	= 6	; PORT K Data Direction Register bit 6
                                 .equ	DDK7	= 7	; PORT K Data Direction Register bit 7
                                 
                                 ; PINK - PORT K Input Pins
                                 .equ	PINK0	= 0	; PORT K Input Pins bit 0
                                 .equ	PINK1	= 1	; PORT K Input Pins bit 1
                                 .equ	PINK2	= 2	; PORT K Input Pins bit 2
                                 .equ	PINK3	= 3	; PORT K Input Pins bit 3
                                 .equ	PINK4	= 4	; PORT K Input Pins bit 4
                                 .equ	PINK5	= 5	; PORT K Input Pins bit 5
                                 .equ	PINK6	= 6	; PORT K Input Pins bit 6
                                 .equ	PINK7	= 7	; PORT K Input Pins bit 7
                                 
                                 
                                 ; ***** PORTL ************************
                                 ; PORTL - PORT L Data Register
                                 .equ	PORTL0	= 0	; PORT L Data Register bit 0
                                 .equ	PL0	= 0	; For compatibility
                                 .equ	PORTL1	= 1	; PORT L Data Register bit 1
                                 .equ	PL1	= 1	; For compatibility
                                 .equ	PORTL2	= 2	; PORT L Data Register bit 2
                                 .equ	PL2	= 2	; For compatibility
                                 .equ	PORTL3	= 3	; PORT L Data Register bit 3
                                 .equ	PL3	= 3	; For compatibility
                                 .equ	PORTL4	= 4	; PORT L Data Register bit 4
                                 .equ	PL4	= 4	; For compatibility
                                 .equ	PORTL5	= 5	; PORT L Data Register bit 5
                                 .equ	PL5	= 5	; For compatibility
                                 .equ	PORTL6	= 6	; PORT L Data Register bit 6
                                 .equ	PL6	= 6	; For compatibility
                                 .equ	PORTL7	= 7	; PORT L Data Register bit 7
                                 .equ	PL7	= 7	; For compatibility
                                 
                                 ; DDRL - PORT L Data Direction Register
                                 .equ	DDL0	= 0	; PORT L Data Direction Register bit 0
                                 .equ	DDL1	= 1	; PORT L Data Direction Register bit 1
                                 .equ	DDL2	= 2	; PORT L Data Direction Register bit 2
                                 .equ	DDL3	= 3	; PORT L Data Direction Register bit 3
                                 .equ	DDL4	= 4	; PORT L Data Direction Register bit 4
                                 .equ	DDL5	= 5	; PORT L Data Direction Register bit 5
                                 .equ	DDL6	= 6	; PORT L Data Direction Register bit 6
                                 .equ	DDL7	= 7	; PORT L Data Direction Register bit 7
                                 
                                 ; PINL - PORT L Input Pins
                                 .equ	PINL0	= 0	; PORT L Input Pins bit 0
                                 .equ	PINL1	= 1	; PORT L Input Pins bit 1
                                 .equ	PINL2	= 2	; PORT L Input Pins bit 2
                                 .equ	PINL3	= 3	; PORT L Input Pins bit 3
                                 .equ	PINL4	= 4	; PORT L Input Pins bit 4
                                 .equ	PINL5	= 5	; PORT L Input Pins bit 5
                                 .equ	PINL6	= 6	; PORT L Input Pins bit 6
                                 .equ	PINL7	= 7	; PORT L Input Pins bit 7
                                 
                                 
                                 ; ***** TIMER_COUNTER_0 **************
                                 ; TIMSK0 - Timer/Counter0 Interrupt Mask Register
                                 .equ	TOIE0	= 0	; Timer/Counter0 Overflow Interrupt Enable
                                 .equ	OCIE0A	= 1	; Timer/Counter0 Output Compare Match A Interrupt Enable
                                 .equ	OCIE0B	= 2	; Timer/Counter0 Output Compare Match B Interrupt Enable
                                 
                                 ; TIFR0 - Timer/Counter0 Interrupt Flag register
                                 .equ	TOV0	= 0	; Timer/Counter0 Overflow Flag
                                 .equ	OCF0A	= 1	; Timer/Counter0 Output Compare Flag 0A
                                 .equ	OCF0B	= 2	; Timer/Counter0 Output Compare Flag 0B
                                 
                                 ; TCCR0A - Timer/Counter  Control Register A
                                 .equ	WGM00	= 0	; Waveform Generation Mode
                                 .equ	WGM01	= 1	; Waveform Generation Mode
                                 .equ	COM0B0	= 4	; Compare Output Mode, Fast PWm
                                 .equ	COM0B1	= 5	; Compare Output Mode, Fast PWm
                                 .equ	COM0A0	= 6	; Compare Output Mode, Phase Correct PWM Mode
                                 .equ	COM0A1	= 7	; Compare Output Mode, Phase Correct PWM Mode
                                 
                                 ; TCCR0B - Timer/Counter Control Register B
                                 .equ	CS00	= 0	; Clock Select
                                 .equ	CS01	= 1	; Clock Select
                                 .equ	CS02	= 2	; Clock Select
                                 .equ	WGM02	= 3	; 
                                 .equ	FOC0B	= 6	; Force Output Compare B
                                 .equ	FOC0A	= 7	; Force Output Compare A
                                 
                                 ; TCNT0 - Timer/Counter0
                                 .equ	TCNT0_0	= 0	; 
                                 .equ	TCNT0_1	= 1	; 
                                 .equ	TCNT0_2	= 2	; 
                                 .equ	TCNT0_3	= 3	; 
                                 .equ	TCNT0_4	= 4	; 
                                 .equ	TCNT0_5	= 5	; 
                                 .equ	TCNT0_6	= 6	; 
                                 .equ	TCNT0_7	= 7	; 
                                 
                                 ; OCR0A - Timer/Counter0 Output Compare Register
                                 .equ	OCR0A_0	= 0	; 
                                 .equ	OCR0A_1	= 1	; 
                                 .equ	OCR0A_2	= 2	; 
                                 .equ	OCR0A_3	= 3	; 
                                 .equ	OCR0A_4	= 4	; 
                                 .equ	OCR0A_5	= 5	; 
                                 .equ	OCR0A_6	= 6	; 
                                 .equ	OCR0A_7	= 7	; 
                                 
                                 ; OCR0B - Timer/Counter0 Output Compare Register
                                 .equ	OCR0B_0	= 0	; 
                                 .equ	OCR0B_1	= 1	; 
                                 .equ	OCR0B_2	= 2	; 
                                 .equ	OCR0B_3	= 3	; 
                                 .equ	OCR0B_4	= 4	; 
                                 .equ	OCR0B_5	= 5	; 
                                 .equ	OCR0B_6	= 6	; 
                                 .equ	OCR0B_7	= 7	; 
                                 
                                 ; GTCCR - General Timer/Counter Control Register
                                 .equ	PSRSYNC	= 0	; Prescaler Reset Timer/Counter1 and Timer/Counter0
                                 .equ	PSR10	= PSRSYNC	; For compatibility
                                 .equ	TSM	= 7	; Timer/Counter Synchronization Mode
                                 
                                 
                                 ; ***** TIMER_COUNTER_2 **************
                                 ; TIMSK2 - Timer/Counter Interrupt Mask register
                                 .equ	TOIE2	= 0	; Timer/Counter2 Overflow Interrupt Enable
                                 .equ	TOIE2A	= TOIE2	; For compatibility
                                 .equ	OCIE2A	= 1	; Timer/Counter2 Output Compare Match A Interrupt Enable
                                 .equ	OCIE2B	= 2	; Timer/Counter2 Output Compare Match B Interrupt Enable
                                 
                                 ; TIFR2 - Timer/Counter Interrupt Flag Register
                                 .equ	TOV2	= 0	; Timer/Counter2 Overflow Flag
                                 .equ	OCF2A	= 1	; Output Compare Flag 2A
                                 .equ	OCF2B	= 2	; Output Compare Flag 2B
                                 
                                 ; TCCR2A - Timer/Counter2 Control Register A
                                 .equ	WGM20	= 0	; Waveform Genration Mode
                                 .equ	WGM21	= 1	; Waveform Genration Mode
                                 .equ	COM2B0	= 4	; Compare Output Mode bit 0
                                 .equ	COM2B1	= 5	; Compare Output Mode bit 1
                                 .equ	COM2A0	= 6	; Compare Output Mode bit 1
                                 .equ	COM2A1	= 7	; Compare Output Mode bit 1
                                 
                                 ; TCCR2B - Timer/Counter2 Control Register B
                                 .equ	CS20	= 0	; Clock Select bit 0
                                 .equ	CS21	= 1	; Clock Select bit 1
                                 .equ	CS22	= 2	; Clock Select bit 2
                                 .equ	WGM22	= 3	; Waveform Generation Mode
                                 .equ	FOC2B	= 6	; Force Output Compare B
                                 .equ	FOC2A	= 7	; Force Output Compare A
                                 
                                 ; TCNT2 - Timer/Counter2
                                 .equ	TCNT2_0	= 0	; Timer/Counter 2 bit 0
                                 .equ	TCNT2_1	= 1	; Timer/Counter 2 bit 1
                                 .equ	TCNT2_2	= 2	; Timer/Counter 2 bit 2
                                 .equ	TCNT2_3	= 3	; Timer/Counter 2 bit 3
                                 .equ	TCNT2_4	= 4	; Timer/Counter 2 bit 4
                                 .equ	TCNT2_5	= 5	; Timer/Counter 2 bit 5
                                 .equ	TCNT2_6	= 6	; Timer/Counter 2 bit 6
                                 .equ	TCNT2_7	= 7	; Timer/Counter 2 bit 7
                                 
                                 ; OCR2A - Timer/Counter2 Output Compare Register A
                                 .equ	OCR2A_0	= 0	; Timer/Counter2 Output Compare Register Bit 0
                                 .equ	OCR2A_1	= 1	; Timer/Counter2 Output Compare Register Bit 1
                                 .equ	OCR2A_2	= 2	; Timer/Counter2 Output Compare Register Bit 2
                                 .equ	OCR2A_3	= 3	; Timer/Counter2 Output Compare Register Bit 3
                                 .equ	OCR2A_4	= 4	; Timer/Counter2 Output Compare Register Bit 4
                                 .equ	OCR2A_5	= 5	; Timer/Counter2 Output Compare Register Bit 5
                                 .equ	OCR2A_6	= 6	; Timer/Counter2 Output Compare Register Bit 6
                                 .equ	OCR2A_7	= 7	; Timer/Counter2 Output Compare Register Bit 7
                                 
                                 ; OCR2B - Timer/Counter2 Output Compare Register B
                                 .equ	OCR2B_0	= 0	; Timer/Counter2 Output Compare Register Bit 0
                                 .equ	OCR2B_1	= 1	; Timer/Counter2 Output Compare Register Bit 1
                                 .equ	OCR2B_2	= 2	; Timer/Counter2 Output Compare Register Bit 2
                                 .equ	OCR2B_3	= 3	; Timer/Counter2 Output Compare Register Bit 3
                                 .equ	OCR2B_4	= 4	; Timer/Counter2 Output Compare Register Bit 4
                                 .equ	OCR2B_5	= 5	; Timer/Counter2 Output Compare Register Bit 5
                                 .equ	OCR2B_6	= 6	; Timer/Counter2 Output Compare Register Bit 6
                                 .equ	OCR2B_7	= 7	; Timer/Counter2 Output Compare Register Bit 7
                                 
                                 ; ASSR - Asynchronous Status Register
                                 .equ	TCR2BUB	= 0	; Timer/Counter Control Register2 Update Busy
                                 .equ	TCR2AUB	= 1	; Timer/Counter Control Register2 Update Busy
                                 .equ	OCR2BUB	= 2	; Output Compare Register 2 Update Busy
                                 .equ	OCR2AUB	= 3	; Output Compare Register2 Update Busy
                                 .equ	TCN2UB	= 4	; Timer/Counter2 Update Busy
                                 .equ	AS2	= 5	; Asynchronous Timer/Counter2
                                 .equ	EXCLK	= 6	; Enable External Clock Input
                                 
                                 ; GTCCR - General Timer Counter Control register
                                 .equ	PSRASY	= 1	; Prescaler Reset Timer/Counter2
                                 .equ	PSR2	= PSRASY	; For compatibility
                                 ;.equ	TSM	= 7	; Timer/Counter Synchronization Mode
                                 
                                 
                                 ; ***** WATCHDOG *********************
                                 ; WDTCSR - Watchdog Timer Control Register
                                 .equ	WDP0	= 0	; Watch Dog Timer Prescaler bit 0
                                 .equ	WDP1	= 1	; Watch Dog Timer Prescaler bit 1
                                 .equ	WDP2	= 2	; Watch Dog Timer Prescaler bit 2
                                 .equ	WDE	= 3	; Watch Dog Enable
                                 .equ	WDCE	= 4	; Watchdog Change Enable
                                 .equ	WDP3	= 5	; Watchdog Timer Prescaler Bit 3
                                 .equ	WDIE	= 6	; Watchdog Timeout Interrupt Enable
                                 .equ	WDIF	= 7	; Watchdog Timeout Interrupt Flag
                                 
                                 
                                 ; ***** USART1 ***********************
                                 ; UDR1 - USART I/O Data Register
                                 .equ	UDR1_0	= 0	; USART I/O Data Register bit 0
                                 .equ	UDR1_1	= 1	; USART I/O Data Register bit 1
                                 .equ	UDR1_2	= 2	; USART I/O Data Register bit 2
                                 .equ	UDR1_3	= 3	; USART I/O Data Register bit 3
                                 .equ	UDR1_4	= 4	; USART I/O Data Register bit 4
                                 .equ	UDR1_5	= 5	; USART I/O Data Register bit 5
                                 .equ	UDR1_6	= 6	; USART I/O Data Register bit 6
                                 .equ	UDR1_7	= 7	; USART I/O Data Register bit 7
                                 
                                 ; UCSR1A - USART Control and Status Register A
                                 .equ	MPCM1	= 0	; Multi-processor Communication Mode
                                 .equ	U2X1	= 1	; Double the USART transmission speed
                                 .equ	UPE1	= 2	; Parity Error
                                 .equ	DOR1	= 3	; Data overRun
                                 .equ	FE1	= 4	; Framing Error
                                 .equ	UDRE1	= 5	; USART Data Register Empty
                                 .equ	TXC1	= 6	; USART Transmitt Complete
                                 .equ	RXC1	= 7	; USART Receive Complete
                                 
                                 ; UCSR1B - USART Control and Status Register B
                                 .equ	TXB81	= 0	; Transmit Data Bit 8
                                 .equ	RXB81	= 1	; Receive Data Bit 8
                                 .equ	UCSZ12	= 2	; Character Size
                                 .equ	TXEN1	= 3	; Transmitter Enable
                                 .equ	RXEN1	= 4	; Receiver Enable
                                 .equ	UDRIE1	= 5	; USART Data register Empty Interrupt Enable
                                 .equ	TXCIE1	= 6	; TX Complete Interrupt Enable
                                 .equ	RXCIE1	= 7	; RX Complete Interrupt Enable
                                 
                                 ; UCSR1C - USART Control and Status Register C
                                 .equ	UCPOL1	= 0	; Clock Polarity
                                 .equ	UCSZ10	= 1	; Character Size
                                 .equ	UCPHA1	= UCSZ10	; For compatibility
                                 .equ	UCSZ11	= 2	; Character Size
                                 .equ	UDORD1	= UCSZ11	; For compatibility
                                 .equ	USBS1	= 3	; Stop Bit Select
                                 .equ	UPM10	= 4	; Parity Mode Bit 0
                                 .equ	UPM11	= 5	; Parity Mode Bit 1
                                 .equ	UMSEL10	= 6	; USART Mode Select
                                 .equ	UMSEL11	= 7	; USART Mode Select
                                 
                                 ; UBRR1H - USART Baud Rate Register High Byte
                                 .equ	UBRR_8	= 0	; USART Baud Rate Register bit 8
                                 .equ	UBRR_9	= 1	; USART Baud Rate Register bit 9
                                 .equ	UBRR_10	= 2	; USART Baud Rate Register bit 10
                                 .equ	UBRR_11	= 3	; USART Baud Rate Register bit 11
                                 
                                 ; UBRR1L - USART Baud Rate Register Low Byte
                                 .equ	UBRR_0	= 0	; USART Baud Rate Register bit 0
                                 .equ	UBRR_1	= 1	; USART Baud Rate Register bit 1
                                 .equ	UBRR_2	= 2	; USART Baud Rate Register bit 2
                                 .equ	UBRR_3	= 3	; USART Baud Rate Register bit 3
                                 .equ	UBRR_4	= 4	; USART Baud Rate Register bit 4
                                 .equ	UBRR_5	= 5	; USART Baud Rate Register bit 5
                                 .equ	UBRR_6	= 6	; USART Baud Rate Register bit 6
                                 .equ	UBRR_7	= 7	; USART Baud Rate Register bit 7
                                 
                                 
                                 ; ***** EEPROM ***********************
                                 ; EEARH - EEPROM Address Register Low Byte
                                 .equ	EEAR8	= 0	; EEPROM Read/Write Access Bit 8
                                 .equ	EEAR9	= 1	; EEPROM Read/Write Access Bit 9
                                 .equ	EEAR10	= 2	; EEPROM Read/Write Access Bit 10
                                 .equ	EEAR11	= 3	; EEPROM Read/Write Access Bit 11
                                 
                                 ; EEARL - EEPROM Address Register Low Byte
                                 .equ	EEAR0	= 0	; EEPROM Read/Write Access Bit 0
                                 .equ	EEAR1	= 1	; EEPROM Read/Write Access Bit 1
                                 .equ	EEAR2	= 2	; EEPROM Read/Write Access Bit 2
                                 .equ	EEAR3	= 3	; EEPROM Read/Write Access Bit 3
                                 .equ	EEAR4	= 4	; EEPROM Read/Write Access Bit 4
                                 .equ	EEAR5	= 5	; EEPROM Read/Write Access Bit 5
                                 .equ	EEAR6	= 6	; EEPROM Read/Write Access Bit 6
                                 .equ	EEAR7	= 7	; EEPROM Read/Write Access Bit 7
                                 
                                 ; EEDR - EEPROM Data Register
                                 .equ	EEDR0	= 0	; EEPROM Data Register bit 0
                                 .equ	EEDR1	= 1	; EEPROM Data Register bit 1
                                 .equ	EEDR2	= 2	; EEPROM Data Register bit 2
                                 .equ	EEDR3	= 3	; EEPROM Data Register bit 3
                                 .equ	EEDR4	= 4	; EEPROM Data Register bit 4
                                 .equ	EEDR5	= 5	; EEPROM Data Register bit 5
                                 .equ	EEDR6	= 6	; EEPROM Data Register bit 6
                                 .equ	EEDR7	= 7	; EEPROM Data Register bit 7
                                 
                                 ; EECR - EEPROM Control Register
                                 .equ	EERE	= 0	; EEPROM Read Enable
                                 .equ	EEPE	= 1	; EEPROM Write Enable
                                 .equ	EEMPE	= 2	; EEPROM Master Write Enable
                                 .equ	EERIE	= 3	; EEPROM Ready Interrupt Enable
                                 .equ	EEPM0	= 4	; EEPROM Programming Mode Bit 0
                                 .equ	EEPM1	= 5	; EEPROM Programming Mode Bit 1
                                 
                                 
                                 ; ***** TIMER_COUNTER_5 **************
                                 ; TIMSK5 - Timer/Counter5 Interrupt Mask Register
                                 .equ	TOIE5	= 0	; Timer/Counter5 Overflow Interrupt Enable
                                 .equ	OCIE5A	= 1	; Timer/Counter5 Output Compare A Match Interrupt Enable
                                 .equ	OCIE5B	= 2	; Timer/Counter5 Output Compare B Match Interrupt Enable
                                 .equ	OCIE5C	= 3	; Timer/Counter5 Output Compare C Match Interrupt Enable
                                 .equ	ICIE5	= 5	; Timer/Counter5 Input Capture Interrupt Enable
                                 
                                 ; TIFR5 - Timer/Counter5 Interrupt Flag register
                                 .equ	TOV5	= 0	; Timer/Counter5 Overflow Flag
                                 .equ	OCF5A	= 1	; Output Compare Flag 5A
                                 .equ	OCF5B	= 2	; Output Compare Flag 5B
                                 .equ	OCF5C	= 3	; Output Compare Flag 5C
                                 .equ	ICF5	= 5	; Input Capture Flag 5
                                 
                                 ; TCCR5A - Timer/Counter5 Control Register A
                                 .equ	WGM50	= 0	; Waveform Generation Mode
                                 .equ	WGM51	= 1	; Waveform Generation Mode
                                 .equ	COM5C0	= 2	; Compare Output Mode 5C, bit 0
                                 .equ	COM5C1	= 3	; Compare Output Mode 5C, bit 1
                                 .equ	COM5B0	= 4	; Compare Output Mode 5B, bit 0
                                 .equ	COM5B1	= 5	; Compare Output Mode 5B, bit 1
                                 .equ	COM5A0	= 6	; Compare Output Mode 5A, bit 0
                                 .equ	COM5A1	= 7	; Compare Output Mode 1A, bit 1
                                 
                                 ; TCCR5B - Timer/Counter5 Control Register B
                                 .equ	CS50	= 0	; Prescaler source of Timer/Counter 5
                                 .equ	CS51	= 1	; Prescaler source of Timer/Counter 5
                                 .equ	CS52	= 2	; Prescaler source of Timer/Counter 5
                                 .equ	WGM52	= 3	; Waveform Generation Mode
                                 .equ	WGM53	= 4	; Waveform Generation Mode
                                 .equ	ICES5	= 6	; Input Capture 5 Edge Select
                                 .equ	ICNC5	= 7	; Input Capture 5 Noise Canceler
                                 
                                 ; TCCR5C - Timer/Counter 5 Control Register C
                                 .equ	FOC5C	= 5	; Force Output Compare 5C
                                 .equ	FOC5B	= 6	; Force Output Compare 5B
                                 .equ	FOC5A	= 7	; Force Output Compare 5A
                                 
                                 ; ICR5H - Timer/Counter5 Input Capture Register High Byte
                                 .equ	ICR5H0	= 0	; Timer/Counter5 Input Capture Register High Byte bit 0
                                 .equ	ICR5H1	= 1	; Timer/Counter5 Input Capture Register High Byte bit 1
                                 .equ	ICR5H2	= 2	; Timer/Counter5 Input Capture Register High Byte bit 2
                                 .equ	ICR5H3	= 3	; Timer/Counter5 Input Capture Register High Byte bit 3
                                 .equ	ICR5H4	= 4	; Timer/Counter5 Input Capture Register High Byte bit 4
                                 .equ	ICR5H5	= 5	; Timer/Counter5 Input Capture Register High Byte bit 5
                                 .equ	ICR5H6	= 6	; Timer/Counter5 Input Capture Register High Byte bit 6
                                 .equ	ICR5H7	= 7	; Timer/Counter5 Input Capture Register High Byte bit 7
                                 
                                 ; ICR5L - Timer/Counter5 Input Capture Register Low Byte
                                 .equ	ICR5L0	= 0	; Timer/Counter5 Input Capture Register Low Byte bit 0
                                 .equ	ICR5L1	= 1	; Timer/Counter5 Input Capture Register Low Byte bit 1
                                 .equ	ICR5L2	= 2	; Timer/Counter5 Input Capture Register Low Byte bit 2
                                 .equ	ICR5L3	= 3	; Timer/Counter5 Input Capture Register Low Byte bit 3
                                 .equ	ICR5L4	= 4	; Timer/Counter5 Input Capture Register Low Byte bit 4
                                 .equ	ICR5L5	= 5	; Timer/Counter5 Input Capture Register Low Byte bit 5
                                 .equ	ICR5L6	= 6	; Timer/Counter5 Input Capture Register Low Byte bit 6
                                 .equ	ICR5L7	= 7	; Timer/Counter5 Input Capture Register Low Byte bit 7
                                 
                                 
                                 ; ***** TIMER_COUNTER_4 **************
                                 ; TIMSK4 - Timer/Counter4 Interrupt Mask Register
                                 .equ	TOIE4	= 0	; Timer/Counter4 Overflow Interrupt Enable
                                 .equ	OCIE4A	= 1	; Timer/Counter4 Output Compare A Match Interrupt Enable
                                 .equ	OCIE4B	= 2	; Timer/Counter4 Output Compare B Match Interrupt Enable
                                 .equ	OCIE4C	= 3	; Timer/Counter4 Output Compare C Match Interrupt Enable
                                 .equ	ICIE4	= 5	; Timer/Counter4 Input Capture Interrupt Enable
                                 
                                 ; TIFR4 - Timer/Counter4 Interrupt Flag register
                                 .equ	TOV4	= 0	; Timer/Counter4 Overflow Flag
                                 .equ	OCF4A	= 1	; Output Compare Flag 4A
                                 .equ	OCF4B	= 2	; Output Compare Flag 4B
                                 .equ	OCF4C	= 3	; Output Compare Flag 4C
                                 .equ	ICF4	= 5	; Input Capture Flag 4
                                 
                                 ; TCCR4A - Timer/Counter4 Control Register A
                                 .equ	WGM40	= 0	; Waveform Generation Mode
                                 .equ	WGM41	= 1	; Waveform Generation Mode
                                 .equ	COM4C0	= 2	; Compare Output Mode 4C, bit 0
                                 .equ	COM4C1	= 3	; Compare Output Mode 4C, bit 1
                                 .equ	COM4B0	= 4	; Compare Output Mode 4B, bit 0
                                 .equ	COM4B1	= 5	; Compare Output Mode 4B, bit 1
                                 .equ	COM4A0	= 6	; Compare Output Mode 4A, bit 0
                                 .equ	COM4A1	= 7	; Compare Output Mode 1A, bit 1
                                 
                                 ; TCCR4B - Timer/Counter4 Control Register B
                                 .equ	CS40	= 0	; Prescaler source of Timer/Counter 4
                                 .equ	CS41	= 1	; Prescaler source of Timer/Counter 4
                                 .equ	CS42	= 2	; Prescaler source of Timer/Counter 4
                                 .equ	WGM42	= 3	; Waveform Generation Mode
                                 .equ	WGM43	= 4	; Waveform Generation Mode
                                 .equ	ICES4	= 6	; Input Capture 4 Edge Select
                                 .equ	ICNC4	= 7	; Input Capture 4 Noise Canceler
                                 
                                 ; TCCR4C - Timer/Counter 4 Control Register C
                                 .equ	FOC4C	= 5	; Force Output Compare 4C
                                 .equ	FOC4B	= 6	; Force Output Compare 4B
                                 .equ	FOC4A	= 7	; Force Output Compare 4A
                                 
                                 
                                 ; ***** TIMER_COUNTER_3 **************
                                 ; TIMSK3 - Timer/Counter3 Interrupt Mask Register
                                 .equ	TOIE3	= 0	; Timer/Counter3 Overflow Interrupt Enable
                                 .equ	OCIE3A	= 1	; Timer/Counter3 Output Compare A Match Interrupt Enable
                                 .equ	OCIE3B	= 2	; Timer/Counter3 Output Compare B Match Interrupt Enable
                                 .equ	OCIE3C	= 3	; Timer/Counter3 Output Compare C Match Interrupt Enable
                                 .equ	ICIE3	= 5	; Timer/Counter3 Input Capture Interrupt Enable
                                 
                                 ; TIFR3 - Timer/Counter3 Interrupt Flag register
                                 .equ	TOV3	= 0	; Timer/Counter3 Overflow Flag
                                 .equ	OCF3A	= 1	; Output Compare Flag 3A
                                 .equ	OCF3B	= 2	; Output Compare Flag 3B
                                 .equ	OCF3C	= 3	; Output Compare Flag 3C
                                 .equ	ICF3	= 5	; Input Capture Flag 3
                                 
                                 ; TCCR3A - Timer/Counter3 Control Register A
                                 .equ	WGM30	= 0	; Waveform Generation Mode
                                 .equ	WGM31	= 1	; Waveform Generation Mode
                                 .equ	COM3C0	= 2	; Compare Output Mode 3C, bit 0
                                 .equ	COM3C1	= 3	; Compare Output Mode 3C, bit 1
                                 .equ	COM3B0	= 4	; Compare Output Mode 3B, bit 0
                                 .equ	COM3B1	= 5	; Compare Output Mode 3B, bit 1
                                 .equ	COM3A0	= 6	; Compare Output Mode 3A, bit 0
                                 .equ	COM3A1	= 7	; Compare Output Mode 1A, bit 1
                                 
                                 ; TCCR3B - Timer/Counter3 Control Register B
                                 .equ	CS30	= 0	; Prescaler source of Timer/Counter 3
                                 .equ	CS31	= 1	; Prescaler source of Timer/Counter 3
                                 .equ	CS32	= 2	; Prescaler source of Timer/Counter 3
                                 .equ	WGM32	= 3	; Waveform Generation Mode
                                 .equ	WGM33	= 4	; Waveform Generation Mode
                                 .equ	ICES3	= 6	; Input Capture 3 Edge Select
                                 .equ	ICNC3	= 7	; Input Capture 3 Noise Canceler
                                 
                                 ; TCCR3C - Timer/Counter 3 Control Register C
                                 .equ	FOC3C	= 5	; Force Output Compare 3C
                                 .equ	FOC3B	= 6	; Force Output Compare 3B
                                 .equ	FOC3A	= 7	; Force Output Compare 3A
                                 
                                 
                                 ; ***** TIMER_COUNTER_1 **************
                                 ; TIMSK1 - Timer/Counter1 Interrupt Mask Register
                                 .equ	TOIE1	= 0	; Timer/Counter1 Overflow Interrupt Enable
                                 .equ	OCIE1A	= 1	; Timer/Counter1 Output Compare A Match Interrupt Enable
                                 .equ	OCIE1B	= 2	; Timer/Counter1 Output Compare B Match Interrupt Enable
                                 .equ	OCIE1C	= 3	; Timer/Counter1 Output Compare C Match Interrupt Enable
                                 .equ	ICIE1	= 5	; Timer/Counter1 Input Capture Interrupt Enable
                                 
                                 ; TIFR1 - Timer/Counter1 Interrupt Flag register
                                 .equ	TOV1	= 0	; Timer/Counter1 Overflow Flag
                                 .equ	OCF1A	= 1	; Output Compare Flag 1A
                                 .equ	OCF1B	= 2	; Output Compare Flag 1B
                                 .equ	OCF1C	= 3	; Output Compare Flag 1C
                                 .equ	ICF1	= 5	; Input Capture Flag 1
                                 
                                 ; TCCR1A - Timer/Counter1 Control Register A
                                 .equ	WGM10	= 0	; Waveform Generation Mode
                                 .equ	WGM11	= 1	; Waveform Generation Mode
                                 .equ	COM1C0	= 2	; Compare Output Mode 1C, bit 0
                                 .equ	COM1C1	= 3	; Compare Output Mode 1C, bit 1
                                 .equ	COM1B0	= 4	; Compare Output Mode 1B, bit 0
                                 .equ	COM1B1	= 5	; Compare Output Mode 1B, bit 1
                                 .equ	COM1A0	= 6	; Compare Output Mode 1A, bit 0
                                 .equ	COM1A1	= 7	; Compare Output Mode 1A, bit 1
                                 
                                 ; TCCR1B - Timer/Counter1 Control Register B
                                 .equ	CS10	= 0	; Prescaler source of Timer/Counter 1
                                 .equ	CS11	= 1	; Prescaler source of Timer/Counter 1
                                 .equ	CS12	= 2	; Prescaler source of Timer/Counter 1
                                 .equ	WGM12	= 3	; Waveform Generation Mode
                                 .equ	WGM13	= 4	; Waveform Generation Mode
                                 .equ	ICES1	= 6	; Input Capture 1 Edge Select
                                 .equ	ICNC1	= 7	; Input Capture 1 Noise Canceler
                                 
                                 ; TCCR1C - Timer/Counter 1 Control Register C
                                 .equ	FOC1C	= 5	; Force Output Compare 1C
                                 .equ	FOC1B	= 6	; Force Output Compare 1B
                                 .equ	FOC1A	= 7	; Force Output Compare 1A
                                 
                                 
                                 ; ***** JTAG *************************
                                 ; OCDR - On-Chip Debug Related Register in I/O Memory
                                 .equ	OCDR0	= 0	; On-Chip Debug Register Bit 0
                                 .equ	OCDR1	= 1	; On-Chip Debug Register Bit 1
                                 .equ	OCDR2	= 2	; On-Chip Debug Register Bit 2
                                 .equ	OCDR3	= 3	; On-Chip Debug Register Bit 3
                                 .equ	OCDR4	= 4	; On-Chip Debug Register Bit 4
                                 .equ	OCDR5	= 5	; On-Chip Debug Register Bit 5
                                 .equ	OCDR6	= 6	; On-Chip Debug Register Bit 6
                                 .equ	OCDR7	= 7	; On-Chip Debug Register Bit 7
                                 .equ	IDRD	= OCDR7	; For compatibility
                                 
                                 ; MCUCR - MCU Control Register
                                 .equ	JTD	= 7	; JTAG Interface Disable
                                 
                                 ; MCUSR - MCU Status Register
                                 .equ	JTRF	= 4	; JTAG Reset Flag
                                 
                                 
                                 ; ***** EXTERNAL_INTERRUPT ***********
                                 ; EICRA - External Interrupt Control Register A
                                 .equ	ISC00	= 0	; External Interrupt Sense Control Bit
                                 .equ	ISC01	= 1	; External Interrupt Sense Control Bit
                                 .equ	ISC10	= 2	; External Interrupt Sense Control Bit
                                 .equ	ISC11	= 3	; External Interrupt Sense Control Bit
                                 .equ	ISC20	= 4	; External Interrupt Sense Control Bit
                                 .equ	ISC21	= 5	; External Interrupt Sense Control Bit
                                 .equ	ISC30	= 6	; External Interrupt Sense Control Bit
                                 .equ	ISC31	= 7	; External Interrupt Sense Control Bit
                                 
                                 ; EICRB - External Interrupt Control Register B
                                 .equ	ISC40	= 0	; External Interrupt 7-4 Sense Control Bit
                                 .equ	ISC41	= 1	; External Interrupt 7-4 Sense Control Bit
                                 .equ	ISC50	= 2	; External Interrupt 7-4 Sense Control Bit
                                 .equ	ISC51	= 3	; External Interrupt 7-4 Sense Control Bit
                                 .equ	ISC60	= 4	; External Interrupt 7-4 Sense Control Bit
                                 .equ	ISC61	= 5	; External Interrupt 7-4 Sense Control Bit
                                 .equ	ISC70	= 6	; External Interrupt 7-4 Sense Control Bit
                                 .equ	ISC71	= 7	; External Interrupt 7-4 Sense Control Bit
                                 
                                 ; EIMSK - External Interrupt Mask Register
                                 .equ	INT0	= 0	; External Interrupt Request 0 Enable
                                 .equ	INT1	= 1	; External Interrupt Request 1 Enable
                                 .equ	INT2	= 2	; External Interrupt Request 2 Enable
                                 .equ	INT3	= 3	; External Interrupt Request 3 Enable
                                 .equ	INT4	= 4	; External Interrupt Request 4 Enable
                                 .equ	INT5	= 5	; External Interrupt Request 5 Enable
                                 .equ	INT6	= 6	; External Interrupt Request 6 Enable
                                 .equ	INT7	= 7	; External Interrupt Request 7 Enable
                                 
                                 ; EIFR - External Interrupt Flag Register
                                 .equ	INTF0	= 0	; External Interrupt Flag 0
                                 .equ	INTF1	= 1	; External Interrupt Flag 1
                                 .equ	INTF2	= 2	; External Interrupt Flag 2
                                 .equ	INTF3	= 3	; External Interrupt Flag 3
                                 .equ	INTF4	= 4	; External Interrupt Flag 4
                                 .equ	INTF5	= 5	; External Interrupt Flag 5
                                 .equ	INTF6	= 6	; External Interrupt Flag 6
                                 .equ	INTF7	= 7	; External Interrupt Flag 7
                                 
                                 ; PCICR - Pin Change Interrupt Control Register
                                 .equ	PCIE0	= 0	; Pin Change Interrupt Enable 0
                                 .equ	PCIE1	= 1	; Pin Change Interrupt Enable 1
                                 .equ	PCIE2	= 2	; Pin Change Interrupt Enable 2
                                 
                                 ; PCIFR - Pin Change Interrupt Flag Register
                                 .equ	PCIF0	= 0	; Pin Change Interrupt Flag 0
                                 .equ	PCIF1	= 1	; Pin Change Interrupt Flag 1
                                 .equ	PCIF2	= 2	; Pin Change Interrupt Flag 2
                                 
                                 ; PCMSK2 - Pin Change Mask Register 2
                                 .equ	PCINT16	= 0	; Pin Change Enable Mask 16
                                 .equ	PCINT17	= 1	; Pin Change Enable Mask 17
                                 .equ	PCINT18	= 2	; Pin Change Enable Mask 18
                                 .equ	PCINT19	= 3	; Pin Change Enable Mask 19
                                 .equ	PCINT20	= 4	; Pin Change Enable Mask 20
                                 .equ	PCINT21	= 5	; Pin Change Enable Mask 21
                                 .equ	PCINT22	= 6	; Pin Change Enable Mask 22
                                 .equ	PCINT23	= 7	; Pin Change Enable Mask 23
                                 
                                 ; PCMSK1 - Pin Change Mask Register 1
                                 .equ	PCINT8	= 0	; Pin Change Enable Mask 8
                                 .equ	PCINT9	= 1	; Pin Change Enable Mask 9
                                 .equ	PCINT10	= 2	; Pin Change Enable Mask 10
                                 .equ	PCINT11	= 3	; Pin Change Enable Mask 11
                                 .equ	PCINT12	= 4	; Pin Change Enable Mask 12
                                 .equ	PCINT13	= 5	; Pin Change Enable Mask 13
                                 .equ	PCINT14	= 6	; Pin Change Enable Mask 14
                                 .equ	PCINT15	= 7	; Pin Change Enable Mask 15
                                 
                                 ; PCMSK0 - Pin Change Mask Register 0
                                 .equ	PCINT0	= 0	; Pin Change Enable Mask 0
                                 .equ	PCINT1	= 1	; Pin Change Enable Mask 1
                                 .equ	PCINT2	= 2	; Pin Change Enable Mask 2
                                 .equ	PCINT3	= 3	; Pin Change Enable Mask 3
                                 .equ	PCINT4	= 4	; Pin Change Enable Mask 4
                                 .equ	PCINT5	= 5	; Pin Change Enable Mask 5
                                 .equ	PCINT6	= 6	; Pin Change Enable Mask 6
                                 .equ	PCINT7	= 7	; Pin Change Enable Mask 7
                                 
                                 
                                 ; ***** CPU **************************
                                 ; SREG - Status Register
                                 .equ	SREG_C	= 0	; Carry Flag
                                 .equ	SREG_Z	= 1	; Zero Flag
                                 .equ	SREG_N	= 2	; Negative Flag
                                 .equ	SREG_V	= 3	; Two's Complement Overflow Flag
                                 .equ	SREG_S	= 4	; Sign Bit
                                 .equ	SREG_H	= 5	; Half Carry Flag
                                 .equ	SREG_T	= 6	; Bit Copy Storage
                                 .equ	SREG_I	= 7	; Global Interrupt Enable
                                 
                                 ; MCUCR - MCU Control Register
                                 .equ	IVCE	= 0	; Interrupt Vector Change Enable
                                 .equ	IVSEL	= 1	; Interrupt Vector Select
                                 .equ	PUD	= 4	; Pull-up disable
                                 ;.equ	JTD	= 7	; JTAG Interface Disable
                                 
                                 ; MCUSR - MCU Status Register
                                 .equ	PORF	= 0	; Power-on reset flag
                                 .equ	EXTRF	= 1	; External Reset Flag
                                 .equ	BORF	= 2	; Brown-out Reset Flag
                                 .equ	WDRF	= 3	; Watchdog Reset Flag
                                 ;.equ	JTRF	= 4	; JTAG Reset Flag
                                 
                                 ; XMCRA - External Memory Control Register A
                                 .equ	SRW00	= 0	; Wait state select bit lower page
                                 .equ	SRW01	= 1	; Wait state select bit lower page
                                 .equ	SRW10	= 2	; Wait state select bit upper page
                                 .equ	SRW11	= 3	; Wait state select bit upper page
                                 .equ	SRL0	= 4	; Wait state page limit
                                 .equ	SRL1	= 5	; Wait state page limit
                                 .equ	SRL2	= 6	; Wait state page limit
                                 .equ	SRE	= 7	; External SRAM Enable
                                 
                                 ; XMCRB - External Memory Control Register B
                                 .equ	XMM0	= 0	; External Memory High Mask
                                 .equ	XMM1	= 1	; External Memory High Mask
                                 .equ	XMM2	= 2	; External Memory High Mask
                                 .equ	XMBK	= 7	; External Memory Bus Keeper Enable
                                 
                                 ; OSCCAL - Oscillator Calibration Value
                                 .equ	CAL0	= 0	; Oscillator Calibration Value Bit0
                                 .equ	CAL1	= 1	; Oscillator Calibration Value Bit1
                                 .equ	CAL2	= 2	; Oscillator Calibration Value Bit2
                                 .equ	CAL3	= 3	; Oscillator Calibration Value Bit3
                                 .equ	CAL4	= 4	; Oscillator Calibration Value Bit4
                                 .equ	CAL5	= 5	; Oscillator Calibration Value Bit5
                                 .equ	CAL6	= 6	; Oscillator Calibration Value Bit6
                                 .equ	CAL7	= 7	; Oscillator Calibration Value Bit7
                                 
                                 ; CLKPR - 
                                 .equ	CLKPS0	= 0	; 
                                 .equ	CLKPS1	= 1	; 
                                 .equ	CLKPS2	= 2	; 
                                 .equ	CLKPS3	= 3	; 
                                 .equ	CLKPCE	= 7	; 
                                 
                                 ; SMCR - Sleep Mode Control Register
                                 .equ	SE	= 0	; Sleep Enable
                                 .equ	SM0	= 1	; Sleep Mode Select bit 0
                                 .equ	SM1	= 2	; Sleep Mode Select bit 1
                                 .equ	SM2	= 3	; Sleep Mode Select bit 2
                                 
                                 ; RAMPZ - RAM Page Z Select Register
                                 .equ	RAMPZ0	= 0	; RAM Page Z Select Register Bit 0
                                 .equ	RAMPZ1	= 1	; RAM Page Z Select Register Bit 1
                                 
                                 ; EIND - Extended Indirect Register
                                 .equ	EIND0	= 0	; Bit 0
                                 
                                 ; GPIOR2 - General Purpose IO Register 2
                                 .equ	GPIOR20	= 0	; General Purpose IO Register 2 bit 0
                                 .equ	GPIOR21	= 1	; General Purpose IO Register 2 bit 1
                                 .equ	GPIOR22	= 2	; General Purpose IO Register 2 bit 2
                                 .equ	GPIOR23	= 3	; General Purpose IO Register 2 bit 3
                                 .equ	GPIOR24	= 4	; General Purpose IO Register 2 bit 4
                                 .equ	GPIOR25	= 5	; General Purpose IO Register 2 bit 5
                                 .equ	GPIOR26	= 6	; General Purpose IO Register 2 bit 6
                                 .equ	GPIOR27	= 7	; General Purpose IO Register 2 bit 7
                                 
                                 ; GPIOR1 - General Purpose IO Register 1
                                 .equ	GPIOR10	= 0	; General Purpose IO Register 1 bit 0
                                 .equ	GPIOR11	= 1	; General Purpose IO Register 1 bit 1
                                 .equ	GPIOR12	= 2	; General Purpose IO Register 1 bit 2
                                 .equ	GPIOR13	= 3	; General Purpose IO Register 1 bit 3
                                 .equ	GPIOR14	= 4	; General Purpose IO Register 1 bit 4
                                 .equ	GPIOR15	= 5	; General Purpose IO Register 1 bit 5
                                 .equ	GPIOR16	= 6	; General Purpose IO Register 1 bit 6
                                 .equ	GPIOR17	= 7	; General Purpose IO Register 1 bit 7
                                 
                                 ; GPIOR0 - General Purpose IO Register 0
                                 .equ	GPIOR00	= 0	; General Purpose IO Register 0 bit 0
                                 .equ	GPIOR01	= 1	; General Purpose IO Register 0 bit 1
                                 .equ	GPIOR02	= 2	; General Purpose IO Register 0 bit 2
                                 .equ	GPIOR03	= 3	; General Purpose IO Register 0 bit 3
                                 .equ	GPIOR04	= 4	; General Purpose IO Register 0 bit 4
                                 .equ	GPIOR05	= 5	; General Purpose IO Register 0 bit 5
                                 .equ	GPIOR06	= 6	; General Purpose IO Register 0 bit 6
                                 .equ	GPIOR07	= 7	; General Purpose IO Register 0 bit 7
                                 
                                 ; PRR1 - Power Reduction Register1
                                 .equ	PRUSART1	= 0	; Power Reduction USART1
                                 .equ	PRUSART2	= 1	; Power Reduction USART2
                                 .equ	PRUSART3	= 2	; Power Reduction USART3
                                 .equ	PRTIM3	= 3	; Power Reduction Timer/Counter3
                                 .equ	PRTIM4	= 4	; Power Reduction Timer/Counter4
                                 .equ	PRTIM5	= 5	; Power Reduction Timer/Counter5
                                 
                                 ; PRR0 - Power Reduction Register0
                                 .equ	PRADC	= 0	; Power Reduction ADC
                                 .equ	PRUSART0	= 1	; Power Reduction USART
                                 .equ	PRSPI	= 2	; Power Reduction Serial Peripheral Interface
                                 .equ	PRTIM1	= 3	; Power Reduction Timer/Counter1
                                 .equ	PRTIM0	= 5	; Power Reduction Timer/Counter0
                                 .equ	PRTIM2	= 6	; Power Reduction Timer/Counter2
                                 .equ	PRTWI	= 7	; Power Reduction TWI
                                 
                                 
                                 ; ***** AD_CONVERTER *****************
                                 ; ADMUX - The ADC multiplexer Selection Register
                                 .equ	MUX0	= 0	; Analog Channel and Gain Selection Bits
                                 .equ	MUX1	= 1	; Analog Channel and Gain Selection Bits
                                 .equ	MUX2	= 2	; Analog Channel and Gain Selection Bits
                                 .equ	MUX3	= 3	; Analog Channel and Gain Selection Bits
                                 .equ	MUX4	= 4	; Analog Channel and Gain Selection Bits
                                 .equ	ADLAR	= 5	; Left Adjust Result
                                 .equ	REFS0	= 6	; Reference Selection Bit 0
                                 .equ	REFS1	= 7	; Reference Selection Bit 1
                                 
                                 ; ADCSRA - The ADC Control and Status register A
                                 .equ	ADPS0	= 0	; ADC  Prescaler Select Bits
                                 .equ	ADPS1	= 1	; ADC  Prescaler Select Bits
                                 .equ	ADPS2	= 2	; ADC  Prescaler Select Bits
                                 .equ	ADIE	= 3	; ADC Interrupt Enable
                                 .equ	ADIF	= 4	; ADC Interrupt Flag
                                 .equ	ADATE	= 5	; ADC  Auto Trigger Enable
                                 .equ	ADSC	= 6	; ADC Start Conversion
                                 .equ	ADEN	= 7	; ADC Enable
                                 
                                 ; ADCSRB - The ADC Control and Status register B
                                 .equ	ADTS0	= 0	; ADC Auto Trigger Source bit 0
                                 .equ	ADTS1	= 1	; ADC Auto Trigger Source bit 1
                                 .equ	ADTS2	= 2	; ADC Auto Trigger Source bit 2
                                 .equ	MUX5	= 3	; Analog Channel and Gain Selection Bits
                                 ;.equ	ACME	= 6	; 
                                 
                                 ; ADCH - ADC Data Register High Byte
                                 .equ	ADCH0	= 0	; ADC Data Register High Byte Bit 0
                                 .equ	ADCH1	= 1	; ADC Data Register High Byte Bit 1
                                 .equ	ADCH2	= 2	; ADC Data Register High Byte Bit 2
                                 .equ	ADCH3	= 3	; ADC Data Register High Byte Bit 3
                                 .equ	ADCH4	= 4	; ADC Data Register High Byte Bit 4
                                 .equ	ADCH5	= 5	; ADC Data Register High Byte Bit 5
                                 .equ	ADCH6	= 6	; ADC Data Register High Byte Bit 6
                                 .equ	ADCH7	= 7	; ADC Data Register High Byte Bit 7
                                 
                                 ; ADCL - ADC Data Register Low Byte
                                 .equ	ADCL0	= 0	; ADC Data Register Low Byte Bit 0
                                 .equ	ADCL1	= 1	; ADC Data Register Low Byte Bit 1
                                 .equ	ADCL2	= 2	; ADC Data Register Low Byte Bit 2
                                 .equ	ADCL3	= 3	; ADC Data Register Low Byte Bit 3
                                 .equ	ADCL4	= 4	; ADC Data Register Low Byte Bit 4
                                 .equ	ADCL5	= 5	; ADC Data Register Low Byte Bit 5
                                 .equ	ADCL6	= 6	; ADC Data Register Low Byte Bit 6
                                 .equ	ADCL7	= 7	; ADC Data Register Low Byte Bit 7
                                 
                                 ; DIDR0 - Digital Input Disable Register
                                 .equ	ADC0D	= 0	; 
                                 .equ	ADC1D	= 1	; 
                                 .equ	ADC2D	= 2	; 
                                 .equ	ADC3D	= 3	; 
                                 .equ	ADC4D	= 4	; 
                                 .equ	ADC5D	= 5	; 
                                 .equ	ADC6D	= 6	; 
                                 .equ	ADC7D	= 7	; 
                                 
                                 ; DIDR2 - Digital Input Disable Register
                                 .equ	ADC8D	= 0	; 
                                 .equ	ADC9D	= 1	; 
                                 .equ	ADC10D	= 2	; 
                                 .equ	ADC11D	= 3	; 
                                 .equ	ADC12D	= 4	; 
                                 .equ	ADC13D	= 5	; 
                                 .equ	ADC14D	= 6	; 
                                 .equ	ADC15D	= 7	; 
                                 
                                 
                                 ; ***** BOOT_LOAD ********************
                                 ; SPMCSR - Store Program Memory Control Register
                                 .equ	SPMEN	= 0	; Store Program Memory Enable
                                 .equ	PGERS	= 1	; Page Erase
                                 .equ	PGWRT	= 2	; Page Write
                                 .equ	BLBSET	= 3	; Boot Lock Bit Set
                                 .equ	RWWSRE	= 4	; Read While Write section read enable
                                 .equ	SIGRD	= 5	; Signature Row Read
                                 .equ	RWWSB	= 6	; Read While Write Section Busy
                                 .equ	SPMIE	= 7	; SPM Interrupt Enable
                                 
                                 
                                 ; ***** USART2 ***********************
                                 ; UDR2 - USART I/O Data Register
                                 .equ	UDR2_0	= 0	; USART I/O Data Register bit 0
                                 .equ	UDR2_1	= 1	; USART I/O Data Register bit 1
                                 .equ	UDR2_2	= 2	; USART I/O Data Register bit 2
                                 .equ	UDR2_3	= 3	; USART I/O Data Register bit 3
                                 .equ	UDR2_4	= 4	; USART I/O Data Register bit 4
                                 .equ	UDR2_5	= 5	; USART I/O Data Register bit 5
                                 .equ	UDR2_6	= 6	; USART I/O Data Register bit 6
                                 .equ	UDR2_7	= 7	; USART I/O Data Register bit 7
                                 
                                 ; UCSR2A - USART Control and Status Register A
                                 .equ	MPCM2	= 0	; Multi-processor Communication Mode
                                 .equ	U2X2	= 1	; Double the USART transmission speed
                                 .equ	UPE2	= 2	; Parity Error
                                 .equ	DOR2	= 3	; Data overRun
                                 .equ	FE2	= 4	; Framing Error
                                 .equ	UDRE2	= 5	; USART Data Register Empty
                                 .equ	TXC2	= 6	; USART Transmitt Complete
                                 .equ	RXC2	= 7	; USART Receive Complete
                                 
                                 ; UCSR2B - USART Control and Status Register B
                                 .equ	TXB82	= 0	; Transmit Data Bit 8
                                 .equ	RXB82	= 1	; Receive Data Bit 8
                                 .equ	UCSZ22	= 2	; Character Size
                                 .equ	TXEN2	= 3	; Transmitter Enable
                                 .equ	RXEN2	= 4	; Receiver Enable
                                 .equ	UDRIE2	= 5	; USART Data register Empty Interrupt Enable
                                 .equ	TXCIE2	= 6	; TX Complete Interrupt Enable
                                 .equ	RXCIE2	= 7	; RX Complete Interrupt Enable
                                 
                                 ; UCSR2C - USART Control and Status Register C
                                 .equ	UCPOL2	= 0	; Clock Polarity
                                 .equ	UCSZ20	= 1	; Character Size
                                 .equ	UCSZ21	= 2	; Character Size
                                 .equ	USBS2	= 3	; Stop Bit Select
                                 .equ	UPM20	= 4	; Parity Mode Bit 0
                                 .equ	UPM21	= 5	; Parity Mode Bit 1
                                 .equ	UMSEL20	= 6	; USART Mode Select
                                 .equ	UMSEL21	= 7	; USART Mode Select
                                 
                                 ; UBRR2H - USART Baud Rate Register High Byte
                                 ;.equ	UBRR8	= 0	; USART Baud Rate Register bit 8
                                 ;.equ	UBRR9	= 1	; USART Baud Rate Register bit 9
                                 ;.equ	UBRR10	= 2	; USART Baud Rate Register bit 10
                                 ;.equ	UBRR11	= 3	; USART Baud Rate Register bit 11
                                 
                                 ; UBRR2L - USART Baud Rate Register Low Byte
                                 .equ	UBRR0	= 0	; USART Baud Rate Register bit 0
                                 .equ	UBRR1	= 1	; USART Baud Rate Register bit 1
                                 ;.equ	UBRR2	= 2	; USART Baud Rate Register bit 2
                                 ;.equ	UBRR3	= 3	; USART Baud Rate Register bit 3
                                 ;.equ	UBRR4	= 4	; USART Baud Rate Register bit 4
                                 ;.equ	UBRR5	= 5	; USART Baud Rate Register bit 5
                                 ;.equ	UBRR6	= 6	; USART Baud Rate Register bit 6
                                 ;.equ	UBRR7	= 7	; USART Baud Rate Register bit 7
                                 
                                 
                                 ; ***** USART3 ***********************
                                 ; UDR3 - USART I/O Data Register
                                 .equ	UDR3_0	= 0	; USART I/O Data Register bit 0
                                 .equ	UDR3_1	= 1	; USART I/O Data Register bit 1
                                 .equ	UDR3_2	= 2	; USART I/O Data Register bit 2
                                 .equ	UDR3_3	= 3	; USART I/O Data Register bit 3
                                 .equ	UDR3_4	= 4	; USART I/O Data Register bit 4
                                 .equ	UDR3_5	= 5	; USART I/O Data Register bit 5
                                 .equ	UDR3_6	= 6	; USART I/O Data Register bit 6
                                 .equ	UDR3_7	= 7	; USART I/O Data Register bit 7
                                 
                                 ; UCSR3A - USART Control and Status Register A
                                 .equ	MPCM3	= 0	; Multi-processor Communication Mode
                                 .equ	U2X3	= 1	; Double the USART transmission speed
                                 .equ	UPE3	= 2	; Parity Error
                                 .equ	DOR3	= 3	; Data overRun
                                 .equ	FE3	= 4	; Framing Error
                                 .equ	UDRE3	= 5	; USART Data Register Empty
                                 .equ	TXC3	= 6	; USART Transmitt Complete
                                 .equ	RXC3	= 7	; USART Receive Complete
                                 
                                 ; UCSR3B - USART Control and Status Register B
                                 .equ	TXB83	= 0	; Transmit Data Bit 8
                                 .equ	RXB83	= 1	; Receive Data Bit 8
                                 .equ	UCSZ32	= 2	; Character Size
                                 .equ	TXEN3	= 3	; Transmitter Enable
                                 .equ	RXEN3	= 4	; Receiver Enable
                                 .equ	UDRIE3	= 5	; USART Data register Empty Interrupt Enable
                                 .equ	TXCIE3	= 6	; TX Complete Interrupt Enable
                                 .equ	RXCIE3	= 7	; RX Complete Interrupt Enable
                                 
                                 ; UCSR3C - USART Control and Status Register C
                                 .equ	UCPOL3	= 0	; Clock Polarity
                                 .equ	UCSZ30	= 1	; Character Size
                                 .equ	UCSZ31	= 2	; Character Size
                                 .equ	USBS3	= 3	; Stop Bit Select
                                 .equ	UPM30	= 4	; Parity Mode Bit 0
                                 .equ	UPM31	= 5	; Parity Mode Bit 1
                                 .equ	UMSEL30	= 6	; USART Mode Select
                                 .equ	UMSEL31	= 7	; USART Mode Select
                                 
                                 ; UBRR3H - USART Baud Rate Register High Byte
                                 ;.equ	UBRR8	= 0	; USART Baud Rate Register bit 8
                                 ;.equ	UBRR9	= 1	; USART Baud Rate Register bit 9
                                 ;.equ	UBRR10	= 2	; USART Baud Rate Register bit 10
                                 ;.equ	UBRR11	= 3	; USART Baud Rate Register bit 11
                                 
                                 ; UBRR3L - USART Baud Rate Register Low Byte
                                 ;.equ	UBRR0	= 0	; USART Baud Rate Register bit 0
                                 ;.equ	UBRR1	= 1	; USART Baud Rate Register bit 1
                                 ;.equ	UBRR2	= 2	; USART Baud Rate Register bit 2
                                 ;.equ	UBRR3	= 3	; USART Baud Rate Register bit 3
                                 ;.equ	UBRR4	= 4	; USART Baud Rate Register bit 4
                                 ;.equ	UBRR5	= 5	; USART Baud Rate Register bit 5
                                 ;.equ	UBRR6	= 6	; USART Baud Rate Register bit 6
                                 ;.equ	UBRR7	= 7	; USART Baud Rate Register bit 7
                                 
                                 
                                 
                                 ; ***** LOCKSBITS ********************************************************
                                 .equ	LB1	= 0	; Lock bit
                                 .equ	LB2	= 1	; Lock bit
                                 .equ	BLB01	= 2	; Boot Lock bit
                                 .equ	BLB02	= 3	; Boot Lock bit
                                 .equ	BLB11	= 4	; Boot lock bit
                                 .equ	BLB12	= 5	; Boot lock bit
                                 
                                 
                                 ; ***** FUSES ************************************************************
                                 ; LOW fuse bits
                                 .equ	CKSEL0	= 0	; Select Clock Source
                                 .equ	CKSEL1	= 1	; Select Clock Source
                                 .equ	CKSEL2	= 2	; Select Clock Source
                                 .equ	CKSEL3	= 3	; Select Clock Source
                                 .equ	SUT0	= 4	; Select start-up time
                                 .equ	SUT1	= 5	; Select start-up time
                                 .equ	CKOUT	= 6	; Clock output
                                 .equ	CKDIV8	= 7	; Divide clock by 8
                                 
                                 ; HIGH fuse bits
                                 .equ	BOOTRST	= 0	; Select Reset Vector
                                 .equ	BOOTSZ0	= 1	; Select Boot Size
                                 .equ	BOOTSZ1	= 2	; Select Boot Size
                                 .equ	EESAVE	= 3	; EEPROM memory is preserved through chip erase
                                 .equ	WDTON	= 4	; Watchdog timer always on
                                 .equ	SPIEN	= 5	; Enable Serial programming and Data Downloading
                                 .equ	JTAGEN	= 6	; Enable JTAG
                                 .equ	OCDEN	= 7	; Enable OCD
                                 
                                 ; EXTENDED fuse bits
                                 .equ	BODLEVEL0	= 0	; Brown-out Detector trigger level
                                 .equ	BODLEVEL1	= 1	; Brown-out Detector trigger level
                                 .equ	BODLEVEL2	= 2	; Brown-out Detector trigger level
                                 
                                 
                                 
                                 ; ***** CPU REGISTER DEFINITIONS *****************************************
                                 .def	XH	= r27
                                 .def	XL	= r26
                                 .def	YH	= r29
                                 .def	YL	= r28
                                 .def	ZH	= r31
                                 .def	ZL	= r30
                                 
                                 
                                 
                                 ; ***** DATA MEMORY DECLARATIONS *****************************************
                                 .equ	FLASHEND	= 0x1ffff	; Note: Word address
                                 .equ	IOEND	= 0x01ff
                                 .equ	SRAM_START	= 0x0200
                                 .equ	SRAM_SIZE	= 8192
                                 .equ	RAMEND	= 0x21ff
                                 .equ	XRAMEND	= 0xffff
                                 .equ	E2END	= 0x0fff
                                 .equ	EEPROMEND	= 0x0fff
                                 .equ	EEADRBITS	= 12
                                 #pragma AVRPART MEMORY PROG_FLASH 262144
                                 #pragma AVRPART MEMORY EEPROM 4096
                                 #pragma AVRPART MEMORY INT_SRAM SIZE 8192
                                 #pragma AVRPART MEMORY INT_SRAM START_ADDR 0x200
                                 
                                 
                                 
                                 ; ***** BOOTLOADER DECLARATIONS ******************************************
                                 .equ	NRWW_START_ADDR	= 0x1f000
                                 .equ	NRWW_STOP_ADDR	= 0x1ffff
                                 .equ	RWW_START_ADDR	= 0x0
                                 .equ	RWW_STOP_ADDR	= 0x1efff
                                 .equ	PAGESIZE	= 128
                                 .equ	FIRSTBOOTSTART	= 0x1fe00
                                 .equ	SECONDBOOTSTART	= 0x1fc00
                                 .equ	THIRDBOOTSTART	= 0x1f800
                                 .equ	FOURTHBOOTSTART	= 0x1f000
                                 .equ	SMALLBOOTSTART	= FIRSTBOOTSTART
                                 .equ	LARGEBOOTSTART	= FOURTHBOOTSTART
                                 
                                 
                                 
                                 ; ***** INTERRUPT VECTORS ************************************************
                                 .equ	INT0addr	= 0x0002	; External Interrupt Request 0
                                 .equ	INT1addr	= 0x0004	; External Interrupt Request 1
                                 .equ	INT2addr	= 0x0006	; External Interrupt Request 2
                                 .equ	INT3addr	= 0x0008	; External Interrupt Request 3
                                 .equ	INT4addr	= 0x000a	; External Interrupt Request 4
                                 .equ	INT5addr	= 0x000c	; External Interrupt Request 5
                                 .equ	INT6addr	= 0x000e	; External Interrupt Request 6
                                 .equ	INT7addr	= 0x0010	; External Interrupt Request 7
                                 .equ	PCI0addr	= 0x0012	; Pin Change Interrupt Request 0
                                 .equ	PCI1addr	= 0x0014	; Pin Change Interrupt Request 1
                                 .equ	PCI2addr	= 0x0016	; Pin Change Interrupt Request 2
                                 .equ	WDTaddr	= 0x0018	; Watchdog Time-out Interrupt
                                 .equ	OC2Aaddr	= 0x001a	; Timer/Counter2 Compare Match A
                                 .equ	OC2Baddr	= 0x001c	; Timer/Counter2 Compare Match B
                                 .equ	OVF2addr	= 0x001e	; Timer/Counter2 Overflow
                                 .equ	ICP1addr	= 0x0020	; Timer/Counter1 Capture Event
                                 .equ	OC1Aaddr	= 0x0022	; Timer/Counter1 Compare Match A
                                 .equ	OC1Baddr	= 0x0024	; Timer/Counter1 Compare Match B
                                 .equ	OC1Caddr	= 0x0026	; Timer/Counter1 Compare Match C
                                 .equ	OVF1addr	= 0x0028	; Timer/Counter1 Overflow
                                 .equ	OC0Aaddr	= 0x002a	; Timer/Counter0 Compare Match A
                                 .equ	OC0Baddr	= 0x002c	; Timer/Counter0 Compare Match B
                                 .equ	OVF0addr	= 0x002e	; Timer/Counter0 Overflow
                                 .equ	SPIaddr	= 0x0030	; SPI Serial Transfer Complete
                                 .equ	URXC0addr	= 0x0032	; USART0, Rx Complete
                                 .equ	UDRE0addr	= 0x0034	; USART0 Data register Empty
                                 .equ	UTXC0addr	= 0x0036	; USART0, Tx Complete
                                 .equ	ACIaddr	= 0x0038	; Analog Comparator
                                 .equ	ADCCaddr	= 0x003a	; ADC Conversion Complete
                                 .equ	ERDYaddr	= 0x003c	; EEPROM Ready
                                 .equ	ICP3addr	= 0x003e	; Timer/Counter3 Capture Event
                                 .equ	OC3Aaddr	= 0x0040	; Timer/Counter3 Compare Match A
                                 .equ	OC3Baddr	= 0x0042	; Timer/Counter3 Compare Match B
                                 .equ	OC3Caddr	= 0x0044	; Timer/Counter3 Compare Match C
                                 .equ	OVF3addr	= 0x0046	; Timer/Counter3 Overflow
                                 .equ	URXC1addr	= 0x0048	; USART1, Rx Complete
                                 .equ	UDRE1addr	= 0x004a	; USART1 Data register Empty
                                 .equ	UTXC1addr	= 0x004c	; USART1, Tx Complete
                                 .equ	TWIaddr	= 0x004e	; 2-wire Serial Interface
                                 .equ	SPMRaddr	= 0x0050	; Store Program Memory Read
                                 .equ	ICP4addr	= 0x0052	; Timer/Counter4 Capture Event
                                 .equ	OC4Aaddr	= 0x0054	; Timer/Counter4 Compare Match A
                                 .equ	OC4Baddr	= 0x0056	; Timer/Counter4 Compare Match B
                                 .equ	OC4Caddr	= 0x0058	; Timer/Counter4 Compare Match C
                                 .equ	OVF4addr	= 0x005a	; Timer/Counter4 Overflow
                                 .equ	ICP5addr	= 0x005c	; Timer/Counter5 Capture Event
                                 .equ	OC5Aaddr	= 0x005e	; Timer/Counter5 Compare Match A
                                 .equ	OC5Baddr	= 0x0060	; Timer/Counter5 Compare Match B
                                 .equ	OC5Caddr	= 0x0062	; Timer/Counter5 Compare Match C
                                 .equ	OVF5addr	= 0x0064	; Timer/Counter5 Overflow
                                 .equ	URXC2addr	= 0x0066	; USART2, Rx Complete
                                 .equ	UDRE2addr	= 0x0068	; USART2 Data register Empty
                                 .equ	UTXC2addr	= 0x006a	; USART2, Tx Complete
                                 .equ	URXC3addr	= 0x006c	; USART3, Rx Complete
                                 .equ	UDRE3addr	= 0x006e	; USART3 Data register Empty
                                 .equ	UTXC3addr	= 0x0070	; USART3, Tx Complete
                                 
                                 .equ	INT_VECTORS_SIZE	= 114	; size in words
                                 
                                 #endif  /* _M2560DEF_INC_ */
                                 
                                 ; ***** END OF FILE ******************************************************
                                 
                                 
                                 ;***** Created: 2011-02-09 12:03 ******* Source: ATmega2560.xml **********
                                 ;*************************************************************************
                                 ;* A P P L I C A T I O N   N O T E   F O R   T H E   A V R   F A M I L Y
                                 ;* 
                                 ;* Number            : AVR000
                                 ;* File Name         : "m2560def.inc"
                                 ;* Title             : Register/Bit Definitions for the ATmega2560
                                 ;* Date              : 2011-02-09
                                 ;* Version           : 2.35
                                 ;* Support E-mail    : avr@atmel.com
                                 ;* Target MCU        : ATmega2560
                                 ;* 
                                 ;* DESCRIPTION
                                 ;* When including this file in the assembly program file, all I/O register 
                                 ;* names and I/O register bit names appearing in the data book can be used.
                                 ;* In addition, the six registers forming the three data pointers X, Y and 
                                 ;* Z have been assigned names XL - ZH. Highest RAM address for Internal 
                                 ;* SRAM is also defined 
                                 ;* 
                                 ;* The Register names are represented by their hexadecimal address.
                                 ;* 
                                 ;* The Register Bit names are represented by their bit number (0-7).
                                 ;* 
                                 ;* Please observe the difference in using the bit names with instructions
                                 ;* such as "sbr"/"cbr" (set/clear bit in register) and "sbrs"/"sbrc"
                                 ;* (skip if bit in register set/cleared). The following example illustrates
                                 ;* this:
                                 ;* 
                                 ;* in    r16,PORTB             ;read PORTB latch
                                 ;* sbr   r16,(1<<PB6)+(1<<PB5) ;set PB6 and PB5 (use masks, not bit#)
                                 ;* out   PORTB,r16             ;output to PORTB
                                 ;* 
                                 ;* in    r16,TIFR              ;read the Timer Interrupt Flag Register
                                 ;* sbrc  r16,TOV0              ;test the overflow flag (use bit#)
                                 ;* rjmp  TOV0_is_set           ;jump if set
                                 ;* ...                         ;otherwise do something else
                                 ;*************************************************************************
                                 
                                 #ifndef _M2560DEF_INC_
                                 #endif  /* _M2560DEF_INC_ */
                                 
                                 ; ***** END OF FILE ******************************************************
                                 
                                 ;//=== Keypad Defs ===\\
                                 	.def temp =r16
                                 	.def row =r17
                                 	.def col =r18
                                 	.def mask =r19
                                 	.def temp2 =r20
                                 	.equ PORTLDIR = 0xF0
                                 	.equ INITCOLMASK = 0xEF
                                 	.equ INITROWMASK = 0x01
                                 	.equ ROWMASK = 0x0F
                                 
                                 ;//===  Personal use Defs and Equs ===\\
                                 	;Desperate times call for desperate measures
                                 	.def TravelTime = r8
                                 	.def currStation = r7
                                 	.def stoptime = r6
                                 
                                 	.def temp3 = r21
                                 	.def temp4 = r22
                                 	.def temp5 = r23
                                 
                                 	.def stationNum = r24
                                 	.equ motorSpeed = 0
                                 
                                 	.equ AsciiNum = 0b00110000
                                 	.equ AsciiLetter = 0b01000000
                                 	.equ AsciiHash = 0b00100011
                                 	.equ AsciiStar = 0b00101010
                                 
                                 	.equ LAST_COLUMN = 3
                                 	.equ UNSET_POSITION = 4
                                 	.equ MAX_CHARACTERS = 10
                                 
                                 	.equ hashcol = 0b10111111
                                 	.equ hashrow = 0b1000
                                 
                                 ;//=== Delay Defs and Equs ===\\
                                 	.equ F_CPU = 16000000
                                 	.equ DELAY_COUNTER = F_CPU / 4 / 100 - 4
                                 
                                 ;//=== Macro for LCD display ===\\
                                 	.macro clear;load in and clear 2 bytes of data
                                 		ldi YL, low(@0)
                                 		ldi YH, high(@0)
                                 		clr temp
                                 		st Y+, temp
                                 		st Y, temp
                                 	.endmacro
                                 
                                 	.macro do_lcd_command ;port in a command
                                 		ldi temp, @0
                                 		rcall lcd_command
                                 		rcall lcd_wait
                                 	.endmacro
                                 
                                 	.macro mov_lcd_command ;reg friendly ver.
                                 		mov temp, @0
                                 		rcall lcd_command
                                 		rcall lcd_wait
                                 	.endmacro
                                 
                                 	.macro do_lcd_data ;write out data
                                 		ldi temp, @0
                                 		rcall lcd_data
                                 		rcall lcd_wait
                                 	.endmacro
                                 
                                 	.macro mov_lcd_data ;reg friendly ver.
                                 		mov temp, @0
                                 		rcall lcd_data
                                 		rcall lcd_wait
                                 	.endmacro
                                 
                                 	.macro ascii_print
                                 		ldi temp, 48
                                 		mov temp2, @0
                                 		add temp2, temp
                                 		mov_lcd_data temp2
                                 	.endmacro
                                 
                                 .dseg
000200                           array: .byte 110
00026e                           times: .byte 11 ;USED FOR LAST STATION TO FIRST TIME TECH
                                 
                                 .cseg
                                 .org 0x0
000000 940c 000b                 jmp RESET
                                 
                                 .org INT0addr
000002 940c 0006                 jmp Button_pushed
                                 .org INT1addr
000004 940c 0006                 jmp Button_pushed
                                 
                                 Button_pushed:
000006 930f                      	push temp
000007 ef0f                      	ldi temp, 0xff
000008 2e50                      	mov r5, temp
000009 910f                      	pop temp
00000a 9518                      reti
                                 
                                 RESET:
                                 	;//Array Frame
00000b e0e0                      		ldi zl, low(array)
00000c e0f2                      		ldi zh, high(array)
00000d e6ce                      		ldi yl, low(times)
00000e e0d2                      		ldi yh, high(times)
                                 	;//Stack frame
00000f e90b                      		ldi temp, low(RAMEND-100)
000010 bf0d                      		out SPL, temp
000011 e201                      		ldi temp, high(RAMEND-100)
000012 bf0e                      		out SPH, temp
                                 
                                 	;//Keypad Set Up
000013 ef00                      		ldi temp, PORTLDIR ; columns are outputs, rows are inputs
000014 9300 010a                 		STS DDRL, temp     ; cannot use out
                                 
                                 	;//LCD Set Up
                                 		;//LCD pin Set Up
000016 ef0f                      			ser temp
000017 bb00                      			out DDRF, temp ;lcd pins as out
000018 b901                      			out DDRA, temp ;lcd control pins as out
000019 2700                      			clr temp
00001a bb01                      			out PORTF, temp ;lcd display as clear
00001b b902                      			out PORTA, temp ;lcd control as not writing or enabled
                                 
00001c e308
00001d d50f
00001e d528                      		do_lcd_command 0b00111000 ; 2x5x7
00001f e308
000020 d50c
000021 d525                      		do_lcd_command 0b00111000 ; 2x5x7
000022 e308
000023 d509
000024 d522                      		do_lcd_command 0b00111000 ; 2x5x7
000025 e308
000026 d506
000027 d51f                      		do_lcd_command 0b00111000 ; 2x5x7
000028 e308
000029 d503
00002a d51c                      		do_lcd_command 0b00111000 ; 2x5x7
00002b e008
00002c d500
00002d d519                      		do_lcd_command 0b00001000 ; display off?
00002e e001
00002f d4fd
000030 d516                      		do_lcd_command 0b00000001 ; clear display
000031 e006
000032 d4fa
000033 d513                      		do_lcd_command 0b00000110 ; increment, no display shift
000034 e00e
000035 d4f7
000036 d510                      		do_lcd_command 0b00001110 ; Cursor on, bar, no blink
                                 
                                 	;//LED Set Up
000037 ef0f                      		ser temp
000038 b907                      		out DDRC, temp ;set LEDS to output
000039 2700                      		clr temp
00003a b908                      		out PORTC, temp ;set LEDS to 0
                                 	;//External Interrupt Set Up
                                 		;Currently just the buttons
00003b 2700                      		clr temp
00003c b90a                      		out DDRD, temp ;set interrupt port to input
00003d b90b                      		out PORTD, temp ;set interrupt port to 0
00003e e00a                      		ldi temp, (2 << ISC10 | 2 << ISC00) ;set falling edge interrupt for buttons
00003f 9300 0069                 		sts EICRA, temp ;Load in falling edge for ext. interrupt
000041 b30d                      		in temp, EIMSK ;load in current active ext. interrupts
000042 6003                      		ori temp, (1<<INT0) | (1<<INT1)  ;note int0 = 0, int1 = 1
000043 bb0d                      		out EIMSK, temp  ;enable ext. interrupts 0 and 1
000044 94f8                      		cli ;disable global interrupt
                                 	
                                 	;PWM and Motor Set Up
000045 ef0f                      		ser temp
000046 b90d                      		out DDRE, temp ;set motor power as output
000047 9300 0101                 		STS DDRH, temp
000049 e000                      		ldi temp,0 ;this value and the operation mode determines the PWM duty cycle
00004a 9300 00ac                 		sts OCR4CL, temp ;Load pulse width/speed into OC4C low register
00004c 2700                      		clr temp
00004d 9300 00ad                 		sts OCR4CH, temp ;Load pulse width/speed into 0C4C high register
00004f e001                      		ldi temp, (1<<CS30) ; CS30 = 1: no prescaling
000050 9300 00a1                 		sts TCCR4B, temp; set the prescaling value
000052 e009                      		ldi temp, (1<<WGM30)|(1<<COM4C1)
                                 		; WGM30=1: phase correct PWM, 8 bits
                                 		;COM4C1=1: make OC4C override the normal port functionality of the I/O pin PE2
000053 9300 00a0                 		sts TCCR4A, temp
000055 9478                      		sei
                                 	;//Other
                                 		;Station 1 Name
000056 e503                      			ldi temp, 'S'
000057 9301                      			st z+, temp
000058 e504                      			ldi temp, 'T'
000059 9301                      			st z+, temp
00005a e401                      			ldi temp, 'A'
00005b 9301                      			st z+, temp
00005c e504                      			ldi temp, 'T'
00005d 9301                      			st z+, temp
00005e e409                      			ldi temp, 'I'
00005f 9301                      			st z+, temp
000060 e40f                      			ldi temp, 'O'
000061 9301                      			st z+, temp
000062 e40e                      			ldi temp, 'N'
000063 9301                      			st z+, temp
000064 e200                      			ldi temp, ' '
000065 9301                      			st z+, temp
000066 e301                      			ldi temp, '1'
000067 9301                      			st z+, temp
000068 e201                      			ldi temp, '!'
000069 9301                      			st z+, temp
                                 		;Station 2 Name
00006a e503                      			ldi temp, 'S'
00006b 9301                      			st z+, temp
00006c e504                      			ldi temp, 'T'
00006d 9301                      			st z+, temp
00006e e401                      			ldi temp, 'A'
00006f 9301                      			st z+, temp
000070 e504                      			ldi temp, 'T'
000071 9301                      			st z+, temp
000072 e409                      			ldi temp, 'I'
000073 9301                      			st z+, temp
000074 e40f                      			ldi temp, 'O'
000075 9301                      			st z+, temp
000076 e40e                      			ldi temp, 'N'
000077 9301                      			st z+, temp
000078 e200                      			ldi temp, ' '
000079 9301                      			st z+, temp
00007a e302                      			ldi temp, '2'
00007b 9301                      			st z+, temp
00007c e201                      			ldi temp, '!'
00007d 9301                      			st z+, temp
                                 		;Time Array
00007e e005                      			ldi temp, 5 ;last to s1
00007f 9309                      			st y+, temp
000080 e003                      			ldi temp, 3 ;s1 to s2
000081 9309                      			st y+, temp
                                 	
000082 e0e0                      	ldi zl, low(array)
000083 e0f2                      	ldi zh, high(array)
000084 e6ce                      	ldi yl, low(times)
000085 e0d2                      	ldi yh, high(times)
000086 2700                      	clr temp
000087 e082                      	ldi stationNum, 2
000088 e002                      	ldi temp, 2
000089 2e60                      	mov stoptime, temp
00008a 940c 008c                 	jmp main
                                 
                                 main:
00008c 940e 01a8                 	call maxStations
00008e 940e 013c                 	call read_in_stations
000090 940e 029c                 	call timeBetweenStations
000092 940e 0318                 	call stopTimeRequest
000094 940e 0229                 	call next_section
                                 	loop:
000096 940e 0468                 	call RP ;internal eternal loop
000098 940c 0096                 	jmp loop
                                 
                                 ;//=== Keypad Start ===\\
                                 	;Keypadcheck | A subroutine that will loop until a key is pressed
                                 	;Changes the values of row and col to represent the key pressed
                                 	Keypad:
00009a ee3f                      			ldi mask, INITCOLMASK ;set mask to 0 only column 1/bit5
00009b 2722                      			clr col ; clear column counter
                                 
                                 		colloop:
00009c 9330 010b                 			STS PORTL, mask ; set column to mask value
                                 
00009e ef0f                      			ldi temp, 0xFF ; implement a delay so the
                                 		delay: ; hardware can stabilize
00009f 950a                      			dec temp
0000a0 f7f1                      			brne delay
0000a1 9100 0109                 			LDS temp, PINL ;Intake the keypad reg values 
0000a3 700f                      			andi temp, ROWMASK ; read only the row bits
0000a4 300f                      			cpi temp, 0xF ; check if any rows are grounded
0000a5 f051                      			breq nextcol ; if not go to the next column
0000a6 e031                      			ldi mask, INITROWMASK ; initialise row check
0000a7 2711                      			clr row ; initial row
                                 
                                 		rowloop:      
0000a8 2f40                      			mov temp2, temp
0000a9 2343                      			and temp2, mask ; check masked bit
0000aa f409                      			brne skipconv ; if the result is non-zero, we need to look again
0000ab 9508                      			ret ; if bit is clear, convert the bitcode and start again
                                 
                                 		skipconv:
0000ac 9513                      			inc row ; else move to the next row
0000ad 0f33                      			lsl mask ; shift the mask to the next bit
0000ae 940c 00a8                 			jmp rowloop
                                 
                                 		nextcol:     
0000b0 3023                      			cpi col, 3 ; check if we're on the last column
0000b1 f341                      			breq Keypad ; if so, no buttons were pushed, so start again.
                                 
0000b2 9408                      			sec ; else shift the column mask, we must set the carry bit
0000b3 1f33                      			rol mask ; and then rotate left by a bit, shifting the carry into bit zero. We need this to make sure all the rows have pull-up resistors
0000b4 9523                      			inc col ; increment column value
0000b5 940c 009c                 			jmp colloop ; and check the next column
                                 ;//=== Keypad End ===\\
                                 
                                 ;//=== Convertion Numbers Start ===\\
                                 	;Intakes rows and columns to give a row number
                                 	;Star is taken as end of squence
                                 	;temp is then 0 = no err, 1 = no num, 2 = big num err (>10)
                                 	;store value of key into temp3
                                 	convert_numbers:
0000b7 3023                      			cpi col, 3 ; if column is 3 we have a letter
0000b8 f079                      			breq letters ;but no letters so keypad check
0000b9 3013                      			cpi row, 3 ; if row is 3 we have a symbol or 0
0000ba f079                      			breq symbols
0000bb 2f01                      			mov temp, row ; otherwise we have a number (1-9)
0000bc 0f00                      			lsl temp ; temp = row * 2
0000bd 0f01                      			add temp, row ; temp = row * 3
0000be 0f02                      			add temp, col ; add the column address
                                 			; to get the offset from 1
0000bf 9503                      			inc temp ; add 1. Value of switch is
                                 			; row*3 + col + 1.
                                 
0000c0 e04a                      			ldi temp2, 10 ;multiply temp3 by 10
0000c1 9f54                      			mul temp3, temp2
0000c2 2d50                      			mov temp3, r0
0000c3 0f50                      			add temp3, temp ;then add the curr num value
                                 
0000c4 e340                      			ldi temp2, AsciiNum
0000c5 0f04                      			add temp, temp2
0000c6 940c 00df                 			jmp convert_end
                                 
                                 		letters:
0000c8 e001                      			ldi temp, 1
0000c9 9508                      			ret
                                 
                                 		symbols:
0000ca 3020                      			cpi col, 0 ; check if we have a star
0000cb f021                      			breq star
0000cc 3021                      			cpi col, 1 ; or if we have zero
0000cd f069                      			breq zero
0000ce e001                      			ldi temp, 1
0000cf 9508                      			ret
                                 			;jmp Keypad_numbers ;hash so return to keypad check
                                 
                                 		star: ;either store temp3 or clear it and err message
0000d0 305b                      			cpi temp3, 11 ;same or higher than 11 is err
0000d1 f4a0                      			brsh convert_numbers_error
0000d2 3050                      			cpi temp3, 0
0000d3 f091                      			breq convert_numbers_error
0000d4 9563                      			inc temp4
0000d5 d489                      			rcall delay_30ms
0000d6 e001
0000d7 d455
0000d8 d46e                      			do_lcd_command 0b1
0000d9 2700                      			clr temp
0000da 9508                      			ret
                                 			;jmp Keypad_numbers_start ;success so print new question
                                 
                                 		zero:
0000db e04a                      			ldi temp2, 10
0000dc 9f54                      			mul temp3, temp2
0000dd 2d50                      			mov temp3, r0
0000de e300                      			ldi temp, AsciiNum ; set to zero
                                 
                                 		convert_end:
0000df 2f00
0000e0 d457
0000e1 d465                      			mov_lcd_data temp ; write value to LCD
0000e2 940e 055f                 			call delay_30ms
0000e4 e001                      			ldi temp, 1
0000e5 9508                      			ret
                                 			;jmp Keypad_numbers ; return to keypad checker
                                 
                                 		convert_numbers_error:
0000e6 e002                      			ldi temp, 2
0000e7 9508                      			ret
                                 
                                 ;//=== Convertion Numbers End ===\\
                                 
                                 ;//=== Convertion Characters Start ===\\
                                 	; Using row and col, determine which key was pressed
                                 	;    @0 is the register location to store result
                                 	.macro determine_key_press
                                 		; Key number value (1-9) is (row * 3) + col + 1
                                 		mov @0, row
                                 		lsl @0
                                 		add @0, row 
                                 		add @0, col 
                                 		inc @0
                                 	.endmacro
                                 
                                 	; Translates and stores (in SRAM) valid keypad presses into capital letters.
                                 	;    Achieves this by first reading a 'character position' specified by column 3 key selection
                                 	;       i.e. 'A' represents character position 0, 'B' as position 1, ... and 'C' as position 4 (if applicable)
                                 	;    Followed by selecting the desired keypad 'character block'
                                 	;       Example: character position 'A' (position 0) for keypad character block '2' returns capital letter 'A'
                                 	character_convert:
                                 
                                 		; Keys in the column 3 determine character position for the keypad character block which in turn 
                                 		;    determines the character selection
0000e8 3023                      		cpi col, LAST_COLUMN
0000e9 f1f1                      		breq store_position_selection
                                 
                                 		; Check for zero or hash key presses
                                 		;     D key should be caught by the above case before this one
                                 		;         Only valid ones here are [*,0,#]
0000ea 3013                      		cpi row, 3 
0000eb f109                      		breq zero_or_hash
                                 
                                 		; Check whether or not a position has been saved into position selection register
                                 		;    Return to caller if position has not been stored i.e. go back to listening for keypad press
0000ec 3054                      		cpi temp3, UNSET_POSITION
0000ed f159                      		breq character_convert_end
                                 
                                 		; Character conversion entry point
                                 		;    Use character position selection and keypad character block selection to determine capital letter
0000ee 2f01
0000ef 0f00
0000f0 0f01
0000f1 0f02
0000f2 9503                      		determine_key_press temp
                                 
                                 		; Case where character block 1 is pressed
                                 		;    No letters are present in this block therefore do nothing
0000f3 3001                      		cpi temp, 1
0000f4 f121                      		breq character_convert_end
                                 		
                                 		; Character conversion core algo
                                 		;    (key_distance_from_2 * 3) + 'A' + position_selection where, key_distance_from_2 = key press - 2,
                                 		;        'A' is decimal value 65 and position_selection is character position selection
0000f5 5002                      		subi temp, 2 ; calculate key_distance_from_2
0000f6 2f40                      		mov temp2, temp ; store result to temp2
                                 
                                 		; Multiply key_distance_from_2 by 3 which gives the character distance from '65'
                                 		;    (key_distance_from_2 * 2) + key_distance_from_2 = (key_distance_from_2 * 3) = Character distance from '65'
0000f7 0f00                      		lsl temp
0000f8 0f04                      		add temp, temp2
                                 
                                 		; Add calculated character distance from 'A' (the origin/ start)
0000f9 e441                      		ldi temp2, 'A'
0000fa 0f04                      		add temp, temp2
                                 
0000fb 2f41
0000fc 0f44
0000fd 0f41
0000fe 0f42
0000ff 9543                      		determine_key_press temp2 ; temp overwritten, we can determine the original key press as we still have row, col values saved 
                                 
                                 		; Position selection addition
                                 		;   Case where postion selection is 3
                                 		;      Need to catch this case for character blocks 7 and 9 as they have 4 character selections to choose from
                                 		;         i.e. Block 7 = [P,Q,R,S] and Block 9 = [W,X,Y,Z]
                                 		
000100 94f3                      		inc r15 ;Increase r15
000101 b8f8                      		out PORTC, r15
                                 
000102 3048                      		cpi temp2, 8
000103 f008                      		brlo normalPositionAddition
000104 9503                      		inc temp		
                                 
                                 		normalPositionAddition:
000105 3053                      		cpi temp3, LAST_COLUMN
000106 f119                      		breq last_position_selection
                                 		
                                 		; Position selection anything but last column
000107 0f05                      		add temp, temp3
000108 2744                      		clr temp2 
                                 
000109 307a                      		cpi temp5, MAX_CHARACTERS
00010a f549                      		brne not_max_chars ; do nothing if we've reached max characters, just waiting for end of input
                                 
00010b 940c 0119                 		jmp character_convert_end
                                 
                                 		; *** Character convert helpers ***
                                 		zero_or_hash:
00010d 3021                      			cpi col, 1 ; zero represents white space character
00010e f021                      			breq white_space
                                 
00010f 3020                      			cpi col, 0 ; hash represents end of input
000110 f059                      			breq end_of_input
                                 
                                 			; otherwise do nothing
000111 940c 0119                 			jmp character_convert_end
                                 
                                 		white_space:
000113 e200                      			ldi temp, ' '
                                 
                                 			;dec r15 ;Decrease if space
000114 b8f8                      			out PORTC, r15
                                 
                                 			; do nothing if we've reached max characters, just waiting for end of input
000115 307a                      			cpi temp5, MAX_CHARACTERS
000116 f4e9                      			brne not_max_chars
                                 
000117 940c 0119                 			jmp character_convert_end
                                 		
                                 		character_convert_end:
                                 			; reset the position_selection
000119 e054                      			ldi temp3, 4
00011a d44b                      			rcall delay_10ms
00011b 9508                      			ret ; return to caller
                                 		
                                 		end_of_input:
                                 			; Calculate how many memory addresses we need to pad by
00011c e00a                      			ldi temp, MAX_CHARACTERS
00011d 2f47                      			mov temp2, temp5
00011e 1b04                      			sub temp, temp2 ; MAX_CHARACTERS - character_count = Padding
00011f e240                      			ldi temp2, ' ' ; Character to write to memory
                                 
000120 3000                      			cpi temp, 0 ; No padding required
000121 f019                      			breq end_of_input_exit
                                 
                                 			memory_padding:
000122 9341                      				st z+, temp2
000123 950a                      				dec temp ; Pad this amount of times
000124 f7e9                      				brne memory_padding
                                 
                                 			end_of_input_exit:
000125 e27a                      				ldi temp5, '*'
000126 940c 0119                 				jmp character_convert_end
                                 		
                                 		; *** Position selection helpers ***
                                 		store_position_selection:
                                 			; Row is the character position to be used on next key press
000128 2f51                      			mov temp3, row 
000129 9508                      			ret 
                                 
                                 		; *** Character conversion core helpers ***
                                 		last_position_selection:
                                 			; Catches the case where blocks 1-6 and last position asked for 
00012a 3047                      			cpi temp2, 7
                                 			; Go back to listening for a key press
00012b f368                      			brlo character_convert_end
                                 
00012c 3048                      			cpi temp2, 8 ; Catches the case for block 8
00012d f359                      			breq character_convert_end
                                 
                                 			; Anything here has a valid last position selection
00012e 0f05                      			add temp, temp3
00012f 2744                      			clr temp2
                                 
                                 			; do nothing if we've reached max characters, just waiting for end of input
000130 307a                      			cpi temp5, MAX_CHARACTERS
000131 f411                      			brne not_max_chars
                                 
000132 940c 0119                 			jmp character_convert_end
                                 
                                 		not_max_chars:
                                 			; store in next memory address 
000134 9301                      			st z+, temp
                                 			; output this character onto LCD
000135 2f00
000136 d401
000137 d40f                      			mov_lcd_data temp
                                 			
000138 d426                      			rcall delay_30ms
000139 9573                      			inc temp5
00013a 9508                      			ret
                                 ;//=== Convertion Characters End ===\\
                                 
                                 ;//=== Stations Names ===\\
                                 	; Prompts for a station name
                                 	; @0 is the current station number
                                 	.macro station_name_prompt
                                 		inc @0
                                 		do_lcd_command 0b00000001
                                 		do_lcd_data 'S'
                                 		do_lcd_data 'T'
                                 		do_lcd_data 'A'
                                 		do_lcd_data 'T'
                                 		do_lcd_data 'I'
                                 		do_lcd_data 'O'
                                 		do_lcd_data 'N'
                                 		do_lcd_data ' '
                                 		ldi temp, 0b00110000
                                 		add temp, @0
                                 		mov_lcd_data temp
                                 		do_lcd_data ' '
                                 		do_lcd_data 'N'
                                 		do_lcd_data 'A'
                                 		do_lcd_data 'M'
                                 		do_lcd_data 'E'
                                 		do_lcd_data ':'
                                 		do_lcd_command 0b11000000
                                 		dec @0
                                 	.endmacro
                                 
                                 	read_in_stations_end:
00013b 9508                      		ret
                                 
                                 	read_in_stations:
00013c e0e0                      		ldi zl, low(array)
00013d e0f2                      		ldi zh, high(array)
00013e e054                      		ldi temp3, 4
00013f e060                      		ldi temp4, 0
000140 2777                      		clr temp5
                                 
                                 		read_in_stations_start:
000141 24ff                      			clr r15
000142 1768                      			cp temp4, stationNum
000143 f3b9                      			breq read_in_stations_end
000144 2777                      			clr temp5
000145 9563
000146 e001
000147 d3e5
000148 d3fe
000149 e503
00014a d3ed
00014b d3fb
00014c e504
00014d d3ea
00014e d3f8
00014f e401
000150 d3e7
000151 d3f5
000152 e504
000153 d3e4
000154 d3f2
000155 e409
000156 d3e1
000157 d3ef
000158 e40f
000159 d3de
00015a d3ec
00015b e40e
00015c d3db
00015d d3e9
00015e e200
00015f d3d8
000160 d3e6
000161 e300
000162 0f06
000163 2f00
000164 d3d3
000165 d3e1
000166 e200
000167 d3d0
000168 d3de
000169 e40e
00016a d3cd
00016b d3db
00016c e401
00016d d3ca
00016e d3d8
00016f e40d
000170 d3c7
000171 d3d5
000172 e405
000173 d3c4
000174 d3d2
000175 e30a
000176 d3c1
000177 d3cf
000178 ec00
000179 d3b3
00017a d3cc
00017b 956a                      			station_name_prompt temp4
00017c 940c 017e                 			jmp read_in_stations_loop
                                 			
                                 			read_in_stations_loop:
00017e df1b                      				rcall keypad
00017f df68                      				rcall character_convert
                                 
000180 327a                      				cpi temp5, '*'
000181 f7e1                      				brne read_in_stations_loop
                                 
000182 e000                      				ldi temp , 0
000183 16f0                      				cp r15, temp
000184 f021                      				breq read_in_stations_error
                                 
000185 9563                      				inc temp4
                                 				;do_lcd_data '@'			
                                 				;ascii_print temp4			Print currStation
                                 				;ascii_print stationNum		Print max No. stations
000186 d3d3                      				rcall delay_100ms
000187 940c 0141                 				jmp read_in_stations_start
                                 
                                 		read_in_stations_error:
000189 973a                      			sbiw z, 10
00018a e07a                      			ldi temp5, 10
                                 			read_in_stations_error_loop:
00018b e200                      				ldi temp, ' '
00018c 9301                      				st z+, temp
00018d 957a                      				dec temp5
00018e f7e1                      				brne read_in_stations_error_loop
00018f 973a                      			sbiw z, 10
000190 e001
000191 d39b
000192 d3b4                      			do_lcd_command 0b1
000193 e405
000194 d3a3
000195 d3b1                      			do_lcd_data 'E'
000196 e702
000197 d3a0
000198 d3ae                      			do_lcd_data 'r'
000199 e702
00019a d39d
00019b d3ab                      			do_lcd_data	'r'
00019c e60f
00019d d39a
00019e d3a8                      			do_lcd_data 'o'
00019f e702
0001a0 d397
0001a1 d3a5                      			do_lcd_data 'r'
0001a2 e200
0001a3 d394
0001a4 d3a2                      			do_lcd_data ' '
0001a5 d3b4                      			rcall delay_100ms
0001a6 cf9a                      			rjmp read_in_stations_start
                                 
                                 ;//=== Stations Names End ===\
                                 
                                 ;//=== Max Stations Start ===\\
                                 	.macro askForNumStation
                                 		do_lcd_command 0b1
                                 		do_lcd_data 'N'
                                 		do_lcd_data 'u'
                                 		do_lcd_data	'm'
                                 		do_lcd_data 'b'
                                 		do_lcd_data 'e'
                                 		do_lcd_data 'r'
                                 		do_lcd_data ' '
                                 		do_lcd_data 'o'
                                 		do_lcd_data 'f'
                                 		do_lcd_command 0b11000000 ;second line
                                 		do_lcd_data 'S'
                                 		do_lcd_data 't'
                                 		do_lcd_data 'a'
                                 		do_lcd_data	't'
                                 		do_lcd_data 'i'
                                 		do_lcd_data 'o'
                                 		do_lcd_data 'n'
                                 		do_lcd_data 's'
                                 		do_lcd_data ':'
                                 	.endmacro
                                 	maxStations_end: 
0001a7 9508                      		ret
                                 	maxStations:
0001a8 2766                      		clr temp4
                                 	maxStations_start:
0001a9 3061                      		cpi temp4, 1
0001aa f3e1                      		breq maxStations_end
0001ab 2755                      		clr temp3
0001ac e001
0001ad d37f
0001ae d398
0001af e40e
0001b0 d387
0001b1 d395
0001b2 e705
0001b3 d384
0001b4 d392
0001b5 e60d
0001b6 d381
0001b7 d38f
0001b8 e602
0001b9 d37e
0001ba d38c
0001bb e605
0001bc d37b
0001bd d389
0001be e702
0001bf d378
0001c0 d386
0001c1 e200
0001c2 d375
0001c3 d383
0001c4 e60f
0001c5 d372
0001c6 d380
0001c7 e606
0001c8 d36f
0001c9 d37d
0001ca ec00
0001cb d361
0001cc d37a
0001cd e503
0001ce d369
0001cf d377
0001d0 e704
0001d1 d366
0001d2 d374
0001d3 e601
0001d4 d363
0001d5 d371
0001d6 e704
0001d7 d360
0001d8 d36e
0001d9 e609
0001da d35d
0001db d36b
0001dc e60f
0001dd d35a
0001de d368
0001df e60e
0001e0 d357
0001e1 d365
0001e2 e703
0001e3 d354
0001e4 d362
0001e5 e30a
0001e6 d351
0001e7 d35f                      		askForNumStation
0001e8 940c 01ea                 		jmp maxStations_loop
                                 
                                 	maxStations_loop: 
0001ea deaf                      		rcall keypad
0001eb decb                      		rcall convert_numbers
0001ec 3001                      		cpi temp, 1 ;not num repeat
0001ed f3e1                      		breq maxStations_loop
0001ee 3002                      		cpi temp, 2 ;big num error
0001ef f021                      		breq maxStations_error_message
0001f0 3052                      		cpi temp3, 2 ;lower than 2 error
0001f1 f0c8                      		brlo maxStations_error_message2
0001f2 2f85                      		mov stationNum, temp3
0001f3 cfb5                      		rjmp maxStations_start ;correct num
                                 
                                 	maxStations_error_message:
0001f4 e001
0001f5 d337
0001f6 d350                      		do_lcd_command 0b1
0001f7 e405
0001f8 d33f
0001f9 d34d                      		do_lcd_data 'E'
0001fa e702
0001fb d33c
0001fc d34a                      		do_lcd_data 'r'
0001fd e702
0001fe d339
0001ff d347                      		do_lcd_data	'r'
000200 e60f
000201 d336
000202 d344                      		do_lcd_data 'o'
000203 e702
000204 d333
000205 d341                      		do_lcd_data 'r'
000206 e200
000207 d330
000208 d33e                      		do_lcd_data ' '
000209 d355                      		rcall delay_30ms
00020a cf9e                      		rjmp maxStations_start
                                 
                                 	maxStations_error_message2:
00020b e001
00020c d320
00020d d339                      		do_lcd_command 0b1
00020e e405
00020f d328
000210 d336                      		do_lcd_data 'E'
000211 e702
000212 d325
000213 d333                      		do_lcd_data 'r'
000214 e702
000215 d322
000216 d330                      		do_lcd_data	'r'
000217 e60f
000218 d31f
000219 d32d                      		do_lcd_data 'o'
00021a e702
00021b d31c
00021c d32a                      		do_lcd_data 'r'
00021d e200
00021e d319
00021f d327                      		do_lcd_data ' '
000220 e30c
000221 d316
000222 d324                      		do_lcd_data '<'
000223 e302
000224 d313
000225 d321                      		do_lcd_data '2'
000226 d333                      		rcall delay_100ms
000227 2766                      		clr temp4
000228 cf80                      		rjmp maxStations_start
                                 ;//=== Max Stations End ===\\
                                 
                                 ;//=== Loading Bar Start ===\\
                                 	next_section:
                                 		;message
000229 e001
00022a d302
00022b d31b                      		do_lcd_command 0b1
00022c e500
00022d d30a
00022e d318                      		do_lcd_data 'P'
00022f d32f                      		rcall delay_30ms
000230 e40c
000231 d306
000232 d314                      		do_lcd_data 'L'
000233 d32b                      		rcall delay_30ms
000234 e405
000235 d302
000236 d310                      		do_lcd_data	'E'
000237 d327                      		rcall delay_30ms
000238 e401
000239 d2fe
00023a d30c                      		do_lcd_data 'A'
00023b d323                      		rcall delay_30ms
00023c e503
00023d d2fa
00023e d308                      		do_lcd_data 'S'
00023f d31f                      		rcall delay_30ms
000240 e405
000241 d2f6
000242 d304                      		do_lcd_data 'E'
000243 d31b                      		rcall delay_30ms
000244 e200
000245 d2f2
000246 d300                      		do_lcd_data ' '
000247 e507
000248 d2ef
000249 d2fd                      		do_lcd_data 'W'
00024a d314                      		rcall delay_30ms
00024b e401
00024c d2eb
00024d d2f9                      		do_lcd_data 'A'
00024e d310                      		rcall delay_30ms
00024f e409
000250 d2e7
000251 d2f5                      		do_lcd_data 'I'
000252 d30c                      		rcall delay_30ms
000253 e504
000254 d2e3
000255 d2f1                      		do_lcd_data 'T'
000256 d308                      		rcall delay_30ms
000257 ec00
000258 d2d4
000259 d2ed                      		do_lcd_command 0b11000000
00025a e40c
00025b d2dc
00025c d2ea                      		do_lcd_data 'L'
00025d d301                      		rcall delay_30ms
00025e e40f
00025f d2d8
000260 d2e6                      		do_lcd_data 'O'
000261 d2fd                      		rcall delay_30ms
000262 e401
000263 d2d4
000264 d2e2                      		do_lcd_data 'A'
000265 d2f9                      		rcall delay_30ms
000266 e404
000267 d2d0
000268 d2de                      		do_lcd_data 'D'
000269 d2f5                      		rcall delay_30ms
00026a e409
00026b d2cc
00026c d2da                      		do_lcd_data 'I'
00026d d2f1                      		rcall delay_30ms
00026e e40e
00026f d2c8
000270 d2d6                      		do_lcd_data 'N'
000271 d2ed                      		rcall delay_30ms
000272 e407
000273 d2c4
000274 d2d2                      		do_lcd_data 'G'
000275 d2e9                      		rcall delay_30ms
000276 2744                      		clr temp2
                                 		next_section_loop:
000277 9543                      		inc temp2
000278 e20d
000279 d2be
00027a d2cc                      		do_lcd_data 0b00101101
00027b e100
00027c d2b0
00027d d2c9                      		do_lcd_command 0b10000 ;go back one
00027e d2db                      		rcall delay_100ms
00027f e20f
000280 d2b7
000281 d2c5                      		do_lcd_data 0b00101111
000282 e100
000283 d2a9
000284 d2c2                      		do_lcd_command 0b10000
000285 d2d4                      		rcall delay_100ms
000286 e70c
000287 d2b0
000288 d2be                      		do_lcd_data 0b01111100
000289 e100
00028a d2a2
00028b d2bb                      		do_lcd_command 0b10000
00028c d2cd                      		rcall delay_100ms
00028d ec0d
00028e d2a9
00028f d2b7                      		do_lcd_data 0b11001101
000290 e100
000291 d29b
000292 d2b4                      		do_lcd_command 0b10000
000293 d2c6                      		rcall delay_100ms
000294 3041                      		cpi temp2, 1
000295 f308                      		brlo next_section_loop
000296 9508                      		ret
                                 ;//=== Loading Bar End ===\\
                                 
                                 ;//=== Time Between Stations Start ===\\
                                 	.macro endWrap ;num
                                 		;inc num unless its at the max then wrap around
                                 		ldi temp, AsciiNum
                                 		sub @0, temp
                                 		cp @0, stationNum
                                 		brlo endWrap_end
                                 		sub @0, stationNum
                                 		endWrap_end:
                                 		inc @0
                                 		ldi temp, AsciiNum
                                 		add @0, temp
                                 	.endmacro
                                 	.macro Askfortime
                                 		do_lcd_data 'T'
                                 		do_lcd_data 'i'
                                 		do_lcd_data	'm'
                                 		do_lcd_data 'e'
                                 		do_lcd_data ' '
                                 		do_lcd_data 'f'
                                 		do_lcd_data 'r'
                                 		do_lcd_data 'o'
                                 		do_lcd_data 'm'
                                 		do_lcd_data ' '
                                 		do_lcd_command 0b11000000
                                 		do_lcd_data 'S'
                                 		ldi temp2, AsciiNum
                                 		add temp2, temp4
                                 		endWrap temp2
                                 		mov_lcd_data temp2
                                 		do_lcd_data ' '
                                 		do_lcd_data 't'
                                 		do_lcd_data 'o'
                                 		do_lcd_data ' '
                                 		do_lcd_data 'S'
                                 		endWrap temp2
                                 		mov_lcd_data temp2
                                 		do_lcd_data ':'
                                 	.endmacro
                                 	timeBetweenStations_end:
000297 916a                      		ld temp4, -Y ;load in last value
000298 e6ce                      		ldi YL, low(times)
000299 e0d2                      		ldi YH, high(times)
00029a 8368                      		st y, temp4 ;store last value, see bellow note
00029b 9508                      		ret
                                 	timeBetweenStations:
00029c e001
00029d d28f
00029e d2a8                      		do_lcd_command 0b1
00029f 9169                      		ld temp4, y+ ;====================================================== NOTE SHIFTING ONE PLACE FOR STORAGE TECH WHERE THE LAST STATION TO FIRST STATION TIME IS STORED AT THE START
0002a0 2766                      		clr temp4
                                 		
                                 	timeBetweenStations_start:
0002a1 1768                      		cp temp4, stationNum
0002a2 f3a1                      		breq timeBetweenStations_end
0002a3 2755                      		clr temp3
0002a4 e504
0002a5 d292
0002a6 d2a0
0002a7 e609
0002a8 d28f
0002a9 d29d
0002aa e60d
0002ab d28c
0002ac d29a
0002ad e605
0002ae d289
0002af d297
0002b0 e200
0002b1 d286
0002b2 d294
0002b3 e606
0002b4 d283
0002b5 d291
0002b6 e702
0002b7 d280
0002b8 d28e
0002b9 e60f
0002ba d27d
0002bb d28b
0002bc e60d
0002bd d27a
0002be d288
0002bf e200
0002c0 d277
0002c1 d285
0002c2 ec00
0002c3 d269
0002c4 d282
0002c5 e503
0002c6 d271
0002c7 d27f
0002c8 e340
0002c9 0f46
0002ca e300
0002cb 1b40
0002cc 1748
0002cd f008
0002ce 1b48
0002cf 9543
0002d0 e300
0002d1 0f40
0002d2 2f04
0002d3 d264
0002d4 d272
0002d5 e200
0002d6 d261
0002d7 d26f
0002d8 e704
0002d9 d25e
0002da d26c
0002db e60f
0002dc d25b
0002dd d269
0002de e200
0002df d258
0002e0 d266
0002e1 e503
0002e2 d255
0002e3 d263
0002e4 e300
0002e5 1b40
0002e6 1748
0002e7 f008
0002e8 1b48
0002e9 9543
0002ea e300
0002eb 0f40
0002ec 2f04
0002ed d24a
0002ee d258
0002ef e30a
0002f0 d247
0002f1 d255                      		Askfortime
0002f2 940c 02f4                 		jmp timeBetweenStations_loop
                                 	timeBetweenStations_loop: 
0002f4 dda5                      		rcall keypad
0002f5 ddc1                      		rcall convert_numbers
0002f6 3001                      		cpi temp, 1 ;not num repeat
0002f7 f3e1                      		breq timeBetweenStations_loop
0002f8 3002                      		cpi temp, 2 ;big num error
0002f9 f011                      		breq timeBetweenStations_error_message
                                 		;correct number stored into y
0002fa 9359                      		st y+, temp3 ;store the correct num into y
0002fb cfa5                      		rjmp timeBetweenStations_start
                                 
                                 	timeBetweenStations_error_message:
0002fc e001
0002fd d22f
0002fe d248                      		do_lcd_command 0b1
0002ff e405
000300 d237
000301 d245                      		do_lcd_data 'E'
000302 e702
000303 d234
000304 d242                      		do_lcd_data 'r'
000305 e702
000306 d231
000307 d23f                      		do_lcd_data	'r'
000308 e60f
000309 d22e
00030a d23c                      		do_lcd_data 'o'
00030b e702
00030c d22b
00030d d239                      		do_lcd_data 'r'
00030e e200
00030f d228
000310 d236                      		do_lcd_data ' '
                                 		
                                 
000311 d24d                      		rcall delay_30ms
000312 ec00
000313 d219
000314 d232                      		do_lcd_command 0b11000000 ;second row
000315 940c 02a1                 		jmp timeBetweenStations_start ;restart
                                 ;//=== Time Between Station End ===\\
                                 
                                 ;//=== Stop Time Request Start ===\\
                                 	.macro askForStopTime
                                 		do_lcd_command 0b1
                                 		do_lcd_data 'S'
                                 		do_lcd_data 't'
                                 		do_lcd_data	'o'
                                 		do_lcd_data 'p'
                                 		do_lcd_data ' '
                                 		do_lcd_data 't'
                                 		do_lcd_data 'i'
                                 		do_lcd_data 'm'
                                 		do_lcd_data 'e'
                                 		do_lcd_data ' '
                                 		do_lcd_data 'i'
                                 		do_lcd_data 's'
                                 		do_lcd_data	' '
                                 		do_lcd_command 0b11000000 ;second line
                                 		do_lcd_data ' '
                                 		do_lcd_data ' '
                                 		do_lcd_data ' '
                                 		do_lcd_data 's'
                                 		do_lcd_data 'e'
                                 		do_lcd_data 'c'
                                 		do_lcd_data 'o'
                                 		do_lcd_data 'n'
                                 		do_lcd_data 'd'
                                 		do_lcd_data 's'
                                 		clr temp2
                                 		back_10_loop:
                                 			do_lcd_command 0b10000 ;go back one
                                 			inc temp2
                                 		cpi temp2, 10
                                 		brlo back_10_loop
                                 	.endmacro
                                 	stopTimeRequest_end: 
000317 9508                      		ret
                                 	stopTimeRequest:
000318 2766                      		clr temp4
                                 	stopTimeRequest_start:
000319 3061                      		cpi temp4, 1
00031a f3e1                      		breq stopTimeRequest_end
00031b 2755                      		clr temp3
00031c e001
00031d d20f
00031e d228
00031f e503
000320 d217
000321 d225
000322 e704
000323 d214
000324 d222
000325 e60f
000326 d211
000327 d21f
000328 e700
000329 d20e
00032a d21c
00032b e200
00032c d20b
00032d d219
00032e e704
00032f d208
000330 d216
000331 e609
000332 d205
000333 d213
000334 e60d
000335 d202
000336 d210
000337 e605
000338 d1ff
000339 d20d
00033a e200
00033b d1fc
00033c d20a
00033d e609
00033e d1f9
00033f d207
000340 e703
000341 d1f6
000342 d204
000343 e200
000344 d1f3
000345 d201
000346 ec00
000347 d1e5
000348 d1fe
000349 e200
00034a d1ed
00034b d1fb
00034c e200
00034d d1ea
00034e d1f8
00034f e200
000350 d1e7
000351 d1f5
000352 e703
000353 d1e4
000354 d1f2
000355 e605
000356 d1e1
000357 d1ef
000358 e603
000359 d1de
00035a d1ec
00035b e60f
00035c d1db
00035d d1e9
00035e e60e
00035f d1d8
000360 d1e6
000361 e604
000362 d1d5
000363 d1e3
000364 e703
000365 d1d2
000366 d1e0
000367 2744
000368 e100
000369 d1c3
00036a d1dc
00036b 9543
00036c 304a
00036d f3d0                      		askForStopTime
00036e 940c 0370                 		jmp stopTimeRequest_loop
                                 	stopTimeRequest_loop: 
000370 dd29                      		rcall keypad
000371 dd45                      		rcall convert_numbers
000372 3001                      		cpi temp, 1 ;not num repeat
000373 f3e1                      		breq stopTimeRequest_loop
000374 305b                      		cpi temp3, 11 ;big num error
000375 f420                      		brsh stopTimeRequest_error_message
000376 3052                      		cpi temp3, 2 ;lower than 2 error
000377 f110                      		brlo stopTimeRequest_error_message2
                                 		
000378 2e65                      		mov stoptime, temp3
000379 cf9f                      		rjmp stopTimeRequest_start ;correct num
                                 	stopTimeRequest_error_message:
00037a e001
00037b d1b1
00037c d1ca                      		do_lcd_command 0b1
00037d e405
00037e d1b9
00037f d1c7                      		do_lcd_data 'E'
000380 e702
000381 d1b6
000382 d1c4                      		do_lcd_data 'r'
000383 e702
000384 d1b3
000385 d1c1                      		do_lcd_data	'r'
000386 e60f
000387 d1b0
000388 d1be                      		do_lcd_data 'o'
000389 e702
00038a d1ad
00038b d1bb                      		do_lcd_data 'r'
00038c e200
00038d d1aa
00038e d1b8                      		do_lcd_data ' '
00038f e30e
000390 d1a7
000391 d1b5                      		do_lcd_data '>'
000392 e301
000393 d1a4
000394 d1b2                      		do_lcd_data '1'
000395 e300
000396 d1a1
000397 d1af                      		do_lcd_data '0'
000398 d1c1                      		rcall delay_100ms
000399 cf7f                      		rjmp stopTimeRequest_start
                                 	stopTimeRequest_error_message2:
00039a e001
00039b d191
00039c d1aa                      		do_lcd_command 0b1
00039d e405
00039e d199
00039f d1a7                      		do_lcd_data 'E'
0003a0 e702
0003a1 d196
0003a2 d1a4                      		do_lcd_data 'r'
0003a3 e702
0003a4 d193
0003a5 d1a1                      		do_lcd_data	'r'
0003a6 e60f
0003a7 d190
0003a8 d19e                      		do_lcd_data 'o'
0003a9 e702
0003aa d18d
0003ab d19b                      		do_lcd_data 'r'
0003ac e200
0003ad d18a
0003ae d198                      		do_lcd_data ' '
0003af e30c
0003b0 d187
0003b1 d195                      		do_lcd_data '<'
0003b2 e302
0003b3 d184
0003b4 d192                      		do_lcd_data '2'
0003b5 d1a4                      		rcall delay_100ms
0003b6 2766                      		clr temp4
0003b7 cf61                      		rjmp stopTimeRequest_start
                                 ;//=== Stop Time Request End ===\\
                                 
                                 ;//=== Read and Print Stations Start ===\\
                                 	.macro	PrintName
                                 		;"Next:" message
                                 			do_lcd_command 0b1
                                 			do_lcd_data 'N'
                                 			rcall delay_10ms
                                 			do_lcd_data 'E'
                                 			rcall delay_10ms
                                 			do_lcd_data 'X'
                                 			rcall delay_10ms
                                 			do_lcd_data 'T'
                                 			rcall delay_10ms
                                 			do_lcd_data ':'
                                 
                                 		;Name of Next Stop
                                 		clr r1
                                 		Loop_PN:
                                 			ld temp, z+
                                 			mov_lcd_data temp
                                 			inc r1
                                 			ldi temp, 10
                                 			cp r1, temp
                                 			brlo Loop_PN
                                 		;do_lcd_data '@'
                                 		rcall delay_100ms
                                 	.endmacro
                                 	
                                 	.macro hashCheck
                                 		push temp2
                                 		ldi mask, hashcol
                                 		sts PORTL, mask
                                 		ldi temp, 0xFF
                                 		hashCheck_stablisation:
                                 			dec temp2
                                 			brne hashCheck_stablisation
                                 		LDS temp2, PINL
                                 		andi temp2, ROWMASK
                                 		cpi temp2, ROWMASK
                                 		breq zeroReturn
                                 		ldi mask, hashrow
                                 		and temp2, mask
                                 		brne zeroReturn
                                 		ldi temp, 0xFF
                                 		mov @0, temp
                                 		out PORTC, temp
                                 		rcall delay_100ms
                                 		rjmp hashCheck_end
                                 
                                 		zeroReturn:
                                 			clr @0
                                 		hashCheck_end:
                                 		pop temp2
                                 	.endmacro
                                 
                                 	hashInterrupt:
                                 		;"EMERGENCY STOP" message
0003b8 ec00
0003b9 d173
0003ba d18c                      			do_lcd_command 0b11000000
0003bb e405
0003bc d17b
0003bd d189                      			do_lcd_data 'E'
0003be d1a7                      			rcall delay_10ms
0003bf e40d
0003c0 d177
0003c1 d185                      			do_lcd_data 'M'
0003c2 d1a3                      			rcall delay_10ms
0003c3 e405
0003c4 d173
0003c5 d181                      			do_lcd_data 'E'
0003c6 d19f                      			rcall delay_10ms
0003c7 e502
0003c8 d16f
0003c9 d17d                      			do_lcd_data 'R'
0003ca d19b                      			rcall delay_10ms
0003cb e407
0003cc d16b
0003cd d179                      			do_lcd_data 'G'
0003ce d197                      			rcall delay_10ms
0003cf e405
0003d0 d167
0003d1 d175                      			do_lcd_data 'E'
0003d2 d193                      			rcall delay_10ms
0003d3 e40e
0003d4 d163
0003d5 d171                      			do_lcd_data 'N'
0003d6 d18f                      			rcall delay_10ms
0003d7 e403
0003d8 d15f
0003d9 d16d                      			do_lcd_data 'C'
0003da d18b                      			rcall delay_10ms
0003db e509
0003dc d15b
0003dd d169                      			do_lcd_data 'Y'
0003de d187                      			rcall delay_10ms
0003df e200
0003e0 d157
0003e1 d165                      			do_lcd_data ' '
0003e2 d183                      			rcall delay_10ms
0003e3 e503
0003e4 d153
0003e5 d161                      			do_lcd_data 'S'
0003e6 d17f                      			rcall delay_10ms
0003e7 e504
0003e8 d14f
0003e9 d15d                      			do_lcd_data 'T'
0003ea d17b                      			rcall delay_10ms
0003eb e40f
0003ec d14b
0003ed d159                      			do_lcd_data 'O'
0003ee d177                      			rcall delay_10ms
0003ef e500
0003f0 d147
0003f1 d155                      			do_lcd_data 'P'
0003f2 d173                      			rcall delay_10ms
                                 		
                                 
0003f3 92cf                      		push r12
0003f4 24cc                      		clr r12
0003f5 e000                      		ldi temp, 0
0003f6 9300 00ac                 		sts OCR4CL, temp
0003f8 9300 00ad                 		sts OCR4CH, temp
                                 
                                 		interrupt_loop:
0003fa 934f
0003fb eb3f
0003fc 9330 010b
0003fe ef0f
0003ff 954a
000400 f7f1
000401 9140 0109
000403 704f
000404 304f
000405 f041
000406 e038
000407 2343
000408 f429
000409 ef0f
00040a 2f00
00040b b908
00040c d14d
00040d c001
00040e 2700
00040f 914f                      			hashCheck temp
000410 fd00                      			sbrc temp, 0
000411 c00f                      			rjmp hashInterrupt_end
                                 
000412 d153                      			rcall delay_10ms
000413 94c3                      			inc r12
000414 e104                      			ldi temp, 20
000415 16c0                      			cp r12, temp
000416 f318                      			brlo interrupt_loop
000417 e003                      			ldi temp, 0b11
000418 b908                      			out PORTC, temp
                                 
000419 e201                      			ldi temp, 33
00041a 16c0                      			cp r12, temp
00041b f2f0                      			brlo interrupt_loop
00041c e000                      			ldi temp, 0b00
00041d b908                      			out PORTC, temp
00041e e000                      			ldi temp, 0
00041f 2ec0                      			mov r12, temp
000420 cfd9                      			rjmp interrupt_loop
                                 
                                 		hashInterrupt_end:
000421 e000                      		ldi temp, motorSpeed
000422 9300 00ac                 		sts OCR4CL, temp
000424 2700                      		clr temp
000425 9300 00ad                 		sts OCR4CH, temp
000427 90cf                      		pop r12
                                 		;Clear "EMERGENCY STOP" message
000428 ec00
000429 d103
00042a d11c                      			do_lcd_command 0b11000000
00042b e200
00042c d10b
00042d d119                      			do_lcd_data ' '
00042e e200
00042f d108
000430 d116                      			do_lcd_data ' '
000431 e200
000432 d105
000433 d113                      			do_lcd_data ' '
000434 e200
000435 d102
000436 d110                      			do_lcd_data ' '
000437 e200
000438 d0ff
000439 d10d                      			do_lcd_data ' '
00043a e200
00043b d0fc
00043c d10a                      			do_lcd_data ' '
00043d e200
00043e d0f9
00043f d107                      			do_lcd_data ' '
000440 e200
000441 d0f6
000442 d104                      			do_lcd_data ' '
000443 e200
000444 d0f3
000445 d101                      			do_lcd_data ' '
000446 e200
000447 d0f0
000448 d0fe                      			do_lcd_data ' '
000449 e200
00044a d0ed
00044b d0fb                      			do_lcd_data ' '
00044c e200
00044d d0ea
00044e d0f8                      			do_lcd_data ' '
00044f e200
000450 d0e7
000451 d0f5                      			do_lcd_data ' '
000452 e200
000453 d0e4
000454 d0f2                      			do_lcd_data ' '
000455 e200
000456 d0e1
000457 d0ef                      			do_lcd_data ' '
000458 e200
000459 d0de
00045a d0ec                      			do_lcd_data ' '
00045b ec00
00045c d0d0
00045d d0e9                      			do_lcd_command 0b11000000
00045e 2422                      			clr r2
                                 			block_loop:
00045f 9423                      				inc r2
000460 ef0f
000461 d0d6
000462 d0e4                      				do_lcd_data 0xff
000463 1423                      				cp r2, r3
000464 f7d1                      				brne block_loop
000465 ea0a                      		ldi temp, 0b10101010
000466 b908                      		out PORTC, temp
000467 9508                      	ret
                                 
                                 	.macro travelling
                                 		push r15
                                 		push r14
                                 		push r13
                                 		sei
                                 		ldi temp, motorSpeed
                                 		sts OCR4CL, temp
                                 		clr temp
                                 		sts OCR4CH, temp
                                 
                                 		ldi temp, 0b10101010
                                 		out PORTC, temp
                                 
                                 		clr r3
                                 		do_lcd_command 0b11000000
                                 		do_lcd_data 0xff
                                 
                                 		mov r14, TravelTime
                                 		travelling_loop:
                                 			inc r3
                                 			ldi temp, 100
                                 			mov r15, temp
                                 			in temp, pinc
                                 			com temp
                                 			out PORTC, temp
                                 			travelling_1s:
                                 				rcall delay_10ms
                                 				hashCheck temp
                                 				sbrc temp, 0
                                 				rcall hashInterrupt
                                 				dec r15
                                 				brne travelling_1s
                                 			do_lcd_data 0xff
                                 			dec r14
                                 			brne travelling_loop
                                 		
                                 		clr temp
                                 		out PORTC, temp
                                 		cli
                                 		pop r13
                                 		pop r14
                                 		pop r15
                                 	.endmacro
                                 
                                 	.macro stopping
                                 		do_lcd_command 0b1
                                 		do_lcd_data 'T'
                                 		do_lcd_data 'R'
                                 		do_lcd_data 'A'
                                 		do_lcd_data 'I'
                                 		do_lcd_data 'N'
                                 		do_lcd_data ' '
                                 		do_lcd_data 'S'
                                 		do_lcd_data 'T'
                                 		do_lcd_data 'O'
                                 		do_lcd_data 'P'
                                 		do_lcd_data 'P'
                                 		do_lcd_data 'I'
                                 		do_lcd_data 'N'
                                 		do_lcd_data 'G'
                                 		do_lcd_command 0b11000000
                                 
                                 		clr temp
                                 		sts OCR4CL, temp
                                 		sts OCR4CH, temp
                                 		mov r15, stoptime
                                 		clr r14
                                 		clr temp
                                 		out PORTC, temp
                                 		stopping_loop:
                                 			ldi temp, 100
                                 			mov r14, temp
                                 			stopping_1s:
                                 				in temp, pinc
                                 				inc temp
                                 				out PORTC, temp
                                 				rcall delay_10ms
                                 				dec r14
                                 				brne stopping_1s
                                 			dec r15
                                 			brne stopping_loop
                                 		ldi temp, 0
                                 		mov r5, temp
                                 	.endmacro
                                 
                                 	RP:
000468 e001
000469 d0c3
00046a d0dc                      		do_lcd_command 0B1
                                 		;do_lcd_data '#'
                                 		;rcall delay_30ms
00046b e0e0                      		ldi zl, low(array)
00046c e0f2                      		ldi zh, high(array)
00046d e6ce                      		ldi yl, low(times)
00046e e0d2                      		ldi yh, high(times)
00046f 2477                      		clr currStation
000470 9473                      		inc currStation
000471 963a                      		adiw z, 10
000472 9109                      		ld temp, y+
000473 9109                      		ld temp, y+
000474 2e80                      		mov TravelTime, temp
                                 
                                 	RP_loop:
000475 e001
000476 d0b6
000477 d0cf
000478 e40e
000479 d0be
00047a d0cc
00047b d0ea
00047c e405
00047d d0ba
00047e d0c8
00047f d0e6
000480 e508
000481 d0b6
000482 d0c4
000483 d0e2
000484 e504
000485 d0b2
000486 d0c0
000487 d0de
000488 e30a
000489 d0ae
00048a d0bc
00048b 2411
00048c 9101
00048d 2f00
00048e d0a9
00048f d0b7
000490 9413
000491 e00a
000492 1610
000493 f3c0
000494 d0c5                      		PrintName
                                 		;do_lcd_data '$'
                                 		;rcall delay_100ms
000495 9473                      		inc currStation
                                 		;ascii_print currStation
                                 		;rcall delay_100ms
                                 		
000496 1678                      		cp currStation, stationNum ;last name check
000497 f028                      		brlo cont ;not last name
                                 		
000498 e0e0                      		ldi zl, low(array)
000499 e0f2                      		ldi zh, high(array)
00049a e6ce                      		ldi yl, low(times)
00049b e0d2                      		ldi yh, high(times)
00049c 2477                      		clr currStation
                                 
                                 		cont:
                                 		;ascii_print TravelTime
                                 		;rcall delay_100ms
00049d 92ff
00049e 92ef
00049f 92df
0004a0 9478
0004a1 e000
0004a2 9300 00ac
0004a4 2700
0004a5 9300 00ad
0004a7 ea0a
0004a8 b908
0004a9 2433
0004aa ec00
0004ab d081
0004ac d09a
0004ad ef0f
0004ae d089
0004af d097
0004b0 2ce8
0004b1 9433
0004b2 e604
0004b3 2ef0
0004b4 b106
0004b5 9500
0004b6 b908
0004b7 d0ae
0004b8 934f
0004b9 eb3f
0004ba 9330 010b
0004bc ef0f
0004bd 954a
0004be f7f1
0004bf 9140 0109
0004c1 704f
0004c2 304f
0004c3 f041
0004c4 e038
0004c5 2343
0004c6 f429
0004c7 ef0f
0004c8 2f00
0004c9 b908
0004ca d08f
0004cb c001
0004cc 2700
0004cd 914f
0004ce fd00
0004cf dee8
0004d0 94fa
0004d1 f729
0004d2 ef0f
0004d3 d064
0004d4 d072
0004d5 94ea
0004d6 f6d1
0004d7 2700
0004d8 b908
0004d9 94f8
0004da 90df
0004db 90ef
0004dc 90ff                      		travelling
0004dd ef0f                      		ldi temp, 0xFF
0004de 1505                      		cp temp, r5
0004df f411                      		brne cont2_relay
0004e0 940c 04e4                 		jmp cancer
0004e2 940c 0529                 		cont2_relay: jmp cont2
                                 		cancer:
0004e4 e001
0004e5 d047
0004e6 d060
0004e7 e504
0004e8 d04f
0004e9 d05d
0004ea e502
0004eb d04c
0004ec d05a
0004ed e401
0004ee d049
0004ef d057
0004f0 e409
0004f1 d046
0004f2 d054
0004f3 e40e
0004f4 d043
0004f5 d051
0004f6 e200
0004f7 d040
0004f8 d04e
0004f9 e503
0004fa d03d
0004fb d04b
0004fc e504
0004fd d03a
0004fe d048
0004ff e40f
000500 d037
000501 d045
000502 e500
000503 d034
000504 d042
000505 e500
000506 d031
000507 d03f
000508 e409
000509 d02e
00050a d03c
00050b e40e
00050c d02b
00050d d039
00050e e407
00050f d028
000510 d036
000511 ec00
000512 d01a
000513 d033
000514 2700
000515 9300 00ac
000517 9300 00ad
000519 2cf6
00051a 24ee
00051b 2700
00051c b908
00051d e604
00051e 2ee0
00051f b106
000520 9503
000521 b908
000522 d043
000523 94ea
000524 f7d1
000525 94fa
000526 f7b1
000527 e000
000528 2e50                      		stopping
                                 
                                 		cont2:
000529 9109                      		ld temp, y+
00052a 2e80                      		mov TravelTime, temp
                                 		;ascii_print stoptime
                                 		;rcall delay_100ms
00052b 940c 0475                 		jmp RP_loop
                                 
                                 
                                 ;//=== Read and Print Stations End ===\\
                                 
                                 
                                 ;//=== LCD screen commands ===\\\
                                 	.equ LCD_RS = 7
                                 	.equ LCD_E = 6
                                 	.equ LCD_RW = 5
                                 	.equ LCD_BE = 4
                                 
                                 	.macro lcd_set
                                 		sbi PORTA, @0
                                 	.endmacro
                                 	.macro lcd_clr
                                 		cbi PORTA, @0
                                 	.endmacro
                                 
                                 	; Send a command to the LCD (temp)
                                 		lcd_command:
00052d bb01                      			out PORTF, temp
00052e 0000                      			nop
00052f 9a16                      			lcd_set LCD_E
000530 0000                      			nop
000531 0000                      			nop
000532 0000                      			nop
000533 9816                      			lcd_clr LCD_E
000534 0000                      			nop
000535 0000                      			nop
000536 0000                      			nop
000537 9508                      			ret
                                 
                                 		lcd_data:
000538 bb01                      			out PORTF, temp
000539 9a17                      			lcd_set LCD_RS
00053a 0000                      			nop
00053b 0000                      			nop
00053c 0000                      			nop
00053d 9a16                      			lcd_set LCD_E
00053e 0000                      			nop
00053f 0000                      			nop
000540 0000                      			nop
000541 9816                      			lcd_clr LCD_E
000542 0000                      			nop
000543 0000                      			nop
000544 0000                      			nop
000545 9817                      			lcd_clr LCD_RS
000546 9508                      			ret
                                 
                                 		lcd_wait:
000547 930f                      			push temp
000548 2700                      			clr temp
000549 bb00                      			out DDRF, temp
00054a bb01                      			out PORTF, temp
00054b 9a15                      			lcd_set LCD_RW
                                 		lcd_wait_loop:
00054c 0000                      			nop
00054d 9a16                      			lcd_set LCD_E
00054e 0000                      			nop
00054f 0000                      			nop
000550 0000                      			nop
000551 b10f                      			in temp, PINF
000552 9816                      			lcd_clr LCD_E
000553 fd07                      			sbrc temp, 7
000554 cff7                      			rjmp lcd_wait_loop
000555 9815                      			lcd_clr LCD_RW
000556 ef0f                      			ser temp
000557 bb00                      			out DDRF, temp
000558 910f                      			pop temp
000559 9508                      			ret
                                 	
                                 	delay_100ms:
00055a d004                      		rcall delay_30ms
00055b d003                      		rcall delay_30ms
00055c d002                      		rcall delay_30ms
00055d d008                      		rcall delay_10ms
00055e 9508                      		ret
                                 	
                                 	delay_30ms:
00055f 938f                      		push r24
000560 e18e                      		ldi r24, 30
                                 		delay_loop_loop:
000561 d004                      		rcall delay_10ms
000562 958a                      		dec r24
000563 f7e9                      		brne delay_loop_loop
000564 918f                      		pop r24
000565 9508                      		ret
                                 
                                 	delay_10ms: ;80000c
                                 		;prologue
000566 938f                      		push r24 ;2c
000567 939f                      		push r25 ;2c
000568 e99c                      		ldi r25, high(Delay_Counter) ;1c
000569 e38c                      		ldi r24, low(Delay_Counter) ;1c
                                 
                                 		delay_loop:
00056a 9701                      			sbiw r25:r24, 1 ;2c
00056b f7f1                      			brne delay_loop ;2c if looping 1c if pass through
00056c 919f                      			pop r25 ;2c
00056d 918f                      			pop r24 ;2c
00056e 0000                      			nop ;1c
00056f 0000                      			nop ;1c
000570 0000                      			nop ;1c
000571 9508                      			ret ;4c


RESOURCE USE INFORMATION
------------------------

Notice:
The register and instruction counts are symbol table hit counts,
and hence implicitly used resources are not counted, eg, the
'lpm' instruction without operands implicitly uses r0 and z,
none of which are counted.

x,y,z are separate entities in the symbol table and are
counted separately from r26..r31 here.

.dseg memory usage only counts static data declared with .byte

"ATmega2560" register use summary:
x  :   0 y  :   9 z  :  27 r0 :   2 r1 :   3 r2 :   3 r3 :   3 r4 :   0 
r5 :   3 r6 :   3 r7 :   5 r8 :   3 r9 :   0 r10:   0 r11:   0 r12:   7 
r13:   2 r14:   7 r15:  11 r16: 462 r17:  11 r18:  12 r19:  14 r20:  60 
r21:  23 r22:  19 r23:  11 r24:  17 r25:   4 r26:   0 r27:   0 r28:   5 
r29:   5 r30:   5 r31:   5 
Registers used: 28 out of 35 (80.0%)

"ATmega2560" instruction use summary:
.lds  :   0 .sts  :   0 adc   :   0 add   :  16 adiw  :   1 and   :   3 
andi  :   3 asr   :   0 bclr  :   0 bld   :   0 brbc  :   0 brbs  :   0 
brcc  :   0 brcs  :   0 break :   0 breq  :  28 brge  :   0 brhc  :   0 
brhs  :   0 brid  :   0 brie  :   0 brlo  :  12 brlt  :   0 brmi  :   0 
brne  :  20 brpl  :   0 brsh  :   2 brtc  :   0 brts  :   0 brvc  :   0 
brvs  :   0 bset  :   0 bst   :   0 call  :   7 cbi   :   5 cbr   :   0 
clc   :   0 clh   :   0 cli   :   2 cln   :   0 clr   :  38 cls   :   0 
clt   :   0 clv   :   0 clz   :   0 com   :   1 cp    :  11 cpc   :   0 
cpi   :  37 cpse  :   0 dec   :  11 eicall:   0 eijmp :   0 elpm  :   0 
eor   :   0 fmul  :   0 fmuls :   0 fmulsu:   0 icall :   0 ijmp  :   0 
in    :   4 inc   :  22 jmp   :  22 ld    :   6 ldd   :   0 ldi   : 335 
lds   :   3 lpm   :   0 lsl   :   5 lsr   :   0 mov   :  29 movw  :   0 
mul   :   2 muls  :   0 mulsu :   0 neg   :   0 nop   :  23 or    :   0 
ori   :   1 out   :  29 pop   :  11 push  :  11 rcall : 539 ret   :  21 
reti  :   1 rjmp  :  13 rol   :   1 ror   :   0 sbc   :   0 sbci  :   0 
sbi   :   5 sbic  :   0 sbis  :   0 sbiw  :   3 sbr   :   0 sbrc  :   3 
sbrs  :   0 sec   :   1 seh   :   0 sei   :   2 sen   :   0 ser   :   4 
ses   :   0 set   :   0 sev   :   0 sez   :   0 sleep :   0 spm   :   0 
st    :  27 std   :   0 sts   :  18 sub   :   5 subi  :   1 swap  :   0 
tst   :   0 wdr   :   0 
Instructions used: 45 out of 116 (38.8%)

"ATmega2560" memory use summary [bytes]:
Segment   Begin    End      Code   Data   Used    Size   Use%
---------------------------------------------------------------
[.cseg] 0x000000 0x000ae4   2788      0   2788  262144   1.1%
[.dseg] 0x000200 0x000279      0    121    121    8192   1.5%
[.eseg] 0x000000 0x000000      0      0      0    4096   0.0%

Assembly complete, 0 errors, 0 warnings
